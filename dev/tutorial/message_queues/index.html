<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Message queues · QuantumSavory.jl</title><meta name="title" content="Message queues · QuantumSavory.jl"/><meta property="og:title" content="Message queues · QuantumSavory.jl"/><meta property="twitter:title" content="Message queues · QuantumSavory.jl"/><meta name="description" content="Documentation for QuantumSavory.jl."/><meta property="og:description" content="Documentation for QuantumSavory.jl."/><meta property="twitter:description" content="Documentation for QuantumSavory.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="QuantumSavory.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumSavory.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">QuantumSavory.jl</a></li><li><a class="tocitem" href="../../manual/">Getting Started Manual</a></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../explanations/">Explanations</a></li><li><a class="tocitem" href="../../propbackgrounds/">Properties and Backgrounds</a></li><li><a class="tocitem" href="../../symbolics/">Symbolic Expressions</a></li><li><a class="tocitem" href="../../visualizations/">Visualizations</a></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Dev Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../register_interface/">Register Interface</a></li></ul></li></ul></li><li><span class="tocitem">How-To Guides</span><ul><li><a class="tocitem" href="../../howto/">How-To Guides</a></li><li><a class="tocitem" href="../../howto/firstgenrepeater/firstgenrepeater/">1st-gen Repeater</a></li><li><a class="tocitem" href="../../howto/firstgenrepeater/firstgenrepeater-clifford/">1st-gen Repeater (Clifford formalism)</a></li><li><a class="tocitem" href="../../howto/colorcentermodularcluster/colorcentermodularcluster/">Cluster States in Atomic Memories</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../">Tutorials</a></li><li><a class="tocitem" href="../noninstantgate/">Gate duration</a></li><li class="is-active"><a class="tocitem" href>Message queues</a><ul class="internal"><li><a class="tocitem" href="#Communication-delay"><span>Communication delay</span></a></li></ul></li></ul></li><li><span class="tocitem">References</span><ul><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../API/">API</a></li><li><a class="tocitem" href="../../API_CircuitZoo/">CircuitZoo API</a></li><li><a class="tocitem" href="../../API_StatesZoo/">StatesZoo API</a></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Message queues</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Message queues</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumSavory.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/master/docs/src/tutorial/message_queues.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Message-passing-and-queues"><a class="docs-heading-anchor" href="#Message-passing-and-queues">Message passing and queues</a><a id="Message-passing-and-queues-1"></a><a class="docs-heading-anchor-permalink" href="#Message-passing-and-queues" title="Permalink"></a></h1><p>In network simulations, a convenient synchronization primitive is the passing of messages between nodes. The <code>ResumableFunctions</code> and <code>ConcurrentSim</code> libraries provide such primitives, convenient to use with <code>QuatumSavory</code>.</p><p>Here we run through a simple example: there are two nodes that perform certain measurements. If the measurement result is the same, then the simulation ends. If the results differ, then we reset both nodes and try again. No actual physics will be simulated here (we will just generate some random numbers).</p><p>There are a number of convenient queue structures provided by these libraries. We will focus on <code>Store</code> and <code>DelayChannel</code> both of which are FILO stacks on which you can <code>put</code> messages or <code>get</code> messages.</p><p>We use <code>ConcurrentSim</code>&#39;s <code>@yield</code> and <code>@process</code> constructs to provide concurrency in our simulation.</p><p>First we create a <code>Simulation</code> object (to track the fictitious simulation time and currently active simulated process) and create a few FILO stacks for <code>put</code>ting and <code>get</code>ting messages.</p><pre><code class="language-julia hljs">using QuantumSavory
using ResumableFunctions
using ConcurrentSim
using CairoMakie

sim = Simulation()
channel_1to2 = Store{Bool}(sim) # message channel from node 1 to node 2
channel_2to1 = Store{Bool}(sim) # message channel from node 2 to node 1
channel_ready = Store{Bool}(sim) # message channel for announcing system reset is done</code></pre><p>Now we also define a process that will be executed independently by each of the nodes: it runs a measurement, it sends the measurement result to the other node, and it waits to get a message about the other node&#39;s result.</p><pre><code class="language-julia hljs">@resumable function do_random_measurement_transmit_receive_compare(sim, channel_out, channel_in)
    local_measurement = rand() &lt; 0.1 # 10% chance to get `true`
    put(channel_out, local_measurement)
    other_measurement = @yield get(channel_in)
    succeeded = local_measurement == other_measurement == true
    return succeeded
end</code></pre><p>The system reset function is itself rather simple: just a wait followed by messaging one of the nodes that the reset has finished.</p><pre><code class="language-julia hljs">@resumable function reset_system(sim)
    reset_duration = 1.0
    @yield timeout(sim, reset_duration)
    put(channel_ready, true)
end</code></pre><p>Last step of the setup is to write the event loops for each of the nodes. As a flowchart they look like the following:</p><div class="mermaid">
graph LR
  subgraph Node 2
    direction LR
    a[Make measurement]
    b[Send measurement result]
    c[Wait to receive<br>other node's<br>measurement]
    d{Measurements<br>match}
    e[End]
    f[Wait for<br>system reset<br>confirmation]

    a --> b --> c --> d --Yes--> e
    d --No--> f --> a
  end
  subgraph Node 1
    direction LR
    A[Make measurement]
    B[Send measurement result]
    C[Wait to receive<br>other node's<br>measurement]
    D{Measurements<br>match}
    E[End]
    F[Reset system]
    G[Message<br>that system<br>is reset]

    A --> B --> C --> D --Yes--> E
    D --No--> F --> G --> A
  end</div><p>And below we implement them in code:</p><pre><code class="language-julia hljs">@resumable function process_node1(sim)
    while true
        succeeded = @yield @process do_random_measurement_transmit_receive_compare(sim, channel_1to2, channel_2to1)
        if succeeded
            throw(StopSimulation(&quot;Success!&quot;))
        end
        @yield @process reset_system(sim)
    end
end

@resumable function process_node2(sim)
    while true
        succeeded = @yield @process do_random_measurement_transmit_receive_compare(sim, channel_2to1, channel_1to2)
        if succeeded
            throw(StopSimulation(&quot;Success!&quot;))
        end
        @yield get(channel_ready) # wait in case a reset was needed
    end
end</code></pre><p>Finally, we schedule the two concurrent processes and run the simulation until success.</p><pre><code class="language-julia hljs">@process process_node1(sim)
@process process_node2(sim)

ConcurrentSim.run(sim)
time_before_success = now(sim)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">159.0</code></pre><h2 id="Communication-delay"><a class="docs-heading-anchor" href="#Communication-delay">Communication delay</a><a id="Communication-delay-1"></a><a class="docs-heading-anchor-permalink" href="#Communication-delay" title="Permalink"></a></h2><p>Classical communication delay might be important too. There are FILO storage stacks that can simulate that, e.g. <code>DelayChannel(sim, delay_time)</code> used instead of <code>Storage(sim)</code>. Below we augment the example from above with such a delay channel and we also add some crude instrumentation and plotting.</p><pre><code class="language- hljs">sim = Simulation()
communication_delay = 1.0
channel_1to2 = DelayChannel{Bool}(sim, communication_delay)
channel_2to1 = DelayChannel{Bool}(sim, communication_delay)
channel_ready = DelayChannel{Bool}(sim, communication_delay)

global_log = []

@resumable function do_random_measurement_transmit_receive_compare(sim, channel_out, channel_in)
    @yield timeout(sim, 2+rand())   # wait for the measurement to take place
    local_measurement = rand() &lt; 0.4 # simulate a random measurement result
    put(channel_out, local_measurement)
    other_measurement = @yield get(channel_in)
    succeeded = local_measurement == other_measurement == true
    return succeeded
end

@resumable function reset_system(sim)
    s = now(sim)
    reset_duration = 2.0
    @yield timeout(sim, reset_duration)
    put(channel_ready, true)
    push!(global_log, (:reset_system, s, now(sim)))
end

@resumable function process_node1(sim)
    while true
        s = now(sim)
        succeeded = @yield @process do_random_measurement_transmit_receive_compare(sim, channel_1to2, channel_2to1)
        if succeeded
            throw(StopSimulation(&quot;Success!&quot;))
        end
        push!(global_log, (:node_1_meas_tx_rx, s, now(sim)))
        s2 = now(sim)
        @yield @process reset_system(sim)
        push!(global_log, (:node_1_wait_for_reset, s2, now(sim)))
    end
end

@resumable function process_node2(sim)
    while true
        s = now(sim)
        succeeded = @yield @process do_random_measurement_transmit_receive_compare(sim, channel_2to1, channel_1to2)
        if succeeded
            throw(StopSimulation(&quot;Success!&quot;))
        end
        push!(global_log, (:node_2_meas_tx_rx, s, now(sim)))
        s2 = now(sim)
        @yield get(channel_ready)
        push!(global_log, (:node_2_wait_for_reset, s2, now(sim)))
    end
end

@process process_node1(sim)
@process process_node2(sim)

ConcurrentSim.run(sim)

fig = Figure()
ax = Axis(fig[1,1],xlabel=&quot;time&quot;)
hideydecorations!(ax)

for (i, symbol) in enumerate([:node_1_meas_tx_rx,:node_2_meas_tx_rx,:reset_system,:node_1_wait_for_reset,:node_2_wait_for_reset])
    x_coords = [(x₀, x₁)
        for (s, x₀, x₁) in global_log
        if s==symbol]
    coords = [(Point(x₀,y+i/5),Point(x₁,y+i/5)) for (y,(x₀, x₁)) in enumerate(x_coords)]
    linesegments!(coords,color=Cycled(i),label=string(symbol),linewidth=10)
    flat_coords = collect(Iterators.flatten(coords))
    scatter!(flat_coords,color=Cycled(i))
end
axislegend(ax)
fig</code></pre><p>The horizontal axis is simulation time. We plot the periods during which one of the following is happening:</p><ul><li>node 1 is performing a measurement or transmits/receives messages</li><li>same for node 2</li><li>the system reset is happening</li><li>node 1 is waiting on the system reset (which happens local to it)</li><li>node 2 is waiting to receive a message that the system reset happened.</li></ul><p>As you can see, node 1 can start measurements before node 2 has heard that the system reset has happened, due to the communication delay.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../noninstantgate/">« Gate duration</a><a class="docs-footer-nextpage" href="../../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Wednesday 15 November 2023 04:51">Wednesday 15 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

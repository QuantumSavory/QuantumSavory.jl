<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gate duration · QuantumSavory.jl</title><meta name="title" content="Gate duration · QuantumSavory.jl"/><meta property="og:title" content="Gate duration · QuantumSavory.jl"/><meta property="twitter:title" content="Gate duration · QuantumSavory.jl"/><meta name="description" content="Documentation for QuantumSavory.jl."/><meta property="og:description" content="Documentation for QuantumSavory.jl."/><meta property="twitter:description" content="Documentation for QuantumSavory.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/init.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="QuantumSavory.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumSavory.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">QuantumSavory.jl</a></li><li><a class="tocitem" href="../../manual/">Getting Started Manual</a></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../../explanations/">Explanations</a></li><li><a class="tocitem" href="../../register_interface/">Register Interface</a></li><li><a class="tocitem" href="../../propbackgrounds/">Properties and Backgrounds</a></li><li><a class="tocitem" href="../../symbolics/">Symbolic Expressions</a></li><li><a class="tocitem" href="../../tag_query/">Tagging and Querying</a></li><li><a class="tocitem" href="../../visualizations/">Visualizations</a></li></ul></li><li><span class="tocitem">How-To Guides</span><ul><li><a class="tocitem" href="../../howto/">How-To Guides</a></li><li><a class="tocitem" href="../../howto/firstgenrepeater/firstgenrepeater/">1st-gen Repeater</a></li><li><a class="tocitem" href="../../howto/firstgenrepeater/firstgenrepeater-clifford/">1st-gen Repeater (Clifford formalism)</a></li><li><a class="tocitem" href="../../howto/colorcentermodularcluster/colorcentermodularcluster/">Cluster States in Atomic Memories</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../">Tutorials</a></li><li class="is-active"><a class="tocitem" href>Gate duration</a><ul class="internal"><li><a class="tocitem" href="#Approach-1:-Apply-an-instantaneous-gate-and-then-simply-wait"><span>Approach 1: Apply an instantaneous gate and then simply wait</span></a></li><li><a class="tocitem" href="#Approach-2:-Wait-and-then-apply-an-instantaneous-gate"><span>Approach 2: Wait and then apply an instantaneous gate</span></a></li><li><a class="tocitem" href="#Approach-3:-The-[NonInstantGate](@ref)"><span>Approach 3: The <code>NonInstantGate</code></span></a></li><li><a class="tocitem" href="#Approach-4:-Continuous-application-of-a-Hamiltonian"><span>Approach 4: Continuous application of a Hamiltonian</span></a></li><li><a class="tocitem" href="#Summary-and-comparison-of-all-results"><span>Summary and comparison of all results</span></a></li></ul></li></ul></li><li><span class="tocitem">References</span><ul><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../API/">API</a></li><li><a class="tocitem" href="../../API_CircuitZoo/">CircuitZoo API</a></li><li><a class="tocitem" href="../../API_StatesZoo/">StatesZoo API</a></li><li><a class="tocitem" href="../../API_ProtocolZoo/">ProtocolZoo API</a></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Gate duration</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gate duration</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumSavory.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/master/docs/src/tutorial/noninstantgate.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Gate-duration,-i.e.-gates-that-are-not-instant"><a class="docs-heading-anchor" href="#Gate-duration,-i.e.-gates-that-are-not-instant">Gate duration, i.e. gates that are not instant</a><a id="Gate-duration,-i.e.-gates-that-are-not-instant-1"></a><a class="docs-heading-anchor-permalink" href="#Gate-duration,-i.e.-gates-that-are-not-instant" title="Permalink"></a></h1><p>There are a number of different ways to represent a gate that is not instantaneous in <code>QuantumSavory</code>. They are not necessarily equivalent. Here we show a couple of typical approaches.</p><p>We start with a quick initial setup of a register with two qubits and an observable <code>pop</code> representing the population in the excited state in the Z basis. The gate duration will be set to <code>1.0</code> (as given in <code>ts</code>) and the qubits will have decay time <code>T1 = 2.0</code> so that we can more clearly demonstrate effects due to the non-instant nature of the gate.</p><pre><code class="language-julia hljs">using QuantumSavory
using CairoMakie

T1 = 2.0
reg = Register([Qubit(), Qubit()], [nothing, T1Decay(T1)])
initialize!(reg[1], Z₂)
initialize!(reg[2], Z₂)

pop = SProjector(Z₂)
initial_pop = observable(reg[2], pop)

STEPS = 20
ts = range(0,1,length=STEPS)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0:0.05263157894736842:1.0</code></pre><h2 id="Approach-1:-Apply-an-instantaneous-gate-and-then-simply-wait"><a class="docs-heading-anchor" href="#Approach-1:-Apply-an-instantaneous-gate-and-then-simply-wait">Approach 1: Apply an instantaneous gate and then simply wait</a><a id="Approach-1:-Apply-an-instantaneous-gate-and-then-simply-wait-1"></a><a class="docs-heading-anchor-permalink" href="#Approach-1:-Apply-an-instantaneous-gate-and-then-simply-wait" title="Permalink"></a></h2><p>A rather manual and simple approach. We will plot the value of the population observable over the entire waiting period.</p><pre><code class="language-julia hljs">reg_gate_wait = deepcopy(reg) # copy the register
apply!([reg_gate_wait[1],reg_gate_wait[2]], CNOT)
pop_gate_wait = [observable(reg_gate_wait[2], pop; time) for time in ts]</code></pre><img src="4e95217f.png" alt="Example block output"/><p>Given that the gate flips from the initial excited state to the ground state, the T1 decay does not have any effect.</p><h2 id="Approach-2:-Wait-and-then-apply-an-instantaneous-gate"><a class="docs-heading-anchor" href="#Approach-2:-Wait-and-then-apply-an-instantaneous-gate">Approach 2: Wait and then apply an instantaneous gate</a><a id="Approach-2:-Wait-and-then-apply-an-instantaneous-gate-1"></a><a class="docs-heading-anchor-permalink" href="#Approach-2:-Wait-and-then-apply-an-instantaneous-gate" title="Permalink"></a></h2><pre><code class="language-julia hljs">reg_wait_gate = deepcopy(reg)
pop_wait_gate = [observable(reg_wait_gate[2], pop; time) for time in ts]
apply!([reg_wait_gate[1],reg_wait_gate[2]], CNOT)
final_pop_wait_gate = observable(reg_wait_gate[2], pop)</code></pre><img src="8cbb7b6e.png" alt="Example block output"/><p>There has been significant decay before the gate is applied, which leads to only partially flipping the state (which is also mixed).</p><h2 id="Approach-3:-The-[NonInstantGate](@ref)"><a class="docs-heading-anchor" href="#Approach-3:-The-[NonInstantGate](@ref)">Approach 3: The <a href="../../API/#QuantumSavory.NonInstantGate"><code>NonInstantGate</code></a></a><a id="Approach-3:-The-[NonInstantGate](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Approach-3:-The-[NonInstantGate](@ref)" title="Permalink"></a></h2><pre><code class="language-julia hljs">using QuantumSavory: NonInstantGate

reg_slow_cnot = deepcopy(reg)
gate = NonInstantGate(CNOT, 1.0)
apply!([reg_slow_cnot[1],reg_slow_cnot[2]], CNOT)
final_pop_slow_cnot = observable(reg_slow_cnot[2], pop)</code></pre><img src="d767cacb.png" alt="Example block output"/><p><code>NonInstantGate</code> is convenient way to store a &quot;gate duration&quot; together with an arbitrary gate. As it does not permit sampling while the gate is being performed, we have only initial and final state. Internally, this is implemented by applying the gate instantaneously and then waiting.</p><h2 id="Approach-4:-Continuous-application-of-a-Hamiltonian"><a class="docs-heading-anchor" href="#Approach-4:-Continuous-application-of-a-Hamiltonian">Approach 4: Continuous application of a Hamiltonian</a><a id="Approach-4:-Continuous-application-of-a-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Approach-4:-Continuous-application-of-a-Hamiltonian" title="Permalink"></a></h2><p>The approximation of a gate+waiting above might be inappropriate for real systems (or at least it might be difficult to calibrate). Instead, one can simply provide the Hamiltonian that implements a give gate and <code>QuantumSavory</code> will automatically solve the corresponding dynamical equation.</p><p>Below we do it in two different ways: A single evolution for duration <code>1.0</code> (which does not permit sampling of the state in intermediary times):</p><pre><code class="language-julia hljs">reg_slow_ham  = deepcopy(reg)
ham_gate = ConstantHamiltonianEvolution(pi/2*SProjector(Z₂)⊗σˣ,1.0)
apply!([reg_slow_ham[1],reg_slow_ham[2]], ham_gate)
final_pop_slow_ham = observable(reg_slow_ham[2], pop)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.1456365102085479 + 0.0im</code></pre><p>... and the same but performed in multiple separate steps in order to be able to plot the intermediary results:</p><pre><code class="language-julia hljs">reg_slow_ham_steps  = deepcopy(reg)
ham_gate_step = ConstantHamiltonianEvolution(pi/2*SProjector(Z₂)⊗σˣ, ts[2])
pop_slow_ham_steps = [
    begin
        apply!([reg_slow_ham_steps[1], reg_slow_ham_steps[2]], ham_gate_step)
        observable(reg_slow_ham_steps[2], pop)
    end
    for _ in 2:STEPS
]</code></pre><img src="68153ab2.png" alt="Example block output"/><h2 id="Summary-and-comparison-of-all-results"><a class="docs-heading-anchor" href="#Summary-and-comparison-of-all-results">Summary and comparison of all results</a><a id="Summary-and-comparison-of-all-results-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-and-comparison-of-all-results" title="Permalink"></a></h2><p>Below we plot the results of each approach. As you can see, they are physically different and it might be important to calibrate them carefully to the situation at hand.</p><pre><code class="language-julia hljs">all_pop_gate_wait = real.([initial_pop, pop_gate_wait...])
all_pop_wait_gate = real.([initial_pop, pop_wait_gate..., final_pop_wait_gate])
all_pop_slow_ham_steps = real.([initial_pop, pop_slow_ham_steps...])
fig = Figure(size=(600,300))
axis = Axis(fig[1,1])
lines!([0,ts...], all_pop_gate_wait, color=Cycled(1), label=&quot;apply gate then wait&quot;)
lines!([0,ts...,ts[end]], all_pop_wait_gate, color=Cycled(2), label=&quot;wait then apply gate&quot;)
scatter!([0,ts[end]], real.([initial_pop, final_pop_slow_cnot]), color=Cycled(3), label=&quot;NonInstantGate&quot;)
scatter!([0,ts[end]], real.([initial_pop, final_pop_slow_ham]), color=Cycled(4), label=&quot;Hamiltonian&quot;, marker=&#39;▴&#39;, markersize=18)
lines!(ts, all_pop_slow_ham_steps, color=Cycled(5), label=&quot;Hamiltonian (steps)&quot;)
fig[1, 2] = Legend(fig, axis, &quot;Implementation&quot;, framevisible = false)
fig</code></pre><img src="22fc77b9.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Tutorials</a><a class="docs-footer-nextpage" href="../../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 3 June 2024 18:01">Monday 3 June 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"propbackgrounds/#Properties-and-Backgrounds","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"","category":"section"},{"location":"propbackgrounds/","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"propbackgrounds/","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"When creating a new registers, you can specify what type of physical system it will contain in each slot, e.g. a QubitTrait or a qudit or a harmonic oscillator or a propagating wave packet.","category":"page"},{"location":"propbackgrounds/","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"For each subsystem (slot in the register), you also specify what background processes and noise parameters describe it. For instance, it could be a T1Decay or T2Dephasing process, or a coherent error, or a non-Markovian bath.","category":"page"},{"location":"visualizations/#Visualizations","page":"Visualizations","title":"Visualizations","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The registersgraph_axis function can be used to draw a given set of registers, together with the quantum states they contain. It also provides interactive tools for inspecting the content of various registers.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The resourceplot_axis function can be used to draw all locks and resources stored in a meta-graph governing a discrete event simulation.","category":"page"},{"location":"howto-firstgenrepeater/#First-Generation-Quantum-Repeater","page":"1st-gen Repeater","title":"First Generation Quantum Repeater","text":"","category":"section"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"There is a convenient classification of quantum repeaters by their logical capabilities[1]. The first, simplest, generation of quantum repeaters involves the generation of physical (unencoded) entangled qubits between neighboring nodes, followed by entanglement swap and entanglement purification operation. No error correcting codes are employed and establishing of a link is a probabilistic process.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"[1]: Sreraman Muralidharan, Linshu Li, Jungsang Kim, Norbert L{\\\"u}tkenhaus, Mikhail D Lukin, Liang Jiang (2016)","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"We will build a simplistic simulator for such a network.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"We will employ Schroedinger representation (Schroedinger, Lindblad, and other master equation will be used behind the scenes, but we will not need to work at that low level);\nWe will consider a chain of quantum repeater nodes of various sizes (number of qubits);\nThe goal would be to entangle the extreme ends of the chain:\nBy directly entangling nearest neighbors;\nFollowed by entanglement swaps to extend the links;\nAnd entanglement purification to increase the quality of the links.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"For organizing the simulation and simplifying the digital and analog quantum dynamics, we will use the star of QuantumSavory.jl, namely the Register data structure.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Moreover, we will use:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"SimJulia.jl for discrete event scheduling and simulation;\nMakie.jl together with our custom plotting recipes for visualizations;\nMetaGraphs.jl for a convenient data structure to track per-node metadata in a graph;\nQuantumOptics.jl for low-level quantum states.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The full simulation script is available at the bottom.","category":"page"},{"location":"howto-firstgenrepeater/#The-Underlying-Data-Structures","page":"1st-gen Repeater","title":"The Underlying Data Structures","text":"","category":"section"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"While the quantum dynamics would be encapsulated in a Register data structure, it is convenient to also set up structures that track the overall topology and events on the network. Our preferred way to do that is to use the meta-graph data structures from MetaGraphs.jl, which lets you construct a graph and attach arbitrary meta-data to each edge and vertex. While this is not required for using QuantumSavory.jl, it is convenient, and we provide a lot of debugging tools that assume the use of meta-graphs.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Given an array of register sizes, e.g. sizes = [2,3,4,3,2], we will create a linear graph, where each node has the prescribed number of qubits, e.g.: ","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"(Image: An image of 5 quantum registers)","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<!--\nsim, mgraph = simulation_setup([2,3,4,3,2], 10.); f=Figure(resolution=(400,400)); registersgraph_axis(f,[get_prop(mgraph,n,:register) for n in vertices(mgraph)]; graph=mgraph)[2].title=\"Five Registers\"; save(\"fisrtgenrepeater-01.graph.png\",f)\n-->","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The meta-graph would contain, on each node:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"a Register of the appropriate size (as the :register property);\nan array of tuples keeping track of whom each qubit in the register is entangled to (as the :enttracker property);\nan array of locks (from SimJulia.jl) keeping track of whether a process is happening on the given qubit (as the :locks property).","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"note: Note\nTo see how to visualize these data structures as the simulation is proceeding, consult the Visualizations page.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"note: Note\nTo see how to define imperfections, noise processes, and background events, consult the Sub-system Properties page.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to expand and see code used to set up the meta-graph and registers</summary>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"\"\"\"Creates the datastructures representing the simulated network\"\"\"\nfunction simulation_setup(\n    sizes, # Array giving the number of qubits in each node\n    T2 # T2 dephasing times for the qubits\n    )\n    R = length(sizes) # Number of registers\n\n    # A scheduler datastructure for the discrete event simulation\n    sim = Simulation()\n\n    # A graph structure defining the connectivity among registers\n    # It is not necessary to use such a structure, however, it is a convenient way to\n    # store data about the simulation (and we have created helper plotting functions\n    # expecting such a structure).\n    _graph = grid([R])\n    mgraph = MetaGraph(_graph) # Meta graphs can contain extra meta information\n\n    # Add a register datastructures and event locks to each node.\n    for v in vertices(mgraph)\n        # Create and store a qubit register at each node\n        lay = Layout([QubitTrait() for i in 1:sizes[v]])\n        bg = [T2Dephasing(T2) for i in 1:sizes[v]]\n        set_prop!(mgraph, v,\n            :register,\n            Register(lay,bg,Symbol(v)))\n        # Create an array specifying wheater a qubit is entangled with another qubit\n        set_prop!(mgraph, v,\n            :enttrackers,\n            Any[nothing for i in 1:sizes[v]])\n        # Create an array of locks, telling us whether a qubit is undergoing an operation\n        set_prop!(mgraph, v,\n            :locks,\n            [Resource(sim,1) for i in 1:sizes[v]])\n    end\n\n    sim, mgraph\nend","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto-firstgenrepeater/#Entangler","page":"1st-gen Repeater","title":"Entangler","text":"","category":"section"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The first set of processes we need is the \"entanglers\" that enable nearest-neighbor entanglement generation:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-02.entangler.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"They run in parallel on each edge of the graph, set up by an invocation similar to the following:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"for (;src, dst) in edges(mgraph)\n    @process entangler(sim, mgraph, src, dst, ...)\nend","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"As seen in the following flow chart, the entangler repeatedly checks for available pairs of unused qubit slots and attempts to entangle them.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<div class=\"mermaid\">\ngraph LR\n    A[Entangler starts<br>on node A and B]\n    B{Are there<br>unused qubits on<br>node A and B?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>available qubits])\n    D --> E[Run entanglement<br>generation]\n    E --> F[Write down<br>who was entangled]\n    F --> G([Unlock the<br>qubits])\n    G --> B\n</div>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to see the implementation of the Entangler process</summary>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"@resumable function entangler(\n    sim::Environment,   # The scheduler for all simulation events\n    mgraph,             # The graph of qubit nodes\n    nodea, nodeb,       # The two nodes which we will be entangling\n    F,                  # The raw entanglement fidelity\n    entangler_wait_time,# The wait time in case all qubits are \"busy\"\n    entangler_busy_time # How long it takes to establish entanglement\n    )\n    while true\n        ia = findfreequbit(mgraph, nodea)\n        ib = findfreequbit(mgraph, nodeb)\n        if isnothing(ia) || isnothing(ib)\n            @yield timeout(sim, entangler_wait_time)\n            continue\n        end\n        locka = get_prop(mgraph,nodea,:locks)[ia]\n        lockb = get_prop(mgraph,nodeb,:locks)[ib]\n        @yield request(locka) & request(lockb)\n        registera = get_prop(mgraph,nodea,:register)\n        registerb = get_prop(mgraph,nodeb,:register)\n        @yield timeout(sim, entangler_busy_time)\n        initialize!([registera,registerb],[ia,ib],noisy_pair(F); time=now(sim))\n        get_prop(mgraph,nodea,:enttrackers)[ia] = (node=nodeb,slot=ib)\n        get_prop(mgraph,nodeb,:enttrackers)[ib] = (node=nodea,slot=ia)\n        @simlog sim \"entangled node $(nodea):$(ia) and node $(nodeb):$(ib)\"\n        release(locka)\n        release(lockb)\n    end\nend\n\n\"\"\"Find an uninitialized unlocked qubit on a given node\"\"\"\nfunction findfreequbit(mgraph, node)\n    register = get_prop(mgraph,node,:register)\n    locks = get_prop(mgraph,node,:locks)\n    regsize = nsubsystems(register)\n    findfirst(i->!isassigned(register,i) & isfree(locks[i]), 1:regsize)\nend","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto-firstgenrepeater/#Swapper","page":"1st-gen Repeater","title":"Swapper","text":"","category":"section"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Once we have the raw nearest-neighbor entanglement, we can proceed with swap operations that link two Bell pairs that share one common node into a longer Bell pair:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-03.swapper.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"They run in parallel on each vertex of the graph, set up by an invocation similar to the following:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"for node in vertices(mgraph)\n    @process swapper(sim, mgraph, node, ...)\nend","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The Swapper working on a given node simply checks whether there are any qubits on that node that are entangled with other nodes, both on the left and right of the current node. If such qubits are found, the entanglement swap operation is performed on them, as seen in this flowchart.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<div class=\"mermaid\">\ngraph LR\n    A[Swapper starts<br>on node A]\n    B{Are there<br>qubits entangled with A<br>both on the left and right<br>of A?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>local qubits])\n    D --> E[Run entanglement<br>swapping]\n    E --> F[Write down<br>how the entanglement<br>was redistributed]\n    F --> G([Unlock and erase<br>the local qubits])\n    G --> B\n</div>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The entanglement swap operation is performed through the following simple circuit, which entangles the two local qubits belonging to two separate Bell pairs, and then measures them:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<img alt=\"Entanglement swapping circuit\" src=\"../firstgenrepeater-04.swapcircuit.png\" style=\"max-width:50%\">\n<!--\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CNOT(2, 3),\n Measurement(\"X\", 2, 1),\n ClassicalDecision(\"Z\", 1, 1),\n Measurement(\"Z\", 3, 2),\n ClassicalDecision(\"X\", 4, 2)]\n -->","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The code implementing such a circuit looks like the following (where reg is the register on which swapping happens, and regL/regR are the remote registers on the left and right):","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"apply!([reg,reg], [qubit1,qqubit2], Gates.CNOT; time=now(sim))\nxmeas = project_traceout!(reg, qubit1, [States.X₀, States.X₁])\nzmeas = project_traceout!(reg, qubit2, [States.Z₀, States.Z₁])\nif xmeas==2\n    apply!([regL], [qubitL], Gates.Z)\nend\nif zmeas==2\n    apply!([regR], [qubitR], Gates.X)\nend","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to see the implementation of the Swapper process</summary>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"@resumable function swapper(\n    sim::Environment, # The scheduler for all simulation events\n    mgraph,           # The graph of qubit nodes\n    node,             # The node on which the swapper works\n    swapper_wait_time,# The wait time in case there are no available qubits for swapping\n    swapper_busy_time # How long it takes to perform the swap\n    )\n    while true\n        qubit_pair = findswapablequbits(mgraph,node)\n        if isnothing(qubit_pair)\n            @yield timeout(sim, swapper_wait_time)\n            continue\n        end\n        q1, q2 = qubit_pair\n        locks = get_prop(mgraph, node, :locks)[[q1,q2]]\n        @yield mapreduce(request, &, locks)\n        reg = get_prop(mgraph, node, :register)\n        @yield timeout(sim, swapper_busy_time)\n        apply!([reg,reg], [q1,q2], Gates.CNOT; time=now(sim))\n        xmeas = project_traceout!(reg, q1, [States.X₀, States.X₁])\n        zmeas = project_traceout!(reg, q2, [States.Z₀, States.Z₁])\n        node1 = get_prop(mgraph,node,:enttrackers)[q1]\n        reg1 = get_prop(mgraph,node1.node,:register)\n        if xmeas==2\n            apply!([reg1], [node1.slot], Gates.Z)\n        end\n        node2 = get_prop(mgraph,node,:enttrackers)[q2]\n        reg2 = get_prop(mgraph,node2.node,:register)\n        if zmeas==2\n            apply!([reg2], [node2.slot], Gates.X)\n        end\n        get_prop(mgraph,node1.node,:enttrackers)[node1.slot] = node2\n        get_prop(mgraph,node2.node,:enttrackers)[node2.slot] = node1\n        get_prop(mgraph,node,:enttrackers)[q1] = nothing\n        get_prop(mgraph,node,:enttrackers)[q2] = nothing\n        @simlog sim \"swap at $(node):$(q1)&$(q2) connecting $(node1) and $(node2)\"\n        release.(locks)\n    end\nend\n\nfunction findswapablequbits(mgraph,node)\n    enttrackers = get_prop(mgraph,node,:enttrackers)\n    locks = get_prop(mgraph,node,:locks)\n    left_nodes  = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node<node && isfree(locks[i])]\n    isempty(left_nodes)  && return nothing\n    right_nodes = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node>node && isfree(locks[i])]\n    isempty(right_nodes) && return nothing\n    _, farthest_left  = findmin(n->n.node, left_nodes)\n    _, farthest_right = findmax(n->n.node, right_nodes)\n    return left_nodes[farthest_left].i, right_nodes[farthest_right].i\nend","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto-firstgenrepeater/#Purifier","page":"1st-gen Repeater","title":"Purifier","text":"","category":"section"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Last but not least, there is the Purifier that searches for pairs of nodes that share more than one Bell pair. On such nodes a purification procedure can be performed:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-05.purifier.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"As you can see, not all purification attempts succeed. On some occasions there is a failure and both pairs get discarded as faulty. Each Purifier is running two purification circuits, one after the other, as a single round of purification is uncapable of detecting all types of errors. The two circuits being employed are the following:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<img alt=\"Entanglement purification circuit\" src=\"../firstgenrepeater-06.purcircuit1.png\" style=\"max-width:40%\">\n<img alt=\"Entanglement purification circuit\" src=\"../firstgenrepeater-06.purcircuit2.png\" style=\"max-width:40%\">\n<!--\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CNOT(1, 3),\n CNOT(2, 4),\n Measurement(\"X\", 1),\n Measurement(\"X\", 2)]\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CPHASE(1, 3),\n CPHASE(2, 4),\n Measurement(\"X\", 1),\n Measurement(\"X\", 2)]\n-->","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"If the coincidence measurements fail, all qubits are reset. If the coincidence measurements are correct, the purified pair would have higher fidelity than what it started with. To implement one of these circuits one can write something akin to the following, where regA and regB are the two registers who share two entangled pairs, and pairXqubitX specifies the slot for each of the qubits of each of the pairs:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"gate = Gates.CNOT # or Gates.CPHASE\napply!([regA,regA],[pair2qubit1,pair1qubit1],gate)\napply!([regB,regB],[pair2qubit2,pair1qubit2],gate)\nmeasbasis = [States.X₀, States.X₁]\nmeasa = project_traceout!(regA, pair2qubit1, measbasis)\nmeasb = project_traceout!(regB, pair2qubit2, measbasis)\nif measa!=measb\n    traceout!(regA, pair1qubit1)\n    traceout!(regB, pair1qubit2)\nend","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The overall structure of this process is similar to the Entangler and Swapper: repeatedly trying to lock four qubits belonging to two pairs shared by the same nodes, followed by performing the purification procedure.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<div class=\"mermaid\">\ngraph LR\n    A[Purifier starts<br>on nodes A and B]\n    B{Are there<br>two Bell pairs shared<br>between A and B?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>corresponding qubits])\n    D --> E[Run purification<br>and parity measurement]\n    E --> F{Coincidence<br>was observed?}\n    F --No--> F1[Reset<br>all qubits]\n    F --Yes--> F2[Preserve<br>purified qubits]\n    F1 --> G([Unlock<br>the qubits])\n    F2 --> G([Unlock<br>the qubits])\n    G --> B\n</div>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Purification processes are started on all pairs of nodes with an invocation like:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"for nodea in vertices(mgraph)\n    for nodeb in vertices(mgraph)\n        if nodeb>nodea\n            @process purifier(sim, mgraph, nodea, nodeb, ...)\n        end\n    end\nend","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to see the implementation of the Entangler process</summary>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"@resumable function purifier(\n    sim::Environment,  # The scheduler for all simulation events\n    mgraph,            # The graph of qubit nodes\n    nodea,             # One of the nodes on which the pairs to be purified rest\n    nodeb,             # The other such node\n    purifier_wait_time,# The wait time in case there are no pairs available for purification\n    purifier_busy_time # The duration of the purification circuit\n    )\n    round = 0\n    while true\n        pairs_of_bellpairs = findqubitstopurify(mgraph,nodea,nodeb)\n        if isnothing(pairs_of_bellpairs)\n            @yield timeout(sim, purifier_wait_time)\n            continue\n        end\n        pair1qa, pair1qb, pair2qa, pair2qb = pairs_of_bellpairs\n        locks = [get_prop(mgraph,nodea,:locks)[[pair1qa,pair2qa]];\n                 get_prop(mgraph,nodeb,:locks)[[pair1qb,pair2qb]]]\n        @yield mapreduce(request, &, locks)\n        @yield timeout(sim, purifier_busy_time)\n        rega = get_prop(mgraph,nodea,:register)\n        regb = get_prop(mgraph,nodeb,:register)\n        println((nodea,nodeb),(pair1qa, pair1qb, pair2qa, pair2qb))\n        gate = (Gates.CNOT, Gates.CPHASE)[round%2+1]\n        apply!([rega,rega],[pair2qa,pair1qa],gate)\n        apply!([regb,regb],[pair2qb,pair1qb],gate)\n        measbasis = [States.X₀, States.X₁]\n        measa = project_traceout!(rega, pair2qa, measbasis)\n        measb = project_traceout!(regb, pair2qb, measbasis)\n        if measa!=measb\n            traceout!(rega, pair1qa)\n            traceout!(regb, pair1qb)\n            get_prop(mgraph,nodea,:enttrackers)[pair1qa] = nothing\n            get_prop(mgraph,nodeb,:enttrackers)[pair1qb] = nothing\n            @simlog sim \"failed purification at $(nodea):$(pair1qa)&$(pair2qa) and $(nodeb):$(pair1qb)&$(pair2qb)\"\n        else\n            round += 1\n            @simlog sim \"purification at $(nodea):$(pair1qa) $(nodeb):$(pair1qb) by sacrifice of $(nodea):$(pair1qa) $(nodeb):$(pair1qb)\"\n        end\n        get_prop(mgraph,nodea,:enttrackers)[pair2qa] = nothing\n        get_prop(mgraph,nodeb,:enttrackers)[pair2qb] = nothing\n        release.(locks)\n    end\nend\n\nfunction findqubitstopurify(mgraph,nodea,nodeb)\n    enttrackers = get_prop(mgraph,nodea,:enttrackers)\n    locksa = get_prop(mgraph,nodea,:locks)\n    locksb = get_prop(mgraph,nodeb,:locks)\n    enttrackers = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node==nodeb && isfree(locksa[i]) && isfree(locksb[n.slot])]\n    if length(enttrackers)>=2\n        aqubits = [n.i for n in enttrackers[end-1:end]]\n        bqubits = [n.slot for n in enttrackers[end-1:end]]\n        return aqubits[2], bqubits[2], aqubits[1], bqubits[1]\n    else\n        return nothing\n    end\nend","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto-firstgenrepeater/#Running-the-simulations","page":"1st-gen Repeater","title":"Running the simulations","text":"","category":"section"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Now that we have defined the Entangler, Swapper, and Purifier processes, we just need to run the simulation. That is no different from running any other SimJulia.jl simulation, after our custom setup:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"sizes = [2,3,4,3,2]        # Number of qubits in each register\nT2 = 10.0                  # T2 dephasing time of all qubits\nF = 0.9                    # Fidelity of the raw Bell pairs\nentangler_wait_time = 0.1  # How long to wait if all qubits are busy before retring entangling\nentangler_busy_time = 1.0  # How long it takes to establish a newly entangled pair\nswapper_wait_time = 0.1    # How long to wait if all qubits are unavailable for swapping\nswapper_busy_time = 0.15   # How long it takes to swap two qubits\npurifier_wait_time = 0.15  # How long to wait if there are no pairs to be purified\npurifier_busy_time = 0.2   # How long the purification circuit takes to execute\n\nsim, mgraph = simulation_setup(sizes, T2)\n\n# run the entangler on each nearest-neighbor pair\nfor (;src, dst) in edges(mgraph)\n    @process entangler(sim, mgraph, src, dst, F, entangler_wait_time, entangler_busy_time)\nend\n# run the swapper on each node\nfor node in vertices(mgraph)\n    @process swapper(sim, mgraph, node, swapper_wait_time, swapper_busy_time)\nend\n# run the purifier on each pair of nodes\nfor nodea in vertices(mgraph)\n    for nodeb in vertices(mgraph)\n        if nodeb>nodea\n            @process purifier(sim, mgraph, nodea, nodeb, purifier_wait_time, purifier_busy_time)\n        end\n    end\nend","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Then to run the simulation up to time t we just write run(sim, t). If we want to run until the next event, whenever that is, we can do SimJulia.step(sim)","category":"page"},{"location":"howto-firstgenrepeater/#Figures-of-Merit-and-Visualizations","page":"1st-gen Repeater","title":"Figures of Merit and Visualizations","text":"","category":"section"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"These simulations are not particularly useful if we do not track the performance of the quantum network. One convenient way to do that is to compute observables related to the quality of entanglement, e.g., the XX and ZZ correlators. We will compute these correlators for the second pair on the extreme ends of the chain of repeaters:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-07.observable.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Notice how the XX observable drops due to the T₂ dephasing experienced by the qubits. And then it goes back up at the occurence of a successful purification (or all the way to zero at failed purifications). Here is what it looks like if we do not perform purification:","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-07.observable.nopur.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The plotting itself is realized with the wonderful Makie.jl plotting library. The figure of merrit is obtained through a call to observable, a convenient method for calculating expectation values of various quantum observables.","category":"page"},{"location":"howto-firstgenrepeater/#Summary-of-QuantumSavory-tools-employed-in-the-simulation","page":"1st-gen Repeater","title":"Summary of QuantumSavory tools employed in the simulation","text":"","category":"section"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"We used the Register data structure to automatically track the quantum states describing our mixed analog-digital quantum dynamics.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Much of the analog dynamics was implicit through the use of backgrounds, declaring the noise properties of various qubits.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The digital-ish dynamics was implemented through the use of","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"initialize! for setting inital states to various qubits\napply! for the application of various gates\ntraceout! for deleting qubits\nproject_traceout! for projective measurements over qubits\nobservable for calculating expectation values of quantum observables","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Many of the above functions take the time keyword argument, which ensures that various background analog processes are simulated before the given operation is performed.","category":"page"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Of note is that we also used Makie.jl for plotting, MetaGraphs.jl for convenient data structures, SimJulia.jl for discrete event scheduling, QuantumClifford.jl for efficient simulation of Clifford circuits, and QuantumOptics.jl for convenient master equation integration. Many of these tools were used under the hood without being invoked directly.","category":"page"},{"location":"howto-firstgenrepeater/#Full-Code","page":"1st-gen Repeater","title":"Full Code","text":"","category":"section"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The entirety of the code necessary for reproducing these results is in the examples folder of the QuantumSavory.jl repository.","category":"page"},{"location":"howto-firstgenrepeater/#Suggested-Improvements","page":"1st-gen Repeater","title":"Suggested Improvements","text":"","category":"section"},{"location":"howto-firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The first and most obvious improvement would be to trigger the various events (Entangler, Swapper, Purifier) from each other, instead of having them all randomly wait and hope the necessary resources are available.\nCalibrating when to perform a purification versus a swap would be important for the performance of the network.\nBalancing what types of entanglement purification is performed, depending on the type of noise experienced, can drastically lower resource requirements.\nImplementing more sophisticated purification schemes can greatly improve the quality of entanglement.","category":"page"},{"location":"howto-firstgenrepeater-clifford/#Clifford-Simulations-of-First-Generation-Quantum-Repeater","page":"1st-gen Repeater (Clifford formalism)","title":"Clifford Simulations of First Generation Quantum Repeater","text":"","category":"section"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"Here we will simulate a quantum repeater by employing a noisy Clifford circuit simulator.","category":"page"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"Be sure to check out the more detailed tutorial on wavefunction simulations of First Generation Quantum Repeater before proceeding with this one.","category":"page"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"The changes we need to perform to the code are incredibly small. We only change the way the initial states of the entangled pairs are set, without changing any of the code implementing the swapping and purification steps. We can do that by first defining a function that generates noisy Bell states (by randomly returning either a good stabilizer tableau with probability F or a completely depolarized tableau with probability 1-F).","category":"page"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"const qc_perfect_pair = QuantumClifford.MixedDestabilizer(QuantumClifford.bell())\nconst qc_mixed = QuantumClifford.traceout!(copy(qc_perfect_pair), [1,2])\nfunction qc_noisy_pair(F)\n    if rand() < F\n        return qc_perfect_pair\n    else\n        return qc_mixed\n    end\nend","category":"page"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"We then use that in the entangler setup (the same way we used a similar function when we were doing wavefunction simulations):","category":"page"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"# exerpt from `@resumable function entangler` in `firstgenrepeater_setup.jl`\n        initialize!([registera,registerb],[ia,ib],noisy_pair(); time=now(sim))","category":"page"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"For reference, here is the corresponding code for the wavefunction simulations:","category":"page"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"b = QuantumOptics.SpinBasis(1//2)\nl = QuantumOptics.spindown(b)\nh = QuantumOptics.spinup(b)\nqo_perfect_pair = (QuantumOptics.tensor(l,l) + QuantumOptics.tensor(h,h))/sqrt(2)\nconst qo_perfect_pair_dm = QuantumOptics.dm(qo_perfect_pair)\nconst qo_mixed = QuantumOptics.identityoperator(QuantumOptics.basis(qo_perfect_pair))/4\nfunction qo_noisy_pair(F)\n    F*qo_perfect_pair_dm + (1-F)*qo_mixed\nend","category":"page"},{"location":"howto-firstgenrepeater-clifford/#Simulation-Trace","page":"1st-gen Repeater (Clifford formalism)","title":"Simulation Trace","text":"","category":"section"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"Similarly to the wavefunction simulations from the previous tutorial, here we can see how the various observables evolve over time for a Clifford-base simulation. Notice that unlike the wavefunction simulation, the results are very discrete, and we will certainly need to average over multiple repeated simulations of this trajectory.","category":"page"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"<video src=\"../firstgenrepeater-08.clifford.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto-firstgenrepeater-clifford/#Comparison-Against-a-Wavefunction-based-Simulations","page":"1st-gen Repeater (Clifford formalism)","title":"Comparison Against a Wavefunction-based Simulations","text":"","category":"section"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"We can run the either simulation multiple times in order to compare the results from the wavefunction and tableau-based simulations:","category":"page"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"(Image: Comparison Against a Wavefunction-based Simulations)","category":"page"},{"location":"howto-firstgenrepeater-clifford/#Full-Code","page":"1st-gen Repeater (Clifford formalism)","title":"Full Code","text":"","category":"section"},{"location":"howto-firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"The entirety of the code necessary for reproducing these results is in the examples folder of the QuantumSavory.jl repository.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"","category":"page"},{"location":"#QuantumSavory.jl","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"A limited public demo of a fraction of some internal research code. Full code to be release shortly.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"danger: Danger\nThis is software is still in a fairly unstable alpha state! The documentation is extremely barebones and current users are expected to read the source code.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"A good place to start is the How-To pages. For instance, the implementation of a first generation repeater.","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [QuantumSavory]\nPrivate = false","category":"page"},{"location":"API/#QuantumSavory.QubitTrait","page":"API","title":"QuantumSavory.QubitTrait","text":"Specifies that a given register slot contains qubits.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Register","page":"API","title":"QuantumSavory.Register","text":"The main data structure in QuantumSavory, used to represent a quantum register in an arbitrary formalism.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.T1Decay","page":"API","title":"QuantumSavory.T1Decay","text":"A background describing the T₁ decay of a two-level system.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.T2Dephasing","page":"API","title":"QuantumSavory.T2Dephasing","text":"A background describing the T₂ dephasing of a two-level system.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.apply!-Tuple{Any, Any, Any}","page":"API","title":"QuantumSavory.apply!","text":"Apply a given operation on the given set of register slots.\n\napply!([regA, regB], [slot1, slot2], Gates.CNOT) would apply a CNOT gate on the content of the given registers at the given slots. The appropriate representatin of the gate is used, depending on the formalism under which a quantum state is stored in the given registers. The Hilbert spaces of the registers are automatically joined if necessary.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.initialize!-Tuple{Any, Any, Any}","page":"API","title":"QuantumSavory.initialize!","text":"Set the state of a given set of registers.\n\ninitialize!([regA,regB], [slot1,slot2], state) would set the state of the given slots in the given registers to state. state can be any supported state representation, e.g., kets or density matrices from QuantumOptics.jl or tableaux from QuantumClifford.jl.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.observable","page":"API","title":"QuantumSavory.observable","text":"Calculate the expectation value of a quantum observable on the given register and slot.\n\nobservable([regA, regB], [slot1, slot2], obs) would calculate the expectation value of the obs observable (using the appropriate formalism, depending on the state representation in the given registers).\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.project_traceout!","page":"API","title":"QuantumSavory.project_traceout!","text":"Perform a projective measurement on the given slot of the given register.\n\nproject_traceout!(reg, slot, [stateA, stateB]) performs a projective measurement, projecting on either stateA or stateB, returning the index of the subspace on which the projection happened. It assumes the list of possible states forms a basis for the Hilbert space. The Hilbert space of the register is automatically shrinked.\n\nA basis object can be specified on its own as well, e.g. project_traceout!(reg, slot, basis).\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.registersgraph_axis-Tuple{Any, Any}","page":"API","title":"QuantumSavory.registersgraph_axis","text":"Draw the given registers on a given Makie axis.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.resourceplot_axis-NTuple{5, Any}","page":"API","title":"QuantumSavory.resourceplot_axis","text":"Draw the various resources and locks stored in the given meta-graph on a given Makie axis.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.traceout!-Tuple{Register, Int64}","page":"API","title":"QuantumSavory.traceout!","text":"Delete the given slot of the given register.\n\ntraceout!(reg, slot) would reset (perform a partial trace) over the given subsystem. The Hilbert space of the register is automatically shrinked.\n\n\n\n\n\n","category":"method"}]
}

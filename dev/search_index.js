var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"The reference section of the documentation mostly consists of the API docs.","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"API_Symbolics/#QuantumSymbolics.jl-reference","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.jl reference","text":"","category":"section"},{"location":"API_Symbolics/","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.jl reference","text":"You can also consult the complete QuantumSymbolics.jl documentation.","category":"page"},{"location":"API_Symbolics/","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.jl reference","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API_Symbolics/#Autogenerated-API-list-for-QuantumSymbolics","page":"QuantumSymbolics.jl reference","title":"Autogenerated API list for QuantumSymbolics","text":"","category":"section"},{"location":"API_Symbolics/#QuantumSymbolics.CNOT","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.CNOT","text":"CNOT gate\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.CPHASE","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.CPHASE","text":"CPHASE gate\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Create","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Create","text":"Creation operator, also available as the constant âꜛ, in an infinite dimension Fock basis. There is no unicode dagger superscript, so we use the uparrow\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Destroy","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Destroy","text":"Annihilation operator, also available as the constant â, in an infinite dimension Fock basis.\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.F₁","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.F₁","text":"Single photon state\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.H","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.H","text":"Hadamard gate\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.I","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.I","text":"Identity operator in qubit basis\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.N","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.N","text":"Number operator, also available as the constant n̂, in an infinite dimension Fock basis.\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Pm","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Pm","text":"Pauli \"minus\" operator, also available as the constant σ₋\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Pp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Pp","text":"Pauli \"plus\" operator, also available as the constant σ₊\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.X","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.X","text":"Pauli X operator, also available as the constant σˣ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.X1","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.X1","text":"Basis state of σˣ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.X2","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.X2","text":"Basis state of σˣ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Y","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Y","text":"Pauli Y operator, also available as the constant σʸ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Y1","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Y1","text":"Basis state of σʸ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Y2","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Y2","text":"Basis state of σʸ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Z","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Z","text":"Pauli Z operator, also available as the constant σᶻ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Z1","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Z1","text":"Basis state of σᶻ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Z2","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Z2","text":"Basis state of σᶻ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.vac","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.vac","text":"Single-mode vacuum state\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.BeamSplitterOp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.BeamSplitterOp","text":"Two-mode beamsplitter operator in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.BosonicThermalState","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.BosonicThermalState","text":"Thermal bosonic state in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.CoherentState","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.CoherentState","text":"Coherent state in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.CreateOp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.CreateOp","text":"Creation (raising) operator.\n\njulia> f = FockState(2)\n|2⟩\n\njulia> create = CreateOp()\na†\n\njulia> qsimplify(create*f, rewriter=qsimplify_fock)\n(sqrt(3))|3⟩\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.DephasingCPTP","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.DephasingCPTP","text":"Single-qubit dephasing CPTP map\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.DestroyOp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.DestroyOp","text":"Annihilation (lowering or destroy) operator in defined Fock basis.\n\njulia> f = FockState(2)\n|2⟩\n\njulia> destroy = DestroyOp()\na\n\njulia> qsimplify(destroy*f, rewriter=qsimplify_fock)\n(sqrt(2))|1⟩\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.DisplaceOp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.DisplaceOp","text":"Displacement operator in defined Fock basis.\n\njulia> f = FockState(0)\n|0⟩\n\njulia> displace = DisplaceOp(im)\nD(im)\n\njulia> qsimplify(displace*f, rewriter=qsimplify_fock)\n|im⟩\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.FockState","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.FockState","text":"Fock state in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.GateCPTP","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.GateCPTP","text":"A unitary gate followed by a CPTP map\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.IdentityOp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.IdentityOp","text":"The identity operator for a given basis\n\njulia> IdentityOp(X1⊗X2)\n𝕀\n\njulia> express(IdentityOp(Z2))\nOperator(dim=2x2)\n  basis: Spin(1/2)sparse([1, 2], [1, 2], ComplexF64[1.0 + 0.0im, 1.0 + 0.0im], 2, 2)\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.KrausRepr","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.KrausRepr","text":"Kraus representation of a quantum channel\n\njulia> @op A₁; @op A₂; @op A₃;\n\njulia> K = kraus(A₁, A₂, A₃)\n𝒦(A₁,A₂,A₃)\n\njulia> @op ρ;\n\njulia> K*ρ\nA₁ρA₁†+A₂ρA₂†+A₃ρA₃†\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.MixedState","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.MixedState","text":"Completely depolarized state\n\njulia> MixedState(X1⊗X2)\n𝕄\n\njulia> express(MixedState(X1⊗X2))\nOperator(dim=4x4)\n  basis: [Spin(1/2) ⊗ Spin(1/2)]\n 0.25 + 0.0im        ⋅             ⋅             ⋅     \n       ⋅       0.25 + 0.0im        ⋅             ⋅\n       ⋅             ⋅       0.25 + 0.0im        ⋅\n       ⋅             ⋅             ⋅       0.25 + 0.0im\n\njulia> express(MixedState(X1⊗X2), CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n \n𝒳ₗ━━\n+ X_\n+ _X\n𝒮𝓉𝒶𝒷\n \n𝒵ₗ━━\n+ Z_\n+ _Z\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.NumberOp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.NumberOp","text":"Number operator.\n\njulia> f = FockState(2)\n|2⟩\n\njulia> num = NumberOp()\nn\n\njulia> qsimplify(num*f, rewriter=qsimplify_fock)\n2|2⟩\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.PauliNoiseCPTP","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.PauliNoiseCPTP","text":"Single-qubit Pauli noise CPTP map\n\njulia> apply!(express(Z1), [1], express(PauliNoiseCPTP(1/4,1/4,1/4)))\nOperator(dim=2x2)\n  basis: Spin(1/2)\n 0.5+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.0im\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.PhaseShiftOp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.PhaseShiftOp","text":"Phase-shift operator in defined Fock basis.\n\njulia> c = CoherentState(im)\n|im⟩\n\njulia> phase = PhaseShiftOp(pi)\nU(π)\n\njulia> qsimplify(phase*c, rewriter=qsimplify_fock)\n|1.2246467991473532e-16 - 1.0im⟩\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SAdd","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SAdd","text":"Addition of quantum objects (kets, operators, or bras).\n\njulia> @ket k₁; @ket k₂;\n\njulia> k₁ + k₂\n|k₁⟩+|k₂⟩\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SAnticommutator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SAnticommutator","text":"Symbolic anticommutator of two operators.\n\njulia> @op A; @op B;\n\njulia> anticommutator(A, B)\n{A,B}\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SApplyBra","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SApplyBra","text":"Symbolic application of an operator on a bra (from the right).\n\njulia> @bra b; @op A;\n\njulia> b*A\n⟨b|A\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SApplyKet","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SApplyKet","text":"Symbolic application of an operator on a ket (from the left).\n\njulia> @ket k; @op A;\n\njulia> A*k\nA|k⟩\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SBra","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SBra","text":"Symbolic bra\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SBraKet","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SBraKet","text":"Symbolic inner product of a bra and a ket.\n\njulia> @bra b; @ket k;\n\njulia> b*k\n⟨b||k⟩\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SCommutator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SCommutator","text":"Symbolic commutator of two operators.\n\njulia> @op A; @op B;\n\njulia> commutator(A, B)\n[A,B]\n\njulia> commutator(A, A)\n𝟎\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SConjugate","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SConjugate","text":"Complex conjugate of quantum objects (kets, bras, operators).\n\njulia> @op A; @ket k;\n\njulia> conj(A)\nAˣ\n\njulia> conj(k)\n|k⟩ˣ\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SDagger","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SDagger","text":"Dagger, i.e., adjoint of quantum objects (kets, bras, operators).\n\njulia> @ket a; @op A;\n\njulia> dagger(2*im*A*a)\n(0 - 2im)|a⟩†A†\n\njulia> @op B;\n\njulia> dagger(A*B)\nB†A†\n\njulia> ℋ = SHermitianOperator(:ℋ); U = SUnitaryOperator(:U);\n\njulia> dagger(ℋ)\nℋ\n\njulia> dagger(U)\nU⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SExpOperator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SExpOperator","text":"Exponential of a symbolic operator.\n\njulia> @op A; @op B;\n\njulia> exp(A)\nexp(A)\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SHermitianOperator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SHermitianOperator","text":"Symbolic Hermitian operator\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SHermitianUnitaryOperator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SHermitianUnitaryOperator","text":"Symbolic Hermitian and unitary operator\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SInvOperator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SInvOperator","text":"Inverse of an operator.\n\njulia> @op A;\n\njulia> inv(A)\nA⁻¹\n\njulia> inv(A)*A\n𝕀\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SKet","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SKet","text":"Symbolic ket\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SMulOperator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SMulOperator","text":"Symbolic application of operator on operator.\n\njulia> @op A; @op B;\n\njulia> A*B\nAB\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SOperator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SOperator","text":"Symbolic operator\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SOuterKetBra","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SOuterKetBra","text":"Symbolic outer product of a ket and a bra.\n\njulia> @bra b; @ket k;\n\njulia> k*b \n|k⟩⟨b|\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SPartialTrace","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SPartialTrace","text":"Partial trace over system i of a composite quantum system\n\njulia> @op 𝒪 SpinBasis(1//2)⊗SpinBasis(1//2);\n\njulia> op = ptrace(𝒪, 1)\ntr1(𝒪)\n\njulia> QuantumSymbolics.basis(op)\nSpin(1/2)\n\njulia> @op A; @op B;\n\njulia> ptrace(A⊗B, 1)\n(tr(A))B\n\njulia> @ket k; @bra b;\n\njulia> factorizable = A ⊗ (k*b)\nA⊗|k⟩⟨b|\n\njulia> ptrace(factorizable, 1)\n(tr(A))|k⟩⟨b|\n\njulia> ptrace(factorizable, 2)\n(⟨b||k⟩)A\n\njulia> mixed_state = (A⊗(k*b)) + ((k*b)⊗B)\n(A⊗|k⟩⟨b|)+(|k⟩⟨b|⊗B)\n\njulia> ptrace(mixed_state, 1)\n(0 + ⟨b||k⟩)B+(tr(A))|k⟩⟨b|\n\njulia> ptrace(mixed_state, 2)\n(0 + ⟨b||k⟩)A+(tr(B))|k⟩⟨b|\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SProjector","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SProjector","text":"Projector for a given ket.\n\njulia> projector(X1⊗X2)\n𝐏[|X₁⟩|X₂⟩]\n\njulia> express(projector(X2))\nOperator(dim=2x2)\n  basis: Spin(1/2)\n  0.5+0.0im  -0.5-0.0im\n -0.5+0.0im   0.5+0.0im\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SScaled","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SScaled","text":"Scaling of a quantum object (ket, operator, or bra) by a number.\n\njulia> @ket k\n|k⟩\n\njulia> 2*k\n2|k⟩\n\njulia> @op A\nA\n\njulia> 2*A\n2A\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SSuperOpApply","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SSuperOpApply","text":"Symbolic application of a superoperator on an operator\n\njulia> @op A; @superop S;\n\njulia> S*A\nS[A]\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SSuperOperator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SSuperOperator","text":"Symbolic superoperator\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.STrace","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.STrace","text":"Trace of an operator\n\njulia> @op A; @op B;\n\njulia> tr(A)\ntr(A)\n\njulia> tr(commutator(A, B))\n0\n\njulia> @bra b; @ket k;\n\njulia> tr(k*b)\n⟨b||k⟩\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.STranspose","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.STranspose","text":"Transpose of quantum objects (kets, bras, operators).\n\njulia> @op A; @op B; @ket k;\n\njulia> transpose(A)\nAᵀ\n\njulia> transpose(A+B)\nAᵀ+Bᵀ\n\njulia> transpose(k)\n|k⟩ᵀ\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SUnitaryOperator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SUnitaryOperator","text":"Symbolic unitary operator\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SVec","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SVec","text":"Vectorization of a symbolic operator.\n\njulia> @op A; @op B;\n\njulia> vec(A)\n|A⟩⟩\n\njulia> vec(A+B)\n|A⟩⟩+|B⟩⟩\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SZeroBra","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SZeroBra","text":"Symbolic zero bra\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SZeroKet","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SZeroKet","text":"Symbolic zero ket\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SZeroOperator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SZeroOperator","text":"Symbolic zero operator\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SqueezeOp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SqueezeOp","text":"Squeezing operator in defined Fock basis.\n\njulia> S = SqueezeOp(pi)\nS(π)\n\njulia> qsimplify(S*vac, rewriter=qsimplify_fock)\n|0,π⟩\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SqueezedState","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SqueezedState","text":"Squeezed vacuum state in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.StabilizerState","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.StabilizerState","text":"State defined by a stabilizer tableau\n\nFor full functionality you also need to import the QuantumClifford library.\n\njulia> using QuantumClifford, QuantumOptics # needed for the internal representation of the stabilizer tableaux and the conversion to a ket\n\njulia> StabilizerState(S\"XX ZZ\")\n𝒮₂\n\njulia> express(StabilizerState(S\"-X\"))\nKet(dim=2)\n  basis: Spin(1/2)\n  0.7071067811865475 + 0.0im\n -0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.TwoSqueezeOp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.TwoSqueezeOp","text":"Two-mode squeezing operator in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.TwoSqueezedState","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.TwoSqueezedState","text":"Two-mode squeezed vacuum state, or EPR state, in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#Base.conj-Union{Tuple{SymbolicUtils.Symbolic{T}}, Tuple{T}} where T<:Union{QuantumInterface.AbstractBra, QuantumInterface.AbstractKet, QuantumInterface.AbstractOperator, QuantumInterface.AbstractSuperOperator}","page":"QuantumSymbolics.jl reference","title":"Base.conj","text":"conj(x::Symbolic{AbstractKet})\nconj(x::Symbolic{AbstractBra})\nconj(x::Symbolic{AbstractOperator})\nconj(x::Symbolic{AbstractSuperOperator})\n\nSymbolic complex conjugate operation. See also SConjugate.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#Base.exp-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}}","page":"QuantumSymbolics.jl reference","title":"Base.exp","text":"exp(x::Symbolic{AbstractOperator})\n\nSymbolic exponential of an operator. See also SExpOperator.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#Base.inv-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}}","page":"QuantumSymbolics.jl reference","title":"Base.inv","text":"inv(x::Symbolic{AbstractOperator})\n\nSymbolic inverse of an operator. See also SInvOperator.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#Base.transpose-Union{Tuple{SymbolicUtils.Symbolic{T}}, Tuple{T}} where T<:Union{QuantumInterface.AbstractBra, QuantumInterface.AbstractKet, QuantumInterface.AbstractOperator}","page":"QuantumSymbolics.jl reference","title":"Base.transpose","text":"transpose(x::Symbolic{AbstractKet})\ntranspose(x::Symbolic{AbstractBra})\ntranspose(x::Symbolic{AbstractOperator})\n\nSymbolic transpose operation. See also STranspose.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#Base.vec-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}}","page":"QuantumSymbolics.jl reference","title":"Base.vec","text":"vec(x::Symbolic{AbstractOperator})\n\nSymbolic vector representation of an operator. See also SVec.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#LinearAlgebra.tr-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}}","page":"QuantumSymbolics.jl reference","title":"LinearAlgebra.tr","text":"tr(x::Symbolic{AbstractOperator})\n\nSymbolic trace operation. See also STrace.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#QuantumInterface.dagger-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractBra}}","page":"QuantumSymbolics.jl reference","title":"QuantumInterface.dagger","text":"dagger(x::Symbolic{AbstractBra})\n\nSymbolic adjoint operation. See also SDagger.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#QuantumInterface.dagger-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractKet}}","page":"QuantumSymbolics.jl reference","title":"QuantumInterface.dagger","text":"dagger(x::Symbolic{AbstractKet})\n\nSymbolic adjoint operation. See also SDagger.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#QuantumInterface.dagger-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}}","page":"QuantumSymbolics.jl reference","title":"QuantumInterface.dagger","text":"dagger(x::Symbolic{AbstractOperator})\n\nSymbolic adjoint operation. See also SDagger.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#QuantumInterface.express-Tuple{SymbolicUtils.Symbolic, AbstractRepresentation, AbstractUse}","page":"QuantumSymbolics.jl reference","title":"QuantumInterface.express","text":"express(s, repr::AbstractRepresentation=QuantumOpticsRepr()[, use::AbstractUse])\n\nThe main interface for expressing symbolic quantum objects in various representations.\n\njulia> express(X1)\nKet(dim=2)\n  basis: Spin(1/2)\n 0.7071067811865475 + 0.0im\n 0.7071067811865475 + 0.0im\n\njulia> express(X1, CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n+ X\n\njulia> express(QuantumSymbolics.X)\nOperator(dim=2x2)\n  basis: Spin(1/2)\n      ⋅       1.0 + 0.0im\n 1.0 + 0.0im       ⋅\n\njulia> express(QuantumSymbolics.X, CliffordRepr(), UseAsOperation())\nsX\n\njulia> express(QuantumSymbolics.X, CliffordRepr(), UseAsObservable())\n+ X\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#QuantumInterface.projector-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractKet}}","page":"QuantumSymbolics.jl reference","title":"QuantumInterface.projector","text":"projector(x::Symbolic{AbstractKet})\n\nSymbolic projection operation. See also SProjector.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#QuantumInterface.ptrace-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}, Any}","page":"QuantumSymbolics.jl reference","title":"QuantumInterface.ptrace","text":"ptrace(x::Symbolic{AbstractOperator})\n\nSymbolic partial trace operation. See also SPartialTrace.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#QuantumSymbolics.anticommutator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.anticommutator","text":"The anticommutator of two operators.\n\n\n\n\n\n","category":"function"},{"location":"API_Symbolics/#QuantumSymbolics.commutator","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.commutator","text":"The commutator of two operators.\n\n\n\n\n\n","category":"function"},{"location":"API_Symbolics/#QuantumSymbolics.consistent_representation-Tuple{Any, Any}","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.consistent_representation","text":"Pick a representation that is consistent with given representations and appropriate for the given state.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#QuantumSymbolics.qexpand-Tuple{Any}","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.qexpand","text":"qexpand(s)\n\nManually expand a symbolic expression of quantum objects. \n\njulia> @op A; @op B; @op C;\n\njulia> qexpand(commutator(A, B))\n-1BA+AB\n\njulia> qexpand(A⊗(B+C))\n(A⊗B)+(A⊗C)\n\njulia> @ket k₁; @ket k₂;\n\njulia> qexpand(A*(k₁+k₂))\nA|k₁⟩+A|k₂⟩\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#QuantumSymbolics.qsimplify-Tuple{Any}","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.qsimplify","text":"qsimplify(s; rewriter=nothing)\n\nManually simplify a symbolic expression of quantum objects. \n\nIf the keyword rewriter is not specified, then qsimplify will apply every defined rule to the expression.  For performance or single-purpose motivations, the user has the option to define a specific rewriter for qsimplify to apply to the expression. The defined rewriters for simplification are the following objects:     - qsimplify_pauli     - qsimplify_commutator     - qsimplify_anticommutator     - qsimplify_fock\n\njulia> qsimplify(σʸ*commutator(σˣ*σᶻ, σᶻ))\n(0 - 2im)Z\n\njulia> qsimplify(anticommutator(σˣ, σˣ), rewriter=qsimplify_anticommutator)\n2𝕀\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#QuantumSymbolics.@bra-Tuple{Any, Any}","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.@bra","text":"@bra(name, basis=SpinBasis(1//2))\n\nDefine a symbolic bra of type SBra. By default, the defined basis is the spin-1/2 basis.\n\njulia> @bra b₁\n⟨b₁|\n\njulia> @bra b₂ FockBasis(2)\n⟨b₂|\n\n\n\n\n\n","category":"macro"},{"location":"API_Symbolics/#QuantumSymbolics.@ket-Tuple{Any, Any}","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.@ket","text":"@ket(name, basis=SpinBasis(1//2))\n\nDefine a symbolic ket of type SKet. By default, the defined basis is the spin-1/2 basis.\n\njulia> @ket k₁\n|k₁⟩\n\njulia> @ket k₂ FockBasis(2)\n|k₂⟩\n\n\n\n\n\n","category":"macro"},{"location":"API_Symbolics/#QuantumSymbolics.@op-Tuple{Any, Any}","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.@op","text":"@op(name, basis=SpinBasis(1//2))\n\nDefine a symbolic operator of type SOperator. By default, the defined basis is the spin-1/2 basis.\n\njulia> @op A\nA\n\njulia> @op B FockBasis(2)\nB\n\n\n\n\n\n","category":"macro"},{"location":"API_Symbolics/","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.jl reference","text":"","category":"page"},{"location":"API_Interface/#QuantumInterface.jl-reference","page":"QuantumInterface.jl reference","title":"QuantumInterface.jl reference","text":"","category":"section"},{"location":"API_Interface/","page":"QuantumInterface.jl reference","title":"QuantumInterface.jl reference","text":"QuantumInterface.jl is a base package meant to define common APIs used by many independent QIS packages.","category":"page"},{"location":"API_Interface/","page":"QuantumInterface.jl reference","title":"QuantumInterface.jl reference","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API_Interface/#Autogenerated-API-list-for-QuantumInterface","page":"QuantumInterface.jl reference","title":"Autogenerated API list for QuantumInterface","text":"","category":"section"},{"location":"API_Interface/#QuantumInterface.AbstractRepresentation","page":"QuantumInterface.jl reference","title":"QuantumInterface.AbstractRepresentation","text":"An abstract type for the supported representation of quantum objects.\n\n\n\n\n\n","category":"type"},{"location":"API_Interface/#QuantumInterface.CliffordRepr","page":"QuantumInterface.jl reference","title":"QuantumInterface.CliffordRepr","text":"Representation using tableaux governed by QuantumClifford.jl\n\n\n\n\n\n","category":"type"},{"location":"API_Interface/#QuantumInterface.QuantumOpticsRepr","page":"QuantumInterface.jl reference","title":"QuantumInterface.QuantumOpticsRepr","text":"Representation using kets, bras, density matrices, and superoperators governed by QuantumOptics.jl.\n\n\n\n\n\n","category":"type"},{"location":"API_Interface/","page":"QuantumInterface.jl reference","title":"QuantumInterface.jl reference","text":"","category":"page"},{"location":"API_ProtocolZoo/#Predefined-Networking-Protocols","page":"ProtocolZoo API","title":"Predefined Networking Protocols","text":"","category":"section"},{"location":"API_ProtocolZoo/","page":"ProtocolZoo API","title":"ProtocolZoo API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API_ProtocolZoo/","page":"ProtocolZoo API","title":"ProtocolZoo API","text":"The submodule QuantumSavory.ProtocolZoo provides models for many common quantum networking protocols, including the details of their discrete event scheduling and simulation.","category":"page"},{"location":"API_ProtocolZoo/#Autogenerated-API-list-for-QuantumSavory.ProtocolZoo","page":"ProtocolZoo API","title":"Autogenerated API list for QuantumSavory.ProtocolZoo","text":"","category":"section"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.CutoffProt","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.CutoffProt","text":"struct CutoffProt{LT} <: QuantumSavory.ProtocolZoo.AbstractProtocol\n\nA protocol running at a node, checking periodically for any qubits in the node that have remained unused for more than the retention period of the qubit and emptying such slots.\n\nIf coordination messages are exchanged during deletions (instances of the type EntanglementDelete), then a EntanglementTracker protocol needs to also run, to act on such messages.\n\nsim: time-and-schedule-tracking instance from ConcurrentSim\nnet: a network graph of registers\nnode: the vertex index of the node on which the protocol is running\nperiod: time period between successive queries on the node (nothing for queuing up)\nretention_time: time after which a slot is emptied\nannounce: if true, synchronization messages are sent after a deletion to the node containing the other entangled qubit\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementConsumer","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementConsumer","text":"struct EntanglementConsumer{LT} <: QuantumSavory.ProtocolZoo.AbstractProtocol\n\nA protocol running between two nodes, checking periodically for any entangled pairs between the two nodes and consuming/emptying the qubit slots.\n\nsim: time-and-schedule-tracking instance from ConcurrentSim\nnet: a network graph of registers\nnodeA: the vertex index of node A\nnodeB: the vertex index of node B\nperiod: time period between successive queries on the nodes (nothing for queuing up and waiting for available pairs)\ntag: tag type which the consumer is looking for – the consumer query will be query(node, EntanglementConsumer.tag, remote_node) and it will be expected that remote_node possesses the symmetric reciprocal tag; defaults to EntanglementCounterpart\nlog: stores the time and resulting observable from querying nodeA and nodeB for EntanglementCounterpart\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementCounterpart","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementCounterpart","text":"struct EntanglementCounterpart\n\nIndicates the current entanglement status with a remote node's slot. Added when a new entanglement is generated through EntanglerProt or when a swap happens and  the EntanglementTracker receives an [EntanglementUpdate] message.\n\nremote_node::Int64: the id of the remote node to which we are entangled\nremote_slot::Int64: the slot in the remote node containing the qubit we are entangled to\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementHistory","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementHistory","text":"struct EntanglementHistory\n\nThis tag is used to store the outdated entanglement information after a swap. It helps to direct incoming entanglement update messages to the right node after a swap. It helps in situations when locally we have performed a swap, but we are now receiving a message from a distant node that does not know yet that the swap has occurred (thus the distant node might have outdated information about who is entangled to whom and we need to update that information).\n\nremote_node::Int64: the id of the remote node we used to be entangled to\nremote_slot::Int64: the slot of the remote node we used to be entangled to\nswap_remote_node::Int64: the id of remote node to which we are entangled after the swap\nswap_remote_slot::Int64: the slot of the remote node to which we are entangled after the swap\nswapped_local::Int64: the slot in this register with whom we performed a swap\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementTracker","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementTracker","text":"struct EntanglementTracker <: QuantumSavory.ProtocolZoo.AbstractProtocol\n\nA protocol, running at a given node, listening for messages that indicate something has happened to a remote qubit entangled with one of the local qubits.\n\nsim::ConcurrentSim.Simulation: time-and-schedule-tracking instance from ConcurrentSim\nnet::RegisterNet: a network graph of registers\nnode::Int64: the vertex of the node where the tracker is working\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementUpdateX","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementUpdateX","text":"struct EntanglementUpdateX\n\nThis tag arrives as a message from a remote node to which the current node was entangled to update the entanglement information and apply an X correction after the remote node performs an entanglement swap.\n\npast_local_node::Int64: the id of the node to which you were entangled before the swap\npast_local_slot::Int64: the slot of the node to which you were entangled before the swap\npast_remote_slot::Int64: the slot of your node that we were entangled to\nnew_remote_node::Int64: the id of the node to which you are now entangled after the swap\nnew_remote_slot::Int64: the slot of the node to which you are now entangled after the swap\ncorrection::Int64: what Pauli correction you need to perform\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementUpdateZ","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementUpdateZ","text":"struct EntanglementUpdateZ\n\nThis tag arrives as a message from a remote node to which the current node was entangled to update the entanglement information and apply a Z correction after the remote node performs an entanglement swap.\n\npast_local_node::Int64: the id of the node to which you were entangled before the swap\npast_local_slot::Int64: the slot of the node to which you were entangled before the swap\npast_remote_slot::Int64: the slot of your node that we were entangled to\nnew_remote_node::Int64: the id of the node to which you are now entangled after the swap\nnew_remote_slot::Int64: the slot of the node to which you are now entangled after the swap\ncorrection::Int64: what Pauli correction you need to perform\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglerProt","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglerProt","text":"struct EntanglerProt{LT} <: QuantumSavory.ProtocolZoo.AbstractProtocol\n\nA protocol that generates entanglement between two nodes. Whenever a pair of empty slots is available, the protocol locks them and starts probabilistic attempts to establish entanglement.\n\nsim::ConcurrentSim.Simulation: time-and-schedule-tracking instance from ConcurrentSim\nnet::RegisterNet: a network graph of registers\nnodeA::Int64: the vertex index of node A\nnodeB::Int64: the vertex index of node B\npairstate::Any: the state being generated (supports symbolic, numeric, noisy, and pure)\nsuccess_prob::Float64: success probability of one attempt of entanglement generation\nattempt_time::Float64: duration of single entanglement attempt\nlocal_busy_time_pre::Float64: fixed \"busy time\" duration immediately before starting entanglement generation attempts\nlocal_busy_time_post::Float64: fixed \"busy time\" duration immediately after the a successful entanglement generation attempt\nretry_lock_time::Any: how long to wait before retrying to lock qubits if no qubits are available (nothing for queuing up)\nrounds::Int64: how many rounds of this protocol to run (-1 for infinite)\nattempts::Int64: maximum number of attempts to make per round (-1 for infinite)\nchooseA::Union{Int64, var\"#s40\"} where var\"#s40\"<:Function: function Vector{Int}->Vector{Int} or an integer slot number, specifying the slot to take among available free slots in node A\nchooseB::Union{Int64, var\"#s39\"} where var\"#s39\"<:Function: function Vector{Int}->Vector{Int} or an integer slot number, specifying the slot to take among available free slots in node B\nrandomize::Bool: whether the protocol should find the first available free slots in the nodes to be entangled or check for free slots randomly from the available slots\nmargin::Int64: Repeated rounds of this protocol may lead to monopolizing all slots of a pair of registers, starving or deadlocking other protocols. This field can be used to always leave a minimum number of slots free if there already exists entanglement between the current pair of nodes.\nhardmargin::Int64: Like margin, but it is enforced even when no entanglement has been established yet. Usually smaller than margin.\ntag::Union{Nothing, DataType}: Tag to be added to the entangled qubits or nothing to not add any tag. The created tag will be of the form tag(remote_node, remote_slot), by default EntanglementCounterpart.\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglerProt-Tuple{ConcurrentSim.Simulation, RegisterNet, Int64, Int64}","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglerProt","text":"Convenience constructor for specifying rate of generation instead of success probability and time\n\n\n\n\n\n","category":"method"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.SwapperProt","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.SwapperProt","text":"struct SwapperProt{NL, NH, CL, CH, LT} <: QuantumSavory.ProtocolZoo.AbstractProtocol\n\nA protocol, running at a given node, that finds swappable entangled pairs and performs the swap.\n\nConsider setting an agelimit on qubits and using it together with the cutoff protocol, CutoffProt, which deletes qubits that are about to go past their cutoff/retention time.\n\nsim::ConcurrentSim.Simulation: time-and-schedule-tracking instance from ConcurrentSim\nnet::RegisterNet: a network graph of registers\nnode::Int64: the vertex of the node where swapping is happening\nnodeL::Any: the vertex of one of the remote nodes for the swap, arbitrarily referred to as the \"low\" node (or a predicate function or a wildcard); if you are working on a repeater chain, a good choice is <(current_node), i.e. any node to the \"left\" of the current node\nnodeH::Any: the vertex of the other remote node for the swap, the \"high\" counterpart of nodeL; if you are working on a repeater chain, a good choice is >(current_node), i.e. any node to the \"right\" of the current node\nchooseL::Any: the nodeL predicate can return many positive candidates; chooseL picks one of them (by index into the array of filtered nodeL results), defaults to a random pick arr->rand(keys(arr)); if you are working on a repeater chain a good choice is argmin, i.e. the node furthest to the \"left\"\nchooseH::Any: the nodeH counterpart for chooseH; if you are working on a repeater chain a good choice is argmax, i.e. the node furthest to the \"right\"\nlocal_busy_time::Float64: fixed \"busy time\" duration immediately before starting entanglement generation attempts\nretry_lock_time::Any: how long to wait before retrying to lock qubits if no qubits are available (nothing for queuing up and waiting)\nrounds::Int64: how many rounds of this protocol to run (-1 for infinite))\nagelimit::Union{Nothing, Float64}: what is the oldest a qubit should be to be picked for a swap (to avoid swapping with qubits that are about to be deleted, the agelimit should be shorter than the retention time of the cutoff protocol) (nothing for no limit) – you probably want to use CutoffProt if you have an agelimit\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.Switches.SimpleSwitchDiscreteProt","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.Switches.SimpleSwitchDiscreteProt","text":"struct SimpleSwitchDiscreteProt{AA} <: QuantumSavory.ProtocolZoo.AbstractProtocol\n\nA switch \"controller\", running on a given node, checking for connection requests from neighboring clients, and attempting to serve them by attempting direct raw entanglement with the clients and then mediating swaps to connect two clients together.\n\nWorks on discrete time intervals and destroys raw entanglement not used by the end of a ticktock cycle.\n\nThis switch is mostly based on the architecture proposed in (Promponas et al., 2024). Multiple switch management algorithms are suggested in that paper. By default we use the QuantumSavory.ProtocolZoo.Switches.promponas_bruteforce_choice algorithm.\n\nsim::ConcurrentSim.Simulation: time-and-schedule-tracking instance from ConcurrentSim\nnet::RegisterNet: a network graph of registers\nswitchnode::Int64: the vertex index of the switch\nclientnodes::Vector{Int64}: the vertex indices of the clients\nsuccess_probs::Vector{Float64}: best-guess about success of establishing raw entanglement between client and switch\nticktock::Float64: duration of a single full cycle of the switching decision algorithm\nrounds::Int64: how many rounds of this protocol to run (-1 for infinite)\nassignment_algorithm::Any: the algorithm to use for memory slot assignment, defaulting to promponas_bruteforce_choice\nbacklog::QuantumSavory.ProtocolZoo.Switches.SymMatrix{Matrix{Int64}}\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.Switches.SwitchRequest","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.Switches.SwitchRequest","text":"struct SwitchRequest\n\nNotify a switch that you request to be entangled with another node.\n\nrequester::Int64: the id of the node making the request\nremote_node::Int64: the id of the remote node to which we want to be entangled\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/","page":"ProtocolZoo API","title":"ProtocolZoo API","text":"","category":"page"},{"location":"backendsimulator/#backend","page":"Backend Simulators","title":"Backend Simulators","text":"","category":"section"},{"location":"backendsimulator/","page":"Backend Simulators","title":"Backend Simulators","text":"The simulation of quantum dynamics in QuantumSavory can be done through many different backend simulators, depending on the tradeoff between performance and generality that the user needs. By default, it comes with two included simulators: QuantumClifford and QuantumOptics, but others can be plugged in through our universal quantum register interface.","category":"page"},{"location":"backendsimulator/#QuantumClifford-Stabilizer-Formalism","page":"Backend Simulators","title":"QuantumClifford - Stabilizer Formalism","text":"","category":"section"},{"location":"backendsimulator/","page":"Backend Simulators","title":"Backend Simulators","text":"QuantumClifford leverages stabilizer states and Clifford gates — highly structured operations that can be simulated more efficiently than arbitrary quantum processes. It uses the tableaux formalism with the destabilizer improvements, as implemented in the QuantumClifford library. Simulations run in polynomial time, enabling very fast computations. However, adding non-Clifford elements breaks this efficiency, making the simulation more complex and slower.","category":"page"},{"location":"backendsimulator/#QuantumOptics-State-Vector-Formalism","page":"Backend Simulators","title":"QuantumOptics - State Vector Formalism","text":"","category":"section"},{"location":"backendsimulator/","page":"Backend Simulators","title":"Backend Simulators","text":"QuantumOptics uses a fully general state vector (wavefunction) representation. This approach, provided by the 'QuantumOptics' library, can handle any quantum operation or state without the structural restrictions of stabilizer methods. While this generality is powerful, it quickly becomes computationally expensive as the number of qubits grows — memory and time requirements scale exponentially. Consequently, simulating large systems with the state vector formalism becomes impractically slow compared to stabilizer-based methods.","category":"page"},{"location":"backendsimulator/","page":"Backend Simulators","title":"Backend Simulators","text":"","category":"page"},{"location":"backgrounds/#Background-Noise-Processes","page":"Background Noise","title":"Background Noise Processes","text":"","category":"section"},{"location":"backgrounds/","page":"Background Noise","title":"Background Noise","text":"For each subsystem (slot in the register), you also specify what background processes and noise parameters describe it. For instance, it could be a T1Decay or T2Dephasing process, or a coherent error, or a non-Markovian bath. It is supported by all backends (but maybe with twirling, e.g. to support T1Decay in a Clifford simulation).","category":"page"},{"location":"backgrounds/","page":"Background Noise","title":"Background Noise","text":"Currently we implement:","category":"page"},{"location":"backgrounds/","page":"Background Noise","title":"Background Noise","text":"using QuantumSavory # hide\nusing InteractiveUtils # hide\nsubtypes(QuantumSavory.AbstractBackground)","category":"page"},{"location":"backgrounds/","page":"Background Noise","title":"Background Noise","text":"If you want to introspect these noise processes, you can use the paulinoise, krausops, and lindbladop functions.","category":"page"},{"location":"backgrounds/","page":"Background Noise","title":"Background Noise","text":"","category":"page"},{"location":"howto/#How-To-Guides","page":"How-To Guides","title":"How-To Guides","text":"","category":"section"},{"location":"howto/","page":"How-To Guides","title":"How-To Guides","text":"\"HowTo\"s are fully fleshed out examples of how to use QuantumSavory to set up a complete simulation of a system of interest. They do not go into details of how the library is structured internally and do not provide in-depth discussion of APIs, rather they showcase idiomatic use of the library.","category":"page"},{"location":"howto/#A-simulation-of-a-quantum-repeater:","page":"How-To Guides","title":"A simulation of a quantum repeater:","text":"","category":"section"},{"location":"howto/","page":"How-To Guides","title":"How-To Guides","text":"<video src=\"firstgenrepeater/firstgenrepeater-07.observable.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/#A-simulation-of-the-generation-of-a-cluster-state-in-color-center-memories:","page":"How-To Guides","title":"A simulation of the generation of a cluster state in color-center memories:","text":"","category":"section"},{"location":"howto/","page":"How-To Guides","title":"How-To Guides","text":"<video src=\"colorcentermodularcluster/colorcentermodularcluster-02.simdashboard.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/","page":"How-To Guides","title":"How-To Guides","text":"","category":"page"},{"location":"tag_query/#tagging-and-querying","page":"Tagging and Querying","title":"Tagging and Querying","text":"","category":"section"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"The query and tag! interface lets you manage \"classical state\" metadata in your simulations. In particular, this interface enables the creation of modular interoperable control protocols. Each protocol can operate independently of others without knowledge of each others' internals. This is done by using various \"tags\" to communicate metadata between the network nodes running the protocols, and by the protocols querying for the presence of such tags, leading to greater flexibility when setting up different simulations.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"The components of the query interface which make this possible are described below.","category":"page"},{"location":"tag_query/#The-Tag-type","page":"Tagging and Querying","title":"The Tag type","text":"","category":"section"},{"location":"tag_query/#QuantumSavory.Tag-tag_query","page":"Tagging and Querying","title":"QuantumSavory.Tag","text":"Tags are used to represent classical metadata describing the state (or even history) of nodes and their registers. The library allows the construction of custom tags using the Tag constructor. Currently tags are implemented as instances of a sum type and have fairly constrained structure. Most of them are constrained to contain only Symbol instances and integers.\n\nHere is an example of such a generic tag:\n\njulia> Tag(:sometagdescriptor, 1, 2, -3)\nSymbolIntIntInt(:sometagdescriptor, 1, 2, -3)::Tag\n\nA tag can have a custom DataType as first argument, in which case additional customizability in printing is available. E.g. consider the [EntanglementHistory] tag used to track how pairs were entangled before a swap happened.\n\njulia> using QuantumSavory.ProtocolZoo: EntanglementHistory\n\njulia> Tag(EntanglementHistory, 1, 2, 3, 4, 5)\nWas entangled to 1.2, but swapped with .5 which was entangled to 3.4\n\nSee also: tag!, query\n\n\n\n\n\n","category":"type"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"And here are all currently supported tag signatures:","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"using QuantumSavory #hide\n[tuple(m.sig.types[2:end]...) for m in methods(Tag) if m.sig.types[2] ∈ (Symbol, DataType)]","category":"page"},{"location":"tag_query/#Assigning-and-removing-tags","page":"Tagging and Querying","title":"Assigning and removing tags","text":"","category":"section"},{"location":"tag_query/#QuantumSavory.tag!-tag_query","page":"Tagging and Querying","title":"QuantumSavory.tag!","text":"tag!(ref::RegRef, tag) -> Int128\n\n\nAssign a tag to a slot in a register.\n\nSee also: query, untag!\n\n\n\n\n\n","category":"function"},{"location":"tag_query/#QuantumSavory.untag!-tag_query","page":"Tagging and Querying","title":"QuantumSavory.untag!","text":"untag!(\n    ref::Union{RegRef, Register},\n    id::Integer\n) -> @NamedTuple{tag::Tag, slot::Int64, time::Float64}\n\n\nRemove the tag with the given id from a RegRef or a Register.\n\nTo remove a tag based on a query, use querydelete! instead.\n\nSee also: querydelete!, query, tag!\n\n\n\n\n\n","category":"function"},{"location":"tag_query/#Querying-for-the-presence-of-a-tag","page":"Tagging and Querying","title":"Querying for the presence of a tag","text":"","category":"section"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"The query function allows the user to query for Tags in three different cases:","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"on a particular qubit slot (RegRef) in a Register node;\non a Register to query for any slot that contains the passed Tag;\non a messagebuffer to query for a particular Tag received from another node in a network.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"The Tag description passed to query can include predicate functions (of the form x -> pass::Bool) and wildcards (the ❓ variable), for situations where we have freedom in what tag we are exactly searching for.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"The queries can search in FIFO or FILO order (FILO by default). E.g., for the default FILO, a query on a RegRef returns the Tag which is at the end of the vector of tags stored the given slot (as new tags are appended at the end). On a Register it returns the slot with the \"youngest\" age.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"One can also query by \"lock\" and \"assignment\" status of a given slot, by using the locked and assigned boolean keywords. By default these keywords are set to nothing and these properties are not checked.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"Following is a detailed description of each query method","category":"page"},{"location":"tag_query/#QuantumSavory.query-tag_query","page":"Tagging and Querying","title":"QuantumSavory.query","text":"query(\n    reg::Union{RegRef, Register},\n    queryargs::Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}...;\n    locked,\n    assigned,\n    filo\n) -> Any\n\n\nA query function searching for the first slot in a register that has a given tag.\n\nWildcards are supported (instances of Wildcard also available as the constants W or the emoji ❓ which can be entered as \\:question: in the REPL). Predicate functions are also supported (they have to be Int↦Bool functions). The order of query lookup can be specified in terms of FIFO or FILO and defaults to FILO if not specified. The keyword arguments locked and assigned can be used to check, respectively, whether the given slot is locked or whether it contains a quantum state. The keyword argument filo can be used to specify whether the search should be done in a FIFO or FILO order, defaulting to filo=true (i.e. a stack-like behavior).\n\njulia> r = Register(10);\n       tag!(r[1], :symbol, 2, 3);\n       tag!(r[2], :symbol, 4, 5);\n\n\njulia> query(r, :symbol, 4, 5)\n(slot = Slot 2, id = 4, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n\njulia> lock(r[1]);\n\njulia> query(r, :symbol, 4, 5; locked=false) |> isnothing\nfalse\n\njulia> query(r, :symbol, ❓, 3)\n(slot = Slot 1, id = 3, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\njulia> query(r, :symbol, ❓, 3; assigned=true) |> isnothing\ntrue\n\njulia> query(r, :othersym, ❓, ❓) |> isnothing\ntrue\n\njulia> tag!(r[5], Int, 4, 5);\n\njulia> query(r, Float64, 4, 5) |> isnothing\ntrue\n\njulia> query(r, Int, 4, >(7)) |> isnothing\ntrue\n\njulia> query(r, Int, 4, <(7))\n(slot = Slot 5, id = 5, tag = TypeIntInt(Int64, 4, 5)::Tag)\n\nA query can be on on a single slot of a register:\n\njulia> r = Register(5);\n\njulia> tag!(r[2], :symbol, 2, 3);\n\njulia> query(r[2], :symbol, 2, 3)\n(slot = Slot 2, id = 6, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\njulia> query(r[3], :symbol, 2, 3) === nothing\ntrue\n\njulia> queryall(r[2], :symbol, 2, 3)\n1-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:\n (slot = Slot 2, id = 6, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\nSee also: queryall, tag!, W, ❓\n\n\n\n\n\nquery(\n    mb::MessageBuffer,\n    queryargs::Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}...\n) -> Union{Nothing, NamedTuple{(:depth, :src, :tag), <:Tuple{Int64, Any, Any}}}\n\n\nYou are advised to actually use querydelete!, not query when working with classical message buffers.\n\n\n\n\n\n","category":"function"},{"location":"tag_query/#Wildcards","page":"Tagging and Querying","title":"Wildcards","text":"","category":"section"},{"location":"tag_query/#QuantumSavory.W-tag_query","page":"Tagging and Querying","title":"QuantumSavory.W","text":"A wildcard instance for use with the tag querying functionality.\n\nSee also: query, tag!, ❓\n\n\n\n\n\n","category":"constant"},{"location":"tag_query/#QuantumSavory.❓-tag_query","page":"Tagging and Querying","title":"QuantumSavory.❓","text":"A wildcard instance for use with the tag querying functionality.\n\nThis emoji can be inputted with the \\:question: emoji shortcut, or you can simply use the ASCII alternative W.\n\nSee also: query, tag!, W\n\n\n\n\n\n","category":"constant"},{"location":"tag_query/#querydelete!","page":"Tagging and Querying","title":"querydelete!","text":"","category":"section"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"A method on top of query, which allows to query for tag in a RegRef or a messagebuffer, returning the tag that satisfies the passed predicates and wildcars, and deleting it from the list at the same time. It otherwise has the same signature as query.","category":"page"},{"location":"tag_query/#QuantumSavory.querydelete!-tag_query","page":"Tagging and Querying","title":"QuantumSavory.querydelete!","text":"querydelete!(\n    mb::MessageBuffer,\n    args...\n) -> Union{Nothing, @NamedTuple{src::Union{Nothing, Int64}, tag::T} where T}\n\n\nA query for classical message buffers that also deletes the message out of the buffer.\n\njulia> net = RegisterNet([Register(3), Register(2)])\nA network of 2 registers in a graph of 1 edges\n\njulia> put!(channel(net, 1=>2), Tag(:my_tag));\n\njulia> put!(channel(net, 1=>2), Tag(:another_tag, 123, 456));\n\njulia> query(messagebuffer(net, 2), :my_tag)\n\njulia> run(get_time_tracker(net))\n\njulia> query(messagebuffer(net, 2), :my_tag)\n(depth = 1, src = 1, tag = Symbol(:my_tag)::Tag)\n\njulia> querydelete!(messagebuffer(net, 2), :my_tag)\n@NamedTuple{src::Union{Nothing, Int64}, tag::Tag}((1, Symbol(:my_tag)::Tag))\n\njulia> querydelete!(messagebuffer(net, 2), :my_tag) === nothing\ntrue\n\njulia> querydelete!(messagebuffer(net, 2), :another_tag, ❓, ❓)\n@NamedTuple{src::Union{Nothing, Int64}, tag::Tag}((1, SymbolIntInt(:another_tag, 123, 456)::Tag))\n\njulia> querydelete!(messagebuffer(net, 2), :another_tag, ❓, ❓) === nothing\ntrue\n\nYou can also wait on a message buffer for a message to arrive before running a query:\n\njulia> using ResumableFunctions; using ConcurrentSim;\n\njulia> net = RegisterNet([Register(3), Register(2), Register(3)])\nA network of 3 registers in a graph of 2 edges\n\njulia> env = get_time_tracker(net);\n\njulia> @resumable function receive_tags(env)\n           while true\n               mb = messagebuffer(net, 2)\n               @yield wait(mb)\n               msg = querydelete!(mb, :second_tag, ❓, ❓)\n               print(\"t=$(now(env)): query returns \")\n               if isnothing(msg)\n                   println(\"nothing\")\n               else\n                   println(\"$(msg.tag) received from node $(msg.src)\")\n               end\n           end\n       end\nreceive_tags (generic function with 1 method)\n\njulia> @resumable function send_tags(env)\n           @yield timeout(env, 1.0)\n           put!(channel(net, 1=>2), Tag(:my_tag))\n           @yield timeout(env, 2.0)\n           put!(channel(net, 3=>2), Tag(:second_tag, 123, 456))\n       end\nsend_tags (generic function with 1 method)\n\njulia> @process send_tags(env);\n\njulia> @process receive_tags(env);\n\njulia> run(env, 10)\nt=1.0: query returns nothing\nt=3.0: query returns SymbolIntInt(:second_tag, 123, 456)::Tag received from node 3\n\n\n\n\n\nquerydelete!(\n    reg::Union{RegRef, Register},\n    args...;\n    kwa...\n) -> Any\n\n\nA query for Register or a register slot (i.e. a RegRef) that also deletes the tag.\n\njulia> reg = Register(3)\n       tag!(reg[1], :tagA, 1, 2, 3)\n       tag!(reg[2], :tagA, 10, 20, 30)\n       tag!(reg[2], :tagB, 6, 7, 8);\n\njulia> queryall(reg, :tagA, ❓, ❓, ❓)\n2-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:\n (slot = Slot 2, id = 4, tag = SymbolIntIntInt(:tagA, 10, 20, 30)::Tag)\n (slot = Slot 1, id = 3, tag = SymbolIntIntInt(:tagA, 1, 2, 3)::Tag)\n\njulia> querydelete!(reg, :tagA, ❓, ❓, ❓)\n(slot = Slot 2, id = 4, tag = SymbolIntIntInt(:tagA, 10, 20, 30)::Tag)\n\njulia> queryall(reg, :tagA, ❓, ❓, ❓)\n1-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:\n (slot = Slot 1, id = 3, tag = SymbolIntIntInt(:tagA, 1, 2, 3)::Tag)\n\n\n\n\n\n","category":"function"},{"location":"tag_query/#queryall","page":"Tagging and Querying","title":"queryall","text":"","category":"section"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"A method defined on top of query which allows to query for all tags in a RegRef or a Register that match the query.","category":"page"},{"location":"tag_query/#QuantumSavory.queryall-tag_query","page":"Tagging and Querying","title":"QuantumSavory.queryall","text":"queryall(\n    reg::Union{RegRef, Register},\n    queryargs::Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}...;\n    filo,\n    kwargs...\n) -> Any\n\n\nA query function that returns all slots of a register that have a given tag, with support for predicates and wildcards.\n\njulia> r = Register(10);\n       tag!(r[1], :symbol, 2, 3);\n       tag!(r[2], :symbol, 4, 5);\n\njulia> queryall(r, :symbol, ❓, ❓)\n2-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:\n (slot = Slot 2, id = 2, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n (slot = Slot 1, id = 1, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\njulia> queryall(r, :symbol, ❓, >(4))\n1-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:\n (slot = Slot 2, id = 2, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n\njulia> queryall(r, :symbol, ❓, >(5))\n@NamedTuple{slot::RegRef, id::Int128, tag::Tag}[]\n\n\n\n\n\n","category":"function"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"","category":"page"},{"location":"visualizations/#Visualizations","page":"Visualizations","title":"Visualizations","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"We provide many visualization tools build on top of the Makie.jl framework for interactive visualizations.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The plotting functions generally return a tuple of (subfigure, axis, plot, observable). The observable can be used to issue a notify call that updates the plot with the current state of the network without replotting from scratch. This is particularly useful for live simulation visualizations.","category":"page"},{"location":"visualizations/#The-quantum-registers-in-the-network","page":"Visualizations","title":"The quantum registers in the network","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The registernetplot_axis function can be used to draw a given set of registers, together with the quantum states they contain. It also provides interactive tools for inspecting the content of the registers (by hovering or clicking on the corresponding register slot). Here we give an example where we define a network and then plot it:","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"using GLMakie\nGLMakie.activate!()\nusing QuantumSavory\n\n# create a network of qubit registers\nnet = RegisterNet([Register(2),Register(3),Register(2),Register(5)])\n\n# add some states, entangle a few slots, perform some gates\ninitialize!(net[1,1])\ninitialize!(net[2,3], X₁)\ninitialize!((net[3,1],net[4,2]), X₁⊗Z₂)\napply!((net[2,3],net[3,1]), CNOT)\n\n# create the plot\nfig = Figure(size=(800,400))\n_, ax, plt, obs = registernetplot_axis(fig[1,1],net)\nfig","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The tall rectangles are registers, the gray squares are the slots of these registers, and the (connected) black diamonds denote when a slot is occupied by some subsystem (of a potentially larger) quantum state.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The visualization is capable of showing tooltips when hovering over different components of the plot, particularly valuable for debugging. Quantum observables can be directly calculated and plotted as well (through the observables keyword).","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"Other configuration options are available as well (the ones ending on plot let you access the subplot objects used to create the visualization and the ones ending on backref provide convenient inverse mapping from graphical elements to the registers or states being visualized):","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"propertynames(plt)","category":"page"},{"location":"visualizations/#Plotting-Registers-on-a-Background-Map","page":"Visualizations","title":"Plotting Registers on a Background Map","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"If your registers have latitude and longitude coordinates (ranging from -180 to 180), you can plot them directly on a map. One way is to use generate_map function to create the map as a plotting axis using the package 'Tyler'. Here's how you can do this with the registers defined earlier:","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"using GLMakie # hide\nGLMakie.activate!() # hide\nnet = RegisterNet([Register(2),Register(3),Register(2),Register(5)]) # hide\ninitialize!(net[1,1]) # hide\ninitialize!(net[2,3], X₁) # hide\ninitialize!((net[3,1],net[4,2]), X₁⊗Z₂) # hide\napply!((net[2,3],net[3,1]), CNOT) # hide\nusing Tyler\ncoords = [Point2f(-118, 34), Point2f(-71, 42), Point2f(-111, 34), Point2f(-96, 32)]\nsubfig, ax, map = generate_map()\nfig, ax, plt, obs = registernetplot_axis(ax, net, registercoords=coords, state_linecolor = :black)\nfig","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"In general, if you have a custom background axis, you can use it as the axis parameter in registerplot_axis.","category":"page"},{"location":"visualizations/#State-and-tag-metadata-in-interactive-visualizations","page":"Visualizations","title":"State and tag metadata in interactive visualizations","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"When working with interactive plots, you can also hover over different parts of the visualization to see the registers, what is stored in them, and potentially whether they contain any tagged metadata in use by simulated networking protocols.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"Here is what the data panels look like. (showmetada is used to force-show the panel, but when working interactively you simply need to hover with the cursor)","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"network = RegisterNet([Register(2),Register(3),Register(2),Register(5)]) # hide\ninitialize!(network[1,1]) # hide\ninitialize!(network[2,3], X₁) # hide\ninitialize!((network[3,1],network[4,2]), X₁⊗Z₂) # hide\napply!((network[2,3],network[3,1]), CNOT) # hide\nfig = Figure(size=(700,400)) # hide\n_, ax, plt, obs = registernetplot_axis(fig[1,1],network) # hide\nfig","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"QuantumSavory.showmetadata(fig,ax,plt,1,1)\nfig","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"And here with some extra tag metadata.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"tag!(network[2,3], :specialplace, 1, 2)\ntag!(network[2,3], :otherdata, 3, 4)\nQuantumSavory.showmetadata(fig,ax,plt,2,3)\nfig","category":"page"},{"location":"visualizations/#The-state-of-locks-and-various-metadata-in-the-network","page":"Visualizations","title":"The state of locks and various metadata in the network","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The resourceplot_axis function can be used to draw all locks and resources stored in a meta-graph governing a discrete event simulation. Metadata stored at the vertices is plotted as colored or grayed out dots depending on their state. Metadata stored at the edges is shown as lines.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"using Graphs\nusing ConcurrentSim\n\nsim = Simulation()\n\n# add random metadata to vertices and edges of the network\nfor v in vertices(net)\n    net[v,:bool] = rand(Bool)\n    net[v,:resource] = Resource(sim,1)\n    rand(Bool) && request(net[v,:resource])\nend\nfor e in edges(net)\n    net[e,:edge_bool] = true\n    net[e,:another_bool] = rand(Bool)\nend\n\n# plot the resources and metadata\n\nfig = Figure(size=(700,400))\nresourceplot_axis(fig[1,1],net,\n    [:edge_bool,:another_bool], # list of edge metadata to plot\n    [:bool,:resource],          # list of vertex metadata\n    registercoords=plt[:registercoords] # optionally, reuse register coordinates\n)\nfig","category":"page"},{"location":"visualizations/#Updating-the-plots","page":"Visualizations","title":"Updating the plots","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"You can call notify on the returned plot object to replot the state of the network after a change.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/#Cluster-State-on-Color-Centers","page":"Cluster States in Atomic Memories","title":"Cluster State on Color Centers","text":"","category":"section"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"info: TODO Unfinished\nThis page is unfinished!","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"Cluster states are highly entangled state of qubits useful as a computational resource. The cluster state is also a graph state where the graph has a 2D grid topology.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"One interesting hardware implementation involves entangling a large number of color centers[1].","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"[1]: (Choi et al., 2019)","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"We will build a simulator for such a piece of hardware. Each node will be a register of one electron spin for networking and one nuclear spin in which the actual long-term entanglement is \"stored\".","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"info: Low Level Implementation\nThis is a very low-level implementation. You would be better of using already implemented reusable protocols like EntanglerProt. On the other hand, the setup here is a simple way to learn about making discrete event simulations without depending on a lot of extra library functionality and opaque black boxes.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"The visualization below shows an example of the state being generated, together with tracking the state of various locks and other metadata that needs to be tracked.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"<video src=\"../colorcentermodularcluster-02.simdashboard.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"Of interest is both the time it takes to prepare a full cluster state, as well as the fidelity of state being prepared in that fashion. The fidelity can be lowered due to the numerous noise processes experience by the hardware. The duration can be quite long due to the low efficiencies of photon capture during typical entanglement procedures. The plot below shows the distribution of these figures of merit, sampled from a large number of independent runs of the simulation (gathering the entirety of this date takes less than a second).","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"(Image: Time to cluster preparation versus fidelity of cluster)","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"For organizing the simulation and simplifying the digital and analog quantum dynamics, we will use the star of QuantumSavory.jl, namely the Register data structure. For a convenient data structure to track per-node metadata in a graph (network) we will use the RegisterNet structure.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"Moreover, behind the scenes QuantumSavory.jl will use:","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"ConcurrentSim.jl for discrete event scheduling and simulation;\nMakie.jl together with our custom plotting recipes for visualizations;\nQuantumOptics.jl for low-level quantum states.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"The user does not need to know much about these libraries, but if they wish, it is easy for them to peek behind the scenes and customize their use.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"Below we embed a live version of the simulation (hosted at areweentangledyet.com/colorcentermodularcluster/):","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"<iframe class=\"liveexample\" src=\"https://areweentangledyet.com/colorcentermodularcluster/\" style=\"height:850px;width:1250px;\"></iframe>","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"The source code is in the examples/colorcentermodularcluster folder.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"","category":"page"},{"location":"manual/#manual","page":"Getting Started Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Getting-Started","page":"Getting Started Manual","title":"Getting Started","text":"","category":"section"},{"location":"manual/#Installation","page":"Getting Started Manual","title":"Installation","text":"","category":"section"},{"location":"manual/","page":"Getting Started Manual","title":"Getting Started Manual","text":"To use QuantumSavory, make sure you have Julia version 1.10 installed. You can download and install Julia from the official Julia website.","category":"page"},{"location":"manual/","page":"Getting Started Manual","title":"Getting Started Manual","text":"Once Julia is setup, QuantumSavory can be installed with the following command in your in your Julia REPL:","category":"page"},{"location":"manual/","page":"Getting Started Manual","title":"Getting Started Manual","text":"$ julia\njulia> ]\npkg> add QuantumSavory","category":"page"},{"location":"manual/#Optional-Dependencies","page":"Getting Started Manual","title":"Optional Dependencies","text":"","category":"section"},{"location":"manual/","page":"Getting Started Manual","title":"Getting Started Manual","text":"There are optional packages that you need to install to use the full plotting feature.","category":"page"},{"location":"manual/","page":"Getting Started Manual","title":"Getting Started Manual","text":"Makie: For plotting of registers and processes.\nTyler: Enables plotting on a real-world map as a background.","category":"page"},{"location":"manual/#Basic-Demo","page":"Getting Started Manual","title":"Basic Demo","text":"","category":"section"},{"location":"manual/","page":"Getting Started Manual","title":"Getting Started Manual","text":"Here’s a simple example to demonstrate how superdense coding can be implemented. For more advanced examples and detailed guide, seeHow-To Guides and Tutorials sections.","category":"page"},{"location":"manual/","page":"Getting Started Manual","title":"Getting Started Manual","text":"using QuantumSavory\nusing ResumableFunctions\nusing ConcurrentSim\n\nsim = Simulation()\n\n# regA for Alice and regB for Bob\nregA = Register(1)\nregB = Register(2)\n\n# Entangle Alice's and Bob's first qubits\nbell_state = (Z1 ⊗ Z1 + Z2 ⊗ Z2) / sqrt(2.0)\ninitialize!((regA[1], regB[1]), bell_state)\n\n# Channel with delay\nqc = QuantumChannel(sim, 10.0)\n\n# Alice wants to send \"10\"\n@resumable function alice(env, qc)\n    println(\"Alice: Encoding 10 at $(now(env))\")\n    apply!(regA[1], Z)\n    put!(qc, regA[1])\nend\n\n# Bob receives the qubit and decodes it\n@resumable function bob(env, qc)\n    @yield take!(qc, regB[2])  # Wait for the qubit from Alice\n    apply!((regB[2], regB[1]), CNOT)\n    apply!(regB[2], H)\n\n    bit1 = project_traceout!(regB, 2, Z) - 1\n    bit2 = project_traceout!(regB, 1, Z) - 1\n    println(\"Bob decoded the bits at $(now(env)): \", bit1, bit2)\nend\n\n@process alice(sim, qc)\n@process bob(sim, qc)\nrun(sim)","category":"page"},{"location":"manual/","page":"Getting Started Manual","title":"Getting Started Manual","text":"","category":"page"},{"location":"explanations/#Explanations","page":"Explanations","title":"Explanations","text":"","category":"section"},{"location":"explanations/","page":"Explanations","title":"Explanations","text":"This section covers how is the library structured, what are its conventions, and why were they decided upon.","category":"page"},{"location":"explanations/","page":"Explanations","title":"Explanations","text":"You probably want to cover the:","category":"page"},{"location":"explanations/","page":"Explanations","title":"Explanations","text":"Register and RegisterNet structures\nbasic interface used by the library\nsymbolic capabilities for formalism-agnostic description\nmetadata tagging and metadata queries for interoperability between protocols\navailable simulator backends\ndiscrete event simulations and time-tracking capabilities\nbackground noise processes\ngraphical visualization and plotting recipes","category":"page"},{"location":"explanations/","page":"Explanations","title":"Explanations","text":"","category":"page"},{"location":"howto/congestionchain/congestionchain/#A-Study-of-Congestions-over-a-Repeater-Chain","page":"Congestion on a Repeater Chain","title":"A Study of Congestions over a Repeater Chain","text":"","category":"section"},{"location":"howto/congestionchain/congestionchain/","page":"Congestion on a Repeater Chain","title":"Congestion on a Repeater Chain","text":"info: TODO Unfinished\nThis page is unfinished!","category":"page"},{"location":"howto/congestionchain/congestionchain/","page":"Congestion on a Repeater Chain","title":"Congestion on a Repeater Chain","text":"A simple example to study congestion on a chain of quantum repeaters.","category":"page"},{"location":"howto/congestionchain/congestionchain/","page":"Congestion on a Repeater Chain","title":"Congestion on a Repeater Chain","text":"info: Low Level Implementation\nThis is a very low-level implementation. You would be better of using already implemented reusable protocols like EntanglerProt. On the other hand, the setup here is a simple way to learn about making discrete event simulations without depending on a lot of extra library functionality and opaque black boxes.","category":"page"},{"location":"howto/congestionchain/congestionchain/","page":"Congestion on a Repeater Chain","title":"Congestion on a Repeater Chain","text":"Below we embed a live version of the simulation (hosted at areweentangledyet.com/congestionchain/):","category":"page"},{"location":"howto/congestionchain/congestionchain/","page":"Congestion on a Repeater Chain","title":"Congestion on a Repeater Chain","text":"<iframe class=\"liveexample\" src=\"https://areweentangledyet.com/congestionchain/\" style=\"height:800px;width:850px;\"></iframe>","category":"page"},{"location":"howto/congestionchain/congestionchain/","page":"Congestion on a Repeater Chain","title":"Congestion on a Repeater Chain","text":"The source code is in the examples/congestionchain folder.","category":"page"},{"location":"howto/congestionchain/congestionchain/","page":"Congestion on a Repeater Chain","title":"Congestion on a Repeater Chain","text":"","category":"page"},{"location":"howto/repeatergrid/repeatergrid/#Entanglement-Generation-On-A-Repeater-Grid","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"","category":"section"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"This section provides a detailed walkthrough of how QuantumSavory.jl can be used to simulate entanglement generation on a network of repeaters where each repeater relies only on local knowledge of the network. This is only one of many ways in which such a network can be set up, focusing on one particular \"no global knowledge\" approach.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"A complete implementation of the simulation described here is available in the examples/repeatergrid folder of the QuantumSavory repository.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"For this example, we consider a square grid topology in which each node is connected to its nearest neighbors. The registers act as repeater nodes. The nodes on the diagonal corners are Alice and Bob, the two special nodes that the network is trying to entangle through generating link-level entanglement at each edge and performing appropriate swaps at each node.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"The goal is to establish entanglement between Alice and Bob by routing entanglement through any of the possible paths (horizontal or vertical) formed by local entanglement links and then swapping those links by performing entanglement swaps.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"This employs functionality from the ProtocolZoo module of QuantumSavory to run the following Quantum Networking protocols:","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"EntanglerProt: Entangler protocol to produce link-level entanglement at each edge in the network\nSwapperProt: Swapper protocol runs at each node except at the Alice and Bob nodes, to perform swaps. The swaps are performed only if a query deems them useful for propagating entanglement closer and closer to Alice and Bob.\nEntanglementTracker: Entanglement Tracker protocol to keep track of and update the local link state (classical knowledge) by listening for \"entanglement update\" messages generated by the other protocols (SwapperProt & CutoffProt specifically).\nCutoffProt: As the simulation progresses, the unused entangled pairs generated by EntanglerProt need to be discarded due to the loss of fidelity under noise as they might not be suitable for networking applications beyond a certain cutoff interval of time from their instantiation. The CutoffProt is instantiated with a retention_time parameter that discards such qubits in each node.\nEntanglementConsumer: This protocol runs between the end nodes and consumes the final entanglement generated as a result of all of the above protocols, which is supposed to represent the qubits being consumed in a networking application.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"All of the above protocols rely on the query and tagging functionality as described in the Tagging and Querying section.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"Other than that, ConcurrentSim and ResumableFunctions are used in the backend to run the discrete event simulation. Graphs helps with some functionality needed for the RegisterNet datastructure that forms the grid. GLMakie and NetworkLayout are used for visualization along with the visualization functionality implemented in QuantumSavory itself.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/#Custom-Predicate-And-Choosing-function","page":"Entanglement Generation On A Repeater Grid","title":"Custom Predicate And Choosing function","text":"","category":"section"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"function check_nodes(net, c_node, node; low=true)\n    n = Int(sqrt(size(net.graph)[1])) # grid size\n    c_x = c_node%n == 0 ? c_node ÷ n : (c_node ÷ n) + 1\n    c_y = c_node - n*(c_x-1)\n    x = node%n == 0 ? node ÷ n : (node ÷ n) + 1\n    y = node - n*(x-1)\n    return low ? (c_x - x) >= 0 && (c_y - y) >= 0 : (c_x - x) <= 0 && (c_y - y) <= 0\nend","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"The Swapper Protocol is initialized with a custom predicate function which is then placed in a call to queryall inside the Swapper to pick the nodes that are suitable to perform a swap with. The criteria for \"suitability\" is described below.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"This predicate function encodes most of the \"logic\" a local node will be performing.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"The custom predicate function shown above is parameterized with net and c_node along with the keyword argument low, when initializing the Swapper Protocol. This predicate function Int->Bool selects the target remote nodes for which a swap is appropriate. The arguments are:","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"net: The network of register nodes representing the graph structure, an instance of RegisterNet.\nc_node: The node in which the Swapper protocol would be running.\nnode: As the queryall function goes through all the nodes linked with the current node, the custom predicate filters them depending on whether the node is suitable for a swap or not.\nlow: The nodes in the grid are numbered as consecutive integers starting from 1. If the Swapper is running at some node n, we want a link closest to Alice and another closest to Bob to perform a swap. We communicate whether we are looking for nodes of the first kind or the latter with the low keyword.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"Out of all the links at some node, the suitable ones are picked by computing the difference between the coordinates of the current node with the coordinates of the candidate node. A low node should have both of the x and y coordinate difference positive and vice versa for a non-low node.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"As the Swapper gets a list of suitable candidates for a swap in each direction, the one with the furthest distance from the current node is chosen by summing the x distance and y-distance.","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"function choose_node(net, node, arr; low=true)\n    grid_size = Int(sqrt(size(net.graph)[1]))\n    return low ? argmax((distance.(grid_size, node, arr))) : argmin((distance.(grid_size, node, arr)))\nend\n\nfunction distance(n, a, b)\n    x1 = a%n == 0 ? a ÷ n : (a ÷ n) + 1\n    x2 = b%n == 0 ? b ÷ n : (b ÷ n) + 1\n    y1 = a - n*(x1-1)\n    y2 = b - n*(x2-1)\n\n    return x1 - x2 + y1 - y2\nend","category":"page"},{"location":"howto/repeatergrid/repeatergrid/#Simulation-and-Visualization","page":"Entanglement Generation On A Repeater Grid","title":"Simulation and Visualization","text":"","category":"section"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"n = 6 # the size of the square grid network (n × n)\nregsize = 8 # the size of the quantum registers at each node\n\ngraph = grid([n,n])\n\nnet = RegisterNet(graph, [Register(regsize, fill(5.0, regsize)) for i in 1:n^2])\n\nsim = get_time_tracker(net)\n\n# each edge is capable of generating raw link-level entanglement\nfor (;src, dst) in edges(net)\n    eprot = EntanglerProt(sim, net, src, dst; rounds=-1, randomize=true)\n    @process eprot()\nend\n\n# each node except the corners on one of the diagonals is capable of swapping entanglement\nfor i in 2:(n^2 - 1)\n    l(x) = check_nodes(net, i, x)\n    h(x) = check_nodes(net, i, x; low=false)\n    cL(arr) = choose_node(net, i, arr)\n    cH(arr) = choose_node(net, i, arr; low=false)\n    swapper = SwapperProt(sim, net, i; nodeL = l, nodeH = h, chooseL = cL, chooseH = cH, rounds=-1)\n    @process swapper()\nend\n\nfor v in vertices(net)\n    tracker = EntanglementTracker(sim, net, v)\n    @process tracker()\nend\n\n# Entanglement usage/consumption by the network end nodes\n\nconsumer = EntanglementConsumer(sim, net, 1, n^2)\n@process consumer()\n\n# decoherence protocol runs at each node to free up slots that haven't been used past the retention time\nfor v in vertices(net)\n    decprot = DecoherenceProt(sim, net, v)\n    @process decprot()\nend","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"We set up the simulation to run with a 6x6 grid of nodes above. Here, each node has 8 qubit slots. Each vertical and horizontal edge runs an entanglement generation protocol. Each node in the network runs an entanglement tracker protocol and all of the nodes except the nodes that we're trying to connect, i.e., Alice's and Bob's nodes which are at the diagonal ends of the grid run the swapper protocol. The code that runs and visualizes this simulation is shown below","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"fig = Figure(;size=(600, 600))\n\n# the network part of the visualization\nlayout = SquareGrid(cols=:auto, dx=10.0, dy=-10.0)(graph) # provided by NetworkLayout, meant to simplify plotting of graphs in 2D\n_, ax, _, obs = registernetplot_axis(fig[1:2,1], net;registercoords=layout)\n\n# the performance log part of the visualization\nentlog = Observable(consumer.log) # Observables are used by Makie to update the visualization in real-time in an automated reactive way\nts = @lift [e[1] for e in $entlog]  # TODO this needs a better interface, something less cluncky, maybe also a whole Makie recipe\ntzzs = @lift [Point2f(e[1],e[2]) for e in $entlog]\ntxxs = @lift [Point2f(e[1],e[3]) for e in $entlog]\nΔts = @lift length($ts)>1 ? $ts[2:end] .- $ts[1:end-1] : [0.0]\nentlogaxis = Axis(fig[1,2], xlabel=\"Time\", ylabel=\"Entanglement\", title=\"Entanglement Successes\")\nylims!(entlogaxis, (-1.04,1.04))\nstem!(entlogaxis, tzzs)\nhistaxis = Axis(fig[2,2], xlabel=\"ΔTime\", title=\"Histogram of Time to Successes\")\nhist!(histaxis, Δts)\n\ndisplay(fig)\n\nstep_ts = range(0, 200, step=0.1)\nrecord(fig, \"grid_sim6x6hv.mp4\", step_ts; framerate=10, visible=true) do t\n    run(sim, t)\n    notify.((obs,entlog))\n    ylims!(entlogaxis, (-1.04,1.04))\n    xlims!(entlogaxis, max(0,t-50), 1+t)\n    autolimits!(histaxis)\nend\n","category":"page"},{"location":"howto/repeatergrid/repeatergrid/#Result","page":"Entanglement Generation On A Repeater Grid","title":"Result","text":"","category":"section"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"include(\"../../../../examples/repeatergrid/1a_async_interactive_visualization.jl\") # hide","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"<video src=\"../grid_sim6x6hv.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/repeatergrid/repeatergrid/","page":"Entanglement Generation On A Repeater Grid","title":"Entanglement Generation On A Repeater Grid","text":"","category":"page"},{"location":"tutorial/noninstantgate/#Gate-duration,-i.e.-gates-that-are-not-instant","page":"Gate Duration","title":"Gate duration, i.e. gates that are not instant","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"There are a number of different ways to represent a gate that is not instantaneous in QuantumSavory. They are not necessarily equivalent. Here we show a couple of typical approaches.","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"We start with a quick initial setup of a register with two qubits and an observable pop representing the population in the excited state in the Z basis. The gate duration will be set to 1.0 (as given in ts) and the qubits will have decay time T1 = 2.0 so that we can more clearly demonstrate effects due to the non-instant nature of the gate.","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"using QuantumSavory\nusing CairoMakie\n\nT1 = 2.0\nreg = Register([Qubit(), Qubit()], [nothing, T1Decay(T1)])\ninitialize!(reg[1], Z₂)\ninitialize!(reg[2], Z₂)\n\npop = SProjector(Z₂)\ninitial_pop = observable(reg[2], pop)\n\nSTEPS = 20\nts = range(0,1,length=STEPS)","category":"page"},{"location":"tutorial/noninstantgate/#Approach-1:-Apply-an-instantaneous-gate-and-then-simply-wait","page":"Gate Duration","title":"Approach 1: Apply an instantaneous gate and then simply wait","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"A rather manual and simple approach. We will plot the value of the population observable over the entire waiting period.","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"reg_gate_wait = deepcopy(reg) # copy the register\napply!([reg_gate_wait[1],reg_gate_wait[2]], CNOT)\npop_gate_wait = [observable(reg_gate_wait[2], pop; time) for time in ts]\nall_pop_gate_wait = real.([initial_pop, pop_gate_wait...])                           #hide\nfig = Figure(size=(600,300))                                                         #hide\naxis = Axis(fig[1,1])                                                                #hide\nlines!([0,ts...], all_pop_gate_wait, color=Cycled(1), label=\"apply gate then wait\")  #hide\nfig[1, 2] = Legend(fig, axis, \"Implementation\", framevisible = false)                #hide\nfig                                                                                  #hide","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"Given that the gate flips from the initial excited state to the ground state, the T1 decay does not have any effect.","category":"page"},{"location":"tutorial/noninstantgate/#Approach-2:-Wait-and-then-apply-an-instantaneous-gate","page":"Gate Duration","title":"Approach 2: Wait and then apply an instantaneous gate","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"reg_wait_gate = deepcopy(reg)\npop_wait_gate = [observable(reg_wait_gate[2], pop; time) for time in ts]\napply!([reg_wait_gate[1],reg_wait_gate[2]], CNOT)\nfinal_pop_wait_gate = observable(reg_wait_gate[2], pop)\nall_pop_wait_gate = real.([initial_pop, pop_wait_gate..., final_pop_wait_gate])             #hide\nfig = Figure(size=(600,300))                                                                #hide\naxis = Axis(fig[1,1])                                                                       #hide\nlines!([0,ts...,ts[end]], all_pop_wait_gate, color=Cycled(2), label=\"wait then apply gate\") #hide\nfig[1, 2] = Legend(fig, axis, \"Implementation\", framevisible = false)                       #hide\nfig                                                                                         #hide","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"There has been significant decay before the gate is applied, which leads to only partially flipping the state (which is also mixed).","category":"page"},{"location":"tutorial/noninstantgate/#Approach-3:-The-[NonInstantGate](@ref)","page":"Gate Duration","title":"Approach 3: The NonInstantGate","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"using QuantumSavory: NonInstantGate\n\nreg_slow_cnot = deepcopy(reg)\ngate = NonInstantGate(CNOT, 1.0)\napply!([reg_slow_cnot[1],reg_slow_cnot[2]], CNOT)\nfinal_pop_slow_cnot = observable(reg_slow_cnot[2], pop)\nfig = Figure(size=(600,300))                                                      #hide\naxis = Axis(fig[1,1])                                                             #hide\nscatter!([0,ts[end]], real.([initial_pop, final_pop_slow_cnot]), color=Cycled(3), label=\"NonInstantGate\") #hide\nfig[1, 2] = Legend(fig, axis, \"Implementation\", framevisible = false)             #hide\nfig                                                                               #hide","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"NonInstantGate is convenient way to store a \"gate duration\" together with an arbitrary gate. As it does not permit sampling while the gate is being performed, we have only initial and final state. Internally, this is implemented by applying the gate instantaneously and then waiting.","category":"page"},{"location":"tutorial/noninstantgate/#Approach-4:-Continuous-application-of-a-Hamiltonian","page":"Gate Duration","title":"Approach 4: Continuous application of a Hamiltonian","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"The approximation of a gate+waiting above might be inappropriate for real systems (or at least it might be difficult to calibrate). Instead, one can simply provide the Hamiltonian that implements a give gate and QuantumSavory will automatically solve the corresponding dynamical equation.","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"Below we do it in two different ways: A single evolution for duration 1.0 (which does not permit sampling of the state in intermediary times):","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"reg_slow_ham  = deepcopy(reg)\nham_gate = ConstantHamiltonianEvolution(pi/2*SProjector(Z₂)⊗σˣ,1.0)\napply!([reg_slow_ham[1],reg_slow_ham[2]], ham_gate)\nfinal_pop_slow_ham = observable(reg_slow_ham[2], pop)","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"... and the same but performed in multiple separate steps in order to be able to plot the intermediary results:","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"reg_slow_ham_steps  = deepcopy(reg)\nham_gate_step = ConstantHamiltonianEvolution(pi/2*SProjector(Z₂)⊗σˣ, ts[2])\npop_slow_ham_steps = [\n    begin\n        apply!([reg_slow_ham_steps[1], reg_slow_ham_steps[2]], ham_gate_step)\n        observable(reg_slow_ham_steps[2], pop)\n    end\n    for _ in 2:STEPS\n]\nall_pop_slow_ham_steps = real.([initial_pop, pop_slow_ham_steps...])              #hide\nfig = Figure(size=(600,300))                                                      #hide\naxis = Axis(fig[1,1])                                                             #hide\nscatter!([0,ts[end]], real.([initial_pop, final_pop_slow_ham]), color=Cycled(4), label=\"Hamiltonian\", marker='▴', markersize=18) #hide\nlines!(ts, all_pop_slow_ham_steps, color=Cycled(5), label=\"Hamiltonian (steps)\")  #hide\nfig[1, 2] = Legend(fig, axis, \"Implementation\", framevisible = false)             #hide\nfig                                                                               #hide","category":"page"},{"location":"tutorial/noninstantgate/#Summary-and-comparison-of-all-results","page":"Gate Duration","title":"Summary and comparison of all results","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"Below we plot the results of each approach. As you can see, they are physically different and it might be important to calibrate them carefully to the situation at hand.","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"all_pop_gate_wait = real.([initial_pop, pop_gate_wait...])\nall_pop_wait_gate = real.([initial_pop, pop_wait_gate..., final_pop_wait_gate])\nall_pop_slow_ham_steps = real.([initial_pop, pop_slow_ham_steps...])\nfig = Figure(size=(600,300))\naxis = Axis(fig[1,1])\nlines!([0,ts...], all_pop_gate_wait, color=Cycled(1), label=\"apply gate then wait\")\nlines!([0,ts...,ts[end]], all_pop_wait_gate, color=Cycled(2), label=\"wait then apply gate\")\nscatter!([0,ts[end]], real.([initial_pop, final_pop_slow_cnot]), color=Cycled(3), label=\"NonInstantGate\")\nscatter!([0,ts[end]], real.([initial_pop, final_pop_slow_ham]), color=Cycled(4), label=\"Hamiltonian\", marker='▴', markersize=18)\nlines!(ts, all_pop_slow_ham_steps, color=Cycled(5), label=\"Hamiltonian (steps)\")\nfig[1, 2] = Legend(fig, axis, \"Implementation\", framevisible = false)\nfig","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate Duration","title":"Gate Duration","text":"","category":"page"},{"location":"tutorial/state_explorer/#Interactively-visualizing-two-qubit-states","page":"State Explorer","title":"Interactively visualizing two-qubit states","text":"","category":"section"},{"location":"tutorial/state_explorer/","page":"State Explorer","title":"State Explorer","text":"The QuantumSavory.StatesZoo.stateexplorer routine lets you generate an interactive state visualizer, that can also be used as an input state in interactive live simulations.","category":"page"},{"location":"tutorial/state_explorer/","page":"State Explorer","title":"State Explorer","text":"E.g. take the Barrett-Kok dual-rail heralded entanglement procedure – it produces a state that is available from QuantumSavory.StatesZoo as BarrettKokBellPairW. The following is enough to generate the interactive Makie figure:","category":"page"},{"location":"tutorial/state_explorer/","page":"State Explorer","title":"State Explorer","text":"stateexplorer!(fig, BarrettKokBellPairW)","category":"page"},{"location":"tutorial/state_explorer/","page":"State Explorer","title":"State Explorer","text":"Below we embed a live version of this state explorer (hosted at areweentangledyet.com/state_explorer/):","category":"page"},{"location":"tutorial/state_explorer/","page":"State Explorer","title":"State Explorer","text":"<iframe class=\"liveexample\" src=\"https://areweentangledyet.com/state_explorer/\" style=\"height:600px;width:850px;\"></iframe>","category":"page"},{"location":"tutorial/state_explorer/","page":"State Explorer","title":"State Explorer","text":"The source code is in the examples/state_explorer folder.","category":"page"},{"location":"tutorial/state_explorer/","page":"State Explorer","title":"State Explorer","text":"","category":"page"},{"location":"symbolics/#Symbolic-Expressions","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"","category":"section"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"QuantumSavory supports symbolic expressions for the quantum states and operations being simulated thanks to the QuantumSymbolics library. It serves two purposes:","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"It provides for algebraic manipulation of mathematical expressions related to your models. Particularly helpful when having to automatically generate or simplify expressions of significant complexity.\nAn assortment of \"expression translators\" are provided that can turn a symbolic expression into a numerical one in any of the representations supported by the simulator (e.g. wavefunctions, tableaux, etc).","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Below we list some commonly used expressions. For more detailed documentation consult QuantumSymbolics.jl.","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<table>\n<tr>\n<th></th><th>Symbolic Example</th><th>Conversion Example</th>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Qubit Basis States -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Qubit Basis States X1, X2, Y1, Y2, Z1, Z2","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Z1","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(Z1)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(Y2, CliffordRepr())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Common gates -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Common gates: CNOT, H, etc","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"CNOT","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(H)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(CNOT, CliffordRepr(), UseAsOperation())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Tensor products and sums -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Tensor products ⊗ and sums +","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"(X1⊗Z2 + Y1⊗Y2 ) / √3","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(X1⊗Z1)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(X1⊗Y2, CliffordRepr())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Projectors -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Projectors, pure density matrices","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"SProjector(X1⊗Z2)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(SProjector(X1⊗Z1))","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(SProjector(X1⊗Z1), CliffordRepr())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Completely mixed state -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Completely depolarized (mixed) state","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"MixedState(X1)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(MixedState(X1))","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(MixedState(X1), CliffordRepr())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Mixtures -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Impure states, represented as sum of density matrices","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"(MixedState(X1)+SProjector(Z1)) / 2","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express((MixedState(X1)+SProjector(Z1)) / 2)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"When a Clifford representation is used, an efficient sampler is generated, and stabilizer states are randomly sampled from the correct distribution:","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(MixedState(X1)/2+SProjector(Z1)/2, CliffordRepr())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</tr>\n</table>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"warning: Stabilizer state expressions\nThe state written as fracZ₁Z₁+Z₂Z₂2 is a well known stabilizer state, namely a Bell state. However, automatically expressing it as a stabilizer is a prohibitively expensive computational operation in general. We do not perform that computation automatically. If you want to ensure that states you define can be automatically converted to tableaux for Clifford simulations, avoid using summation of kets. On the other hand, in all of our Clifford Monte-Carlo simulations, ⊗ is fully supported, as well as SProjector, MixedState, StabilizerState, and summation of density matrices.","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"","category":"page"},{"location":"howto/simpleswitch/simpleswitch/#A-Simple-Entanglement-Switch","page":"Entanglement Switch","title":"A Simple Entanglement Switch","text":"","category":"section"},{"location":"howto/simpleswitch/simpleswitch/","page":"Entanglement Switch","title":"Entanglement Switch","text":"info: TODO Unfinished\nThis page is unfinished!","category":"page"},{"location":"howto/simpleswitch/simpleswitch/","page":"Entanglement Switch","title":"Entanglement Switch","text":"This example builds around the switching protocol implemented as part of QuantumSavory.ProtocolZoo.SimpleSwitchDiscreteProt.","category":"page"},{"location":"howto/simpleswitch/simpleswitch/","page":"Entanglement Switch","title":"Entanglement Switch","text":"Below we embed a live version of the simulation (hosted at areweentangledyet.com/simpleswitch/):","category":"page"},{"location":"howto/simpleswitch/simpleswitch/","page":"Entanglement Switch","title":"Entanglement Switch","text":"<iframe class=\"liveexample\" src=\"https://areweentangledyet.com/simpleswitch/\" style=\"height:1000px;width:1650px;\"></iframe>","category":"page"},{"location":"howto/simpleswitch/simpleswitch/","page":"Entanglement Switch","title":"Entanglement Switch","text":"The source code is in the examples/simpleswitch folder.","category":"page"},{"location":"howto/simpleswitch/simpleswitch/","page":"Entanglement Switch","title":"Entanglement Switch","text":"","category":"page"},{"location":"howto/firstgenrepeater_v2/firstgenrepeater_v2/#First-Generation-Quantum-Repeater-A-Simpler-Implementation","page":"1st-gen Repeater - simpler implementation","title":"First Generation Quantum Repeater - A Simpler Implementation","text":"","category":"section"},{"location":"howto/firstgenrepeater_v2/firstgenrepeater_v2/","page":"1st-gen Repeater - simpler implementation","title":"1st-gen Repeater - simpler implementation","text":"info: TODO Unfinished\nThis page is unfinished!","category":"page"},{"location":"howto/firstgenrepeater_v2/firstgenrepeater_v2/","page":"1st-gen Repeater - simpler implementation","title":"1st-gen Repeater - simpler implementation","text":"Compared to the lower-level implementation firstgenrepeater, which does not use convenient high-level abstractions, the code here (firstgenrepeater_v2) is drastically simpler. It is little more than direct calls to two pre-defined protocols available in QuantumSavory.ProtocolZoo: QuantumSavory.ProtocolZoo.EntanglerProt for probabilistic generation of nearest-neighbor entanglement and QuantumSavory.ProtocolZoo.SwapperProt for entanglement swapping, as well as QuantumSavory.ProtocolZoo.EntanglementTracker to keep track of all classical metadata and messaging necessary for the control of the network.","category":"page"},{"location":"howto/firstgenrepeater_v2/firstgenrepeater_v2/","page":"1st-gen Repeater - simpler implementation","title":"1st-gen Repeater - simpler implementation","text":"It is instructive to compare this simple-to-use setup with the much lengthier but equivalent implementation in firstgenrepeater, especially if one wants to develop reusable protocols of their own.","category":"page"},{"location":"howto/firstgenrepeater_v2/firstgenrepeater_v2/","page":"1st-gen Repeater - simpler implementation","title":"1st-gen Repeater - simpler implementation","text":"The source code is in the examples/firstgenrepeater_v2 folder.","category":"page"},{"location":"howto/firstgenrepeater_v2/firstgenrepeater_v2/","page":"1st-gen Repeater - simpler implementation","title":"1st-gen Repeater - simpler implementation","text":"","category":"page"},{"location":"discreteeventsimulator/#sim","page":"Discrete Event Simulator","title":"Discrete Event Simulator","text":"","category":"section"},{"location":"discreteeventsimulator/#Overview","page":"Discrete Event Simulator","title":"Overview","text":"","category":"section"},{"location":"discreteeventsimulator/","page":"Discrete Event Simulator","title":"Discrete Event Simulator","text":"Simulating quantum processes requires robust tools for Discrete Event Simulation. In QuantumSavory, we use ConcurrentSim.jl and ResumableFunctions.jl to model complex, asynchronous processes.","category":"page"},{"location":"discreteeventsimulator/","page":"Discrete Event Simulator","title":"Discrete Event Simulator","text":"This simulation framework enables protocols to handle dynamic interactions, such as waiting for resources to become available.","category":"page"},{"location":"discreteeventsimulator/#**ConcurrentSim.jl**-and-**ResumableFunctions.jl**","page":"Discrete Event Simulator","title":"ConcurrentSim.jl and ResumableFunctions.jl","text":"","category":"section"},{"location":"discreteeventsimulator/","page":"Discrete Event Simulator","title":"Discrete Event Simulator","text":"QuantumSavory discrete event simulations are based on ConcurrentSim.jl. A process is defined as a @resumable function that yields events, allowing for efficient resource allocation and the expression of protocols that pause until specific conditions are met. These features are essential for implementing waiting mechanisms, such as waiting for messages or changes in a quantum state.","category":"page"},{"location":"discreteeventsimulator/","page":"Discrete Event Simulator","title":"Discrete Event Simulator","text":"","category":"page"},{"location":"API_StatesZoo/#Predefined-Models-of-Quantum-States","page":"StatesZoo API","title":"Predefined Models of Quantum States","text":"","category":"section"},{"location":"API_StatesZoo/","page":"StatesZoo API","title":"StatesZoo API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API_StatesZoo/","page":"StatesZoo API","title":"StatesZoo API","text":"The submodule QuantumSavory.StatesZoo provides models for many frequently used quantum states.","category":"page"},{"location":"API_StatesZoo/#Autogenerated-API-list-for-QuantumSavory.StatesZoo","page":"StatesZoo API","title":"Autogenerated API list for QuantumSavory.StatesZoo","text":"","category":"section"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.BarrettKokBellPair","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.BarrettKokBellPair","text":"struct BarrettKokBellPair <: QuantumSavory.StatesZoo.AbstractTwoQubitState\n\nFields:\n\nηᴬ: Individual channel transmissivity from source A to entanglement swapping station, ∈[0,1]\nηᴮ: Individual channel transmissivity from source B to entanglement swapping station, ∈[0,1]\nPᵈ: Total excess noise (photons per qubit slot) in photon detectors, ≥0, usually ≪1\nηᵈ: Detection efficiency of photon detectors, ∈[0,1]\n𝒱: Mode matching parameter for individual interacting photonic pulses with |V| evaluates mode overlap and arg(V) evaluates the carrier phase mismatch, |V|∈[0,1]\nm: A single parity bit determined by the click pattern (m = 0 for [0, 1, 1, 0] or [1, 0, 0, 1]; m = 1 for [1, 1, 0, 0] or [0, 0, 1, 1])\nmetadata\n\nA symbolic representation of the noisy Bell pair state obtained in a Barrett-Kok style protocol (a sequence of two successful entanglement swaps), referred to as the \"dual rail photonic qubit swap\" in (Prajit Dhara and Guha, 2023) (see eq. C7).\n\nSee also BarrettKokBellPairW for the weighted density matrix.\n\n\n\n\n\n","category":"type"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.BarrettKokBellPair-Tuple{Any, Any}","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.BarrettKokBellPair","text":"BarrettKokBellPair(ηᴬ,ηᴮ)\n\nAsymmetric noiseless perfectly mode-matched case ηᴬ≠ηᴮ, Pᵈ=0, ηᵈ=1, 𝒱=1, m=0\n\n\n\n\n\n","category":"method"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.BarrettKokBellPair-Tuple{Any}","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.BarrettKokBellPair","text":"BarrettKokBellPair(η)\n\nSymmetric noiseless perfectly mode-matched case ηᴬ=ηᴮ=η, Pᵈ=0, ηᵈ=1, 𝒱=1, m=0\n\n\n\n\n\n","category":"method"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.BarrettKokBellPairW","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.BarrettKokBellPairW","text":"The weighted version of BarrettKokBellPair, i.e. its trace is the probability of successfully heralding a Barrett-Kok Bell pair.\n\n\n\n\n\n","category":"type"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.stateexplorer","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.stateexplorer","text":"An interactive explorer for two-qubit states. It returns a new figure.\n\nRequires a Makie plotting backend to be imported.\n\n\n\n\n\n","category":"function"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.stateexplorer!","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.stateexplorer!","text":"An interactive explorer for two-qubit states. It modifies the given figure.\n\nRequires a Makie plotting backend to be imported.\n\n\n\n\n\n","category":"function"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.stateparameters","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.stateparameters","text":"Return the \"interesting\" parameters that a state from the StatesZoo has. A constructor that uses only these parameters needs to exist.\n\nUsed by stateexplorer to generate the most valuable plots of figures of merit.\n\n\n\n\n\n","category":"function"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.stateparametersrange","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.stateparametersrange","text":"Return the valid ranges and the \"good\" value for all parameters listed in stateparameters.\n\n\n\n\n\n","category":"function"},{"location":"API_StatesZoo/","page":"StatesZoo API","title":"StatesZoo API","text":"","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/#QuantumSavory.W","page":"API","title":"QuantumSavory.W","text":"A wildcard instance for use with the tag querying functionality.\n\nSee also: query, tag!, ❓\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSavory.❓","page":"API","title":"QuantumSavory.❓","text":"A wildcard instance for use with the tag querying functionality.\n\nThis emoji can be inputted with the \\:question: emoji shortcut, or you can simply use the ASCII alternative W.\n\nSee also: query, tag!, W\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSavory.AbstractBackground","page":"API","title":"QuantumSavory.AbstractBackground","text":"An abstract type for the various background processes that might be inflicted upon a Register slot, e.g. decay, dephasing, etc.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.AmplitudeDamping","page":"API","title":"QuantumSavory.AmplitudeDamping","text":"A depolarization background.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.ConstantHamiltonianEvolution","page":"API","title":"QuantumSavory.ConstantHamiltonianEvolution","text":"Represents a Hamiltonian being applied for the given duration. See also NonInstantGate.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Depolarization","page":"API","title":"QuantumSavory.Depolarization","text":"A depolarization background.\n\nThe τ parameter specifies the average time between depolarization events (assuming a Poisson point process). I.e. after time t the probability for an depolarization event is 1-exp(-t/τ).\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.NonInstantGate","page":"API","title":"QuantumSavory.NonInstantGate","text":"Represents an gate applied instantaneously followed by a waiting period. See also ConstantHamiltonianEvolution.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.PauliNoise","page":"API","title":"QuantumSavory.PauliNoise","text":"A Pauli noise background.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.QuantumChannel","page":"API","title":"QuantumSavory.QuantumChannel","text":"Quantum channel for transmitting quantum states from one register to another.\n\nDelay and background noise processes are supported.\n\nThe function put! is used to take the contents of a RegRef and put it in the channel. That state can can then be received by a register (after a delay) using the take! method.\n\njulia> using QuantumSavory, ResumableFunctions, ConcurrentSim\n\njulia> regA = Register(1); regB = Register(1);\n\njulia> initialize!(regA[1], Z1);\n\njulia> sim = Simulation();\n\njulia> qc = QuantumChannel(sim, 10.0) # a delay of 10 units\nQuantumChannel{Qubit}(Qubit(), DelayQueue{Register}(ConcurrentSim.QueueStore{Register, Int64}, 10.0), nothing)\n\njulia> @resumable function alice_node(env, qc)\n            println(\"Putting Alice's qubit in the channel at \", now(env))\n            put!(qc, regA[1])\n        end\nalice_node (generic function with 1 method)\n\njulia> @resumable function bob_node(env, qc)\n            @yield take!(qc, regB[1])\n            println(\"Taking the qubit from alice at \", now(env))\n        end\nbob_node (generic function with 1 method)\n\njulia> @process alice_node(sim, qc); @process bob_node(sim, qc);\n\njulia> run(sim)\nPutting Alice's qubit in the channel at 0.0\nTaking the qubit from alice at 10.0\n\njulia> regA\nRegister with 1 slots: [ Qubit ]\n  Slots:\n    nothing\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.QuantumStateTrait","page":"API","title":"QuantumSavory.QuantumStateTrait","text":"An abstract type for the various types of states that can be given to Register slots, e.g. qubit, harmonic oscillator, etc.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Qubit","page":"API","title":"QuantumSavory.Qubit","text":"Specifies that a given register slot contains qubits.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Qumode","page":"API","title":"QuantumSavory.Qumode","text":"Specifies that a given register slot contains qumodes.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.RegRef","page":"API","title":"QuantumSavory.RegRef","text":"A reference to a Register slot, convenient for use with functions like apply!, etc.\n\njulia> r = Register(2)\n       initialize!(r[1], X₁)\n       observable(r[1], X)\n0.9999999999999998 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Register","page":"API","title":"QuantumSavory.Register","text":"The main data structure in QuantumSavory, used to represent a quantum register in an arbitrary formalism.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.RegisterNet","page":"API","title":"QuantumSavory.RegisterNet","text":"A network of Registers with convenient graph API as well.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.RegisterNet-Tuple{Graphs.SimpleGraphs.SimpleGraph, Any}","page":"API","title":"QuantumSavory.RegisterNet","text":"Construct a RegisterNet from a given list of Registers and a graph.\n\njulia> graph = grid([2,2]) # from Graphs.jl\n{4, 4} undirected simple Int64 graph\n\njulia> registers = [Register(1), Register(2), Register(1), Register(2)]\n4-element Vector{Register}:\n Register with 1 slots: [ Qubit ]\n  Slots:\n    nothing\n Register with 2 slots: [ Qubit | Qubit ]\n  Slots:\n    nothing\n    nothing\n Register with 1 slots: [ Qubit ]\n  Slots:\n    nothing\n Register with 2 slots: [ Qubit | Qubit ]\n  Slots:\n    nothing\n    nothing\n\njulia> net = RegisterNet(graph, registers)\nA network of 4 registers in a graph of 4 edges\n\n\njulia> neighbors(net, 1) # from Graphs.jl\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.RegisterNet-Tuple{Vector{Register}}","page":"API","title":"QuantumSavory.RegisterNet","text":"Construct a RegisterNet from a given list of Registers, defaulting to a chain topology.\n\njulia> net = RegisterNet([Register(2), Register(4), Register(2)])\nA network of 3 registers in a graph of 2 edges\n\njulia> neighbors(net,2) # from Graphs.jl\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.T1Decay","page":"API","title":"QuantumSavory.T1Decay","text":"A background describing the T₁ decay of a two-level system.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.T2Dephasing","page":"API","title":"QuantumSavory.T2Dephasing","text":"A background describing the T₂ dephasing of a two-level system.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Tag","page":"API","title":"QuantumSavory.Tag","text":"Tags are used to represent classical metadata describing the state (or even history) of nodes and their registers. The library allows the construction of custom tags using the Tag constructor. Currently tags are implemented as instances of a sum type and have fairly constrained structure. Most of them are constrained to contain only Symbol instances and integers.\n\nHere is an example of such a generic tag:\n\njulia> Tag(:sometagdescriptor, 1, 2, -3)\nSymbolIntIntInt(:sometagdescriptor, 1, 2, -3)::Tag\n\nA tag can have a custom DataType as first argument, in which case additional customizability in printing is available. E.g. consider the [EntanglementHistory] tag used to track how pairs were entangled before a swap happened.\n\njulia> using QuantumSavory.ProtocolZoo: EntanglementHistory\n\njulia> Tag(EntanglementHistory, 1, 2, 3, 4, 5)\nWas entangled to 1.2, but swapped with .5 which was entangled to 3.4\n\nSee also: tag!, query\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumInterface.apply!-Tuple{Vector{Register}, Union{Tuple{Vararg{Int64}}, AbstractVector{<:Int64}}, Any}","page":"API","title":"QuantumInterface.apply!","text":"Apply a given operation on the given set of register slots.\n\napply!([regA, regB], [slot1, slot2], Gates.CNOT) would apply a CNOT gate on the content of the given registers at the given slots. The appropriate representation of the gate is used, depending on the formalism under which a quantum state is stored in the given registers. The Hilbert spaces of the registers are automatically joined if necessary.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.traceout!-Tuple{Register, Int64}","page":"API","title":"QuantumInterface.traceout!","text":"Delete the given slot of the given register.\n\ntraceout!(reg, slot) would reset (perform a partial trace) over the given subsystem. The Hilbert space of the register gets automatically shrunk.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.channel-Tuple{RegisterNet, Vararg{Any}}","page":"API","title":"QuantumSavory.channel","text":"Get a handle to a classical channel between two registers.\n\nUsually used for sending classical messages between registers. It can be used for receiving as well, but a more convenient choice is messagebuffer, which is a message buffer listening to all channels sending to a given destination register.\n\njulia> net = RegisterNet([Register(2), Register(2), Register(2)]) # defaults to a chain topology\nA network of 3 registers in a graph of 2 edges\n\njulia> channel(net, 1=>2)\nConcurrentSim.DelayQueue{Tag}(ConcurrentSim.QueueStore{Tag, Int64}, 0.0)\n\njulia> channel(net, 1=>2)\nConcurrentSim.DelayQueue{Tag}(ConcurrentSim.QueueStore{Tag, Int64}, 0.0)\n\njulia> channel(net, 1=>2) === channel(net, net[1]=>net[2])\ntrue\n\nSee also: qchannel, messagebuffer\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.findfreeslot-Tuple{Register}","page":"API","title":"QuantumSavory.findfreeslot","text":"Find an empty unlocked slot in a given Register.\n\njulia> reg = Register(3); initialize!(reg[1], X); lock(reg[2]);\n\njulia> findfreeslot(reg) == reg[3]\ntrue\n\njulia> lock(findfreeslot(reg));\n\njulia> findfreeslot(reg) |> isnothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.generate_map","page":"API","title":"QuantumSavory.generate_map","text":"Generates a default map with country and state boundaries and returns a GeoAxis. The returned GeoAxis can be used as an input for registernetplot_axis.\n\nThe Tyler package must be installed and imported.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.initialize!-Tuple{Union{Tuple{Vararg{Register}}, AbstractVector{<:Register}}, Union{Tuple{Vararg{Int64}}, AbstractVector{<:Int64}}, Any}","page":"API","title":"QuantumSavory.initialize!","text":"Set the state of a given set of registers.\n\ninitialize!([regA,regB], [slot1,slot2], state) would set the state of the given slots in the given registers to state. state can be any supported state representation, e.g., kets or density matrices from QuantumOptics.jl or tableaux from QuantumClifford.jl.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.krausops","page":"API","title":"QuantumSavory.krausops","text":"For a given background noise type, provide the corresponding Kraus operators, in a QuantumOptics.jl representation.\n\nSee also: paulinoise, lindbladop\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.krausops-Tuple{Depolarization, Any}","page":"API","title":"QuantumSavory.krausops","text":"The Kraus operators for depolarization are √(1-3p/4) I, √p/2 * X, √p/2 * Y, √p/2 Z\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.krausops-Tuple{T1Decay, Any}","page":"API","title":"QuantumSavory.krausops","text":"The Kraus operators for a T₁ process\n\nA₁ = |0⟩⟨0| + √(1-γ) |1⟩⟨1|\nA₂ = √γ |0⟩⟨1|\nλ = 1 - exp(-Δt/T₁)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.krausops-Tuple{T2Dephasing, Any}","page":"API","title":"QuantumSavory.krausops","text":"The Kraus operators for a T₂ process\n\nOne option is the following (more popular in the literature):\n\nP₁ = |0⟩⟨0| + √(1-λ) |1⟩⟨1|\nP₂ = √λ |1⟩⟨1|\nλ = 1 - exp(-2Δt/T₂)\n\nAn equivalent option is (more convenient when converting to a Pauli error channel):\n\nP₁′ = √(1-p/2) I\nP₂′ = √(p/2) Z\np = 1 - exp(-Δt/T₂)\n\nThese two options are equivalent under a unitary transformation. We implement the second one.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.lindbladop","page":"API","title":"QuantumSavory.lindbladop","text":"For a given background noise type, provide the corresponding Lindblad collapse operator, in a QuantumOptics.jl representation.\n\nSee also: paulinoise, krausops\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.lindbladop-Tuple{AmplitudeDamping, Any}","page":"API","title":"QuantumSavory.lindbladop","text":"1/√τ â\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.lindbladop-Tuple{T1Decay}","page":"API","title":"QuantumSavory.lindbladop","text":"1/√T₁ |0⟩⟨1|\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.lindbladop-Tuple{T2Dephasing}","page":"API","title":"QuantumSavory.lindbladop","text":"1/√(2T₂) Z\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.messagebuffer-Tuple{RegisterNet, Int64}","page":"API","title":"QuantumSavory.messagebuffer","text":"messagebuffer(\n    net::RegisterNet,\n    dst::Int64\n) -> MessageBuffer{Tag}\n\n\nGet a handle to a classical message buffer corresponding to all channels sending to a given destination register.\n\nSee also: channel\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.messagebuffer-Tuple{Union{RegRef, Register}}","page":"API","title":"QuantumSavory.messagebuffer","text":"messagebuffer(\n    ref::Union{RegRef, Register}\n) -> MessageBuffer{Tag}\n\n\nGet a handle to a classical message buffer corresponding to all channels sending to a given destination register.\n\nSee also: channel\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.observable-Tuple{Union{Tuple{Vararg{Register}}, AbstractVector{<:Register}}, Union{Tuple{Vararg{Int64}}, AbstractVector{<:Int64}}, Any}","page":"API","title":"QuantumSavory.observable","text":"Calculate the expectation value of a quantum observable on the given register and slot.\n\nobservable([regA, regB], [slot1, slot2], obs) would calculate the expectation value of the obs observable (using the appropriate formalism, depending on the state representation in the given registers).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.paulinoise","page":"API","title":"QuantumSavory.paulinoise","text":"For a given background noise type, provide the corresponding (potentially twirled) Pauli operators and the probabilities for the operators to act, in a QuantumClifford.jl representation.\n\nSee also: krausops, lindbladop\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.paulinoise-Tuple{Depolarization, Any}","page":"API","title":"QuantumSavory.paulinoise","text":"The Pauli operator and probability of its application for a Depolarization process.\n\n((p/4, X), (p/4, Y), (p/4, Z)) for p = 1-exp(-Δt/τ)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.paulinoise-Tuple{T2Dephasing, Any}","page":"API","title":"QuantumSavory.paulinoise","text":"The Pauli operator and probability of its application for a T₂ process.\n\n(1-exp(-Δt/T₂)) / 2 and Z\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.project_traceout!","page":"API","title":"QuantumSavory.project_traceout!","text":"Perform a projective measurement on the given slot of the given register.\n\nproject_traceout!(reg, slot, [stateA, stateB]) performs a projective measurement, projecting on either stateA or stateB, returning the index of the subspace on which the projection happened. It assumes the list of possible states forms a basis for the Hilbert space. The Hilbert space of the register is automatically shrunk.\n\nA basis object can be specified on its own as well, e.g. project_traceout!(reg, slot, basis).\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.qchannel-Tuple{RegisterNet, Vararg{Any}}","page":"API","title":"QuantumSavory.qchannel","text":"Get a handle to a quantum channel between two registers.\n\njulia> net = RegisterNet([Register(2), Register(2), Register(2)]) # defaults to a chain topology\nA network of 3 registers in a graph of 2 edges\n\njulia> qchannel(net, 1=>2)\nQuantumChannel{Qubit}(Qubit(), ConcurrentSim.DelayQueue{Register}(ConcurrentSim.QueueStore{Register, Int64}, 0.0), nothing)\n\njulia> qchannel(net, 1=>2) === qchannel(net, net[1]=>net[2])\ntrue\n\nSee also: channel\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.query-Union{Tuple{N}, Tuple{MessageBuffer, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N","page":"API","title":"QuantumSavory.query","text":"query(\n    mb::MessageBuffer,\n    queryargs::Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}...\n) -> Union{Nothing, NamedTuple{(:depth, :src, :tag), <:Tuple{Int64, Any, Any}}}\n\n\nYou are advised to actually use querydelete!, not query when working with classical message buffers.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.query-Union{Tuple{N}, Tuple{Union{RegRef, Register}, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N","page":"API","title":"QuantumSavory.query","text":"query(\n    reg::Union{RegRef, Register},\n    queryargs::Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}...;\n    locked,\n    assigned,\n    filo\n) -> Any\n\n\nA query function searching for the first slot in a register that has a given tag.\n\nWildcards are supported (instances of Wildcard also available as the constants W or the emoji ❓ which can be entered as \\:question: in the REPL). Predicate functions are also supported (they have to be Int↦Bool functions). The order of query lookup can be specified in terms of FIFO or FILO and defaults to FILO if not specified. The keyword arguments locked and assigned can be used to check, respectively, whether the given slot is locked or whether it contains a quantum state. The keyword argument filo can be used to specify whether the search should be done in a FIFO or FILO order, defaulting to filo=true (i.e. a stack-like behavior).\n\njulia> r = Register(10);\n       tag!(r[1], :symbol, 2, 3);\n       tag!(r[2], :symbol, 4, 5);\n\n\njulia> query(r, :symbol, 4, 5)\n(slot = Slot 2, id = 4, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n\njulia> lock(r[1]);\n\njulia> query(r, :symbol, 4, 5; locked=false) |> isnothing\nfalse\n\njulia> query(r, :symbol, ❓, 3)\n(slot = Slot 1, id = 3, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\njulia> query(r, :symbol, ❓, 3; assigned=true) |> isnothing\ntrue\n\njulia> query(r, :othersym, ❓, ❓) |> isnothing\ntrue\n\njulia> tag!(r[5], Int, 4, 5);\n\njulia> query(r, Float64, 4, 5) |> isnothing\ntrue\n\njulia> query(r, Int, 4, >(7)) |> isnothing\ntrue\n\njulia> query(r, Int, 4, <(7))\n(slot = Slot 5, id = 5, tag = TypeIntInt(Int64, 4, 5)::Tag)\n\nA query can be on on a single slot of a register:\n\njulia> r = Register(5);\n\njulia> tag!(r[2], :symbol, 2, 3);\n\njulia> query(r[2], :symbol, 2, 3)\n(slot = Slot 2, id = 6, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\njulia> query(r[3], :symbol, 2, 3) === nothing\ntrue\n\njulia> queryall(r[2], :symbol, 2, 3)\n1-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:\n (slot = Slot 2, id = 6, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\nSee also: queryall, tag!, W, ❓\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.queryall-Union{Tuple{N}, Tuple{Union{RegRef, Register}, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N","page":"API","title":"QuantumSavory.queryall","text":"queryall(\n    reg::Union{RegRef, Register},\n    queryargs::Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}...;\n    filo,\n    kwargs...\n) -> Any\n\n\nA query function that returns all slots of a register that have a given tag, with support for predicates and wildcards.\n\njulia> r = Register(10);\n       tag!(r[1], :symbol, 2, 3);\n       tag!(r[2], :symbol, 4, 5);\n\njulia> queryall(r, :symbol, ❓, ❓)\n2-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:\n (slot = Slot 2, id = 2, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n (slot = Slot 1, id = 1, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\njulia> queryall(r, :symbol, ❓, >(4))\n1-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:\n (slot = Slot 2, id = 2, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n\njulia> queryall(r, :symbol, ❓, >(5))\n@NamedTuple{slot::RegRef, id::Int128, tag::Tag}[]\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.querydelete!-Tuple{MessageBuffer, Vararg{Any}}","page":"API","title":"QuantumSavory.querydelete!","text":"querydelete!(\n    mb::MessageBuffer,\n    args...\n) -> Union{Nothing, @NamedTuple{src::Union{Nothing, Int64}, tag::T} where T}\n\n\nA query for classical message buffers that also deletes the message out of the buffer.\n\njulia> net = RegisterNet([Register(3), Register(2)])\nA network of 2 registers in a graph of 1 edges\n\njulia> put!(channel(net, 1=>2), Tag(:my_tag));\n\njulia> put!(channel(net, 1=>2), Tag(:another_tag, 123, 456));\n\njulia> query(messagebuffer(net, 2), :my_tag)\n\njulia> run(get_time_tracker(net))\n\njulia> query(messagebuffer(net, 2), :my_tag)\n(depth = 1, src = 1, tag = Symbol(:my_tag)::Tag)\n\njulia> querydelete!(messagebuffer(net, 2), :my_tag)\n@NamedTuple{src::Union{Nothing, Int64}, tag::Tag}((1, Symbol(:my_tag)::Tag))\n\njulia> querydelete!(messagebuffer(net, 2), :my_tag) === nothing\ntrue\n\njulia> querydelete!(messagebuffer(net, 2), :another_tag, ❓, ❓)\n@NamedTuple{src::Union{Nothing, Int64}, tag::Tag}((1, SymbolIntInt(:another_tag, 123, 456)::Tag))\n\njulia> querydelete!(messagebuffer(net, 2), :another_tag, ❓, ❓) === nothing\ntrue\n\nYou can also wait on a message buffer for a message to arrive before running a query:\n\njulia> using ResumableFunctions; using ConcurrentSim;\n\njulia> net = RegisterNet([Register(3), Register(2), Register(3)])\nA network of 3 registers in a graph of 2 edges\n\njulia> env = get_time_tracker(net);\n\njulia> @resumable function receive_tags(env)\n           while true\n               mb = messagebuffer(net, 2)\n               @yield wait(mb)\n               msg = querydelete!(mb, :second_tag, ❓, ❓)\n               print(\"t=$(now(env)): query returns \")\n               if isnothing(msg)\n                   println(\"nothing\")\n               else\n                   println(\"$(msg.tag) received from node $(msg.src)\")\n               end\n           end\n       end\nreceive_tags (generic function with 1 method)\n\njulia> @resumable function send_tags(env)\n           @yield timeout(env, 1.0)\n           put!(channel(net, 1=>2), Tag(:my_tag))\n           @yield timeout(env, 2.0)\n           put!(channel(net, 3=>2), Tag(:second_tag, 123, 456))\n       end\nsend_tags (generic function with 1 method)\n\njulia> @process send_tags(env);\n\njulia> @process receive_tags(env);\n\njulia> run(env, 10)\nt=1.0: query returns nothing\nt=3.0: query returns SymbolIntInt(:second_tag, 123, 456)::Tag received from node 3\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.querydelete!-Tuple{Union{RegRef, Register}, Vararg{Any}}","page":"API","title":"QuantumSavory.querydelete!","text":"querydelete!(\n    reg::Union{RegRef, Register},\n    args...;\n    kwa...\n) -> Any\n\n\nA query for Register or a register slot (i.e. a RegRef) that also deletes the tag.\n\njulia> reg = Register(3)\n       tag!(reg[1], :tagA, 1, 2, 3)\n       tag!(reg[2], :tagA, 10, 20, 30)\n       tag!(reg[2], :tagB, 6, 7, 8);\n\njulia> queryall(reg, :tagA, ❓, ❓, ❓)\n2-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:\n (slot = Slot 2, id = 4, tag = SymbolIntIntInt(:tagA, 10, 20, 30)::Tag)\n (slot = Slot 1, id = 3, tag = SymbolIntIntInt(:tagA, 1, 2, 3)::Tag)\n\njulia> querydelete!(reg, :tagA, ❓, ❓, ❓)\n(slot = Slot 2, id = 4, tag = SymbolIntIntInt(:tagA, 10, 20, 30)::Tag)\n\njulia> queryall(reg, :tagA, ❓, ❓, ❓)\n1-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:\n (slot = Slot 1, id = 3, tag = SymbolIntIntInt(:tagA, 1, 2, 3)::Tag)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.registernetplot","page":"API","title":"QuantumSavory.registernetplot","text":"Draw the given register network.\n\nRequires a Makie backend be already imported.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.registernetplot!","page":"API","title":"QuantumSavory.registernetplot!","text":"Draw the given register network on a given Makie axis.\n\nRequires a Makie backend be already imported.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.registernetplot_axis","page":"API","title":"QuantumSavory.registernetplot_axis","text":"Draw the given register network on a given Makie axis or subfigure and modify the axis with numerous visualization enhancements.\n\nRequires a Makie backend be already imported.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.resourceplot_axis","page":"API","title":"QuantumSavory.resourceplot_axis","text":"Draw the various resources and locks stored in the given meta-graph on a given Makie axis.\n\nRequires a Makie backend be already imported.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.subsystemcompose-Tuple{Union{Tuple{Vararg{Register}}, AbstractVector{<:Register}}, Any}","page":"API","title":"QuantumSavory.subsystemcompose","text":"Ensure that the all slots of the given registers are represented by one single state object, i.e. that all the register slots are tracked in the same Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.tag!-Tuple{RegRef, Any}","page":"API","title":"QuantumSavory.tag!","text":"tag!(ref::RegRef, tag) -> Int128\n\n\nAssign a tag to a slot in a register.\n\nSee also: query, untag!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.untag!-Tuple{Union{RegRef, Register}, Integer}","page":"API","title":"QuantumSavory.untag!","text":"untag!(\n    ref::Union{RegRef, Register},\n    id::Integer\n) -> @NamedTuple{tag::Tag, slot::Int64, time::Float64}\n\n\nRemove the tag with the given id from a RegRef or a Register.\n\nTo remove a tag based on a query, use querydelete! instead.\n\nSee also: querydelete!, query, tag!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.uptotime!","page":"API","title":"QuantumSavory.uptotime!","text":"Evolve all the states in a register to a given time, according to the various backgrounds that they might have.\n\njulia> reg = Register(2, T1Decay(1.0))\nRegister with 2 slots: [ Qubit | Qubit ]\n  Slots:\n    nothing\n    nothing\n\njulia> initialize!(reg[1], X₁)\n       observable(reg[1], σᶻ)\n0.0 + 0.0im\n\njulia> uptotime!(reg[1], 10)\n       observable(reg[1], Z)\n0.9999546000702374 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"register_interface/#Register-Interface","page":"Register Interface","title":"Register Interface","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"A rather diverse set of simulation libraries is used under the hood. Long term the Julia Quantum Science community might be able to converge to a common interface that would slightly simplify work between the libraries, but in the interim the Julia multimethod paradigm is sufficient. Below we describe the interface that enables us to operate with many distinct underlying simulators.","category":"page"},{"location":"register_interface/#initialize!","page":"Register Interface","title":"initialize!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Initialize the state of a register to a known state.","category":"page"},{"location":"register_interface/#QuantumSavory.initialize!-register_interface","page":"Register Interface","title":"QuantumSavory.initialize!","text":"Set the state of a given set of registers.\n\ninitialize!([regA,regB], [slot1,slot2], state) would set the state of the given slots in the given registers to state. state can be any supported state representation, e.g., kets or density matrices from QuantumOptics.jl or tableaux from QuantumClifford.jl.\n\n\n\n\n\n","category":"function"},{"location":"register_interface/#initialize!(refs::Vector{RegRef},-state;-time)","page":"Register Interface","title":"initialize!(refs::Vector{RegRef}, state; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Store a state in the given register slots.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"refs can also be Tuple{Vararg{RegRef, N}} or a single RegRef.","category":"page"},{"location":"register_interface/#initialize!(r::Vector{Register},-i::Vector{Int64},-state;-time)","page":"Register Interface","title":"initialize!(r::Vector{Register}, i::Vector{Int64}, state; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"r can also be a single Register.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"The accesstimes attributes of the slots are reset to the given time.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"If state<:Symbolic, then consistent_representation is used to choose an appropriate representation based on the AbstractRepresentation properties of the register slots. Then an express call is made to transform the symbolic object into the appropriate representation.","category":"page"},{"location":"register_interface/#initialize!(r::RegRef;-time)-and-initialize!(reg::Register,-i::Int64;-time)","page":"Register Interface","title":"initialize!(r::RegRef; time) and initialize!(reg::Register, i::Int64; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"When a state is not provided, a default one is calculated from newstate, depending on the register slot's QuantumStateTrait (e.g. qubit vs qumode) and AbstractRepresentation (e.g. ket vs tableaux).","category":"page"},{"location":"register_interface/#Interface-Overview","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"flowchart TB\n  A[\"<code>initialize!(refs::Vector{RegRef}, state; time)</code>\"]\n  B[\"<code>initialize!(r::Vector{Register}, i, state; time)</code>\"]\n  subgraph TOP [lower from registers to states]\n    direction LR\n  end\n  D{{\"<code>state<:Symbolic</code>\"}}\n  subgraph D1 [express state]\n    direction LR\n    d11[\"<code>consistent_representation(r,i,state)</code>\"]\n    d12[\"<code>express(state,repr)</code>\"]\n    d11 --> d12\n  end\n  D2([Store a state reference\\nin the register slots])\n  A --> B --> TOP --> D\n  D --Yes--> D1\n  D --No--> D2\n  D1 --> D2\n  Ap[\"<code>initialize!(::RegRef; time)</code>\"]\n  Bp[\"<code>initialize!(::Register, i; time)</code>\"]\n  Cp[\"<code>newstate(::QuantumStateTrait, ::AbstractRepresentation)</code>\"]\n  subgraph TOPp [lower from registers to states]\n    direction LR\n  end\n  Ap --> Bp --> TOPp --> Cp ---> D2","category":"page"},{"location":"register_interface/#apply!","page":"Register Interface","title":"apply!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Apply a quantum operation to a register.","category":"page"},{"location":"register_interface/#QuantumInterface.apply!-register_interface","page":"Register Interface","title":"QuantumInterface.apply!","text":"Apply a given operation on the given set of register slots.\n\napply!([regA, regB], [slot1, slot2], Gates.CNOT) would apply a CNOT gate on the content of the given registers at the given slots. The appropriate representation of the gate is used, depending on the formalism under which a quantum state is stored in the given registers. The Hilbert spaces of the registers are automatically joined if necessary.\n\n\n\n\n\n","category":"function"},{"location":"register_interface/#apply!(refs::Vector{RegRef},-operation;-time)","page":"Register Interface","title":"apply!(refs::Vector{RegRef}, operation; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Applying an operation to the qubits referred to by the sequence of RegRefs at a specified time.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"refs can also be Tuple{Vararg{RegRef, N}} or a single RegRef.","category":"page"},{"location":"register_interface/#apply!(regs::Vector{Register},-indices,-operation;-time)","page":"Register Interface","title":"apply!(regs::Vector{Register}, indices, operation; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"indices refers to the slots inside of the given regs.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls uptotime! in order to update any AbstractBackground properties.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls subsystemcompose in order to make one big state. Then goes to apply!(state, subsystem_indices, operation; time).","category":"page"},{"location":"register_interface/#apply!(state,-subsystem_indices,-operation;-time)","page":"Register Interface","title":"apply!(state, subsystem_indices, operation; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"subsystem_indices refers to subsystems in state.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"If operation<:Symbolic, then express(operation, repr, ::UseAsOperation) is used to convert the symbolic operation into something workable for the given state type. repr is chosen by dispatch on state.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"warning: Limitations of symbolic-to-explicit conversion\nCurrently, the decision of how to convert a symbolic operation is based only on the state on which the operation would act. It can not be modified by the AbstractRepresentation properties of the Registers containing the state.","category":"page"},{"location":"register_interface/#Interface-Overview-2","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"flowchart TB\n  A[\"<code>apply!(refs::Vector{RegRef}, operation; time)</code>\"]\n  B[\"<code>apply!(regs::Vector{Register}, indices, operation; time)</code>\"]\n  subgraph TOP [lower from registers to states]\n    direction LR\n    B1[\"<code>uptotime!</code>\"]\n    B2[\"<code>subsystemcompose</code>\"]\n    B1 --> B2\n  end\n  C[\"<code>apply!(state, subsystem_indices, operation; time)</code>\"]\n  D{{\"<code>operation<:Symbolic</code>\"}}\n  D1[\"<code>express(operation, repr, ::UseAsOperation)</code>\"]\n  D2([Dispatch on state to low level implementation<br>in an independent library])\n  A --> B --> TOP --> C --> D\n  D --Yes--> D1\n  D --No--> D2\n  D1 --> D2","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"warning: Limitations of symbolic-to-explicit conversion\nAs mentioned above, converting from symbolic to explicit representation for the operation is dependent only on the type of state, i.e. by the time the conversion is done, no knowledge of the register and its properties are kept (in particular its preferred representation is not considered).","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"info: Short-circuiting the `express` dispatch\nYou can add a custom dispatch that skips the express functionality by defining a method apply!(state::YourStateType, indices, operation<:Symbolic{AbstractOperator}). This would preemt the default apply!(state, indices, operation<:Symbolic{AbstractOperator}) containing the express logic. The drawback is that this would also skip the memoization employed by express.","category":"page"},{"location":"register_interface/#observable","page":"Register Interface","title":"observable","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Measure a quantum observable. The dispatch down the call three is very similar to the one for apply!.","category":"page"},{"location":"register_interface/#QuantumSavory.observable-register_interface","page":"Register Interface","title":"QuantumSavory.observable","text":"Calculate the expectation value of a quantum observable on the given register and slot.\n\nobservable([regA, regB], [slot1, slot2], obs) would calculate the expectation value of the obs observable (using the appropriate formalism, depending on the state representation in the given registers).\n\n\n\n\n\n","category":"function"},{"location":"register_interface/#observable(refs::Tuple{Vararg{RegRef,-N}},-obs;-somethingnothing,-timenothing)","page":"Register Interface","title":"observable(refs::Tuple{Vararg{RegRef, N}}, obs; something=nothing, time=nothing)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calculate the value of an observable on the state in the sequence of RegRefs at a specified time. If these registers are not instantiated, return something.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"refs can also be Tuple{Vararg{RegRef, N}} or a single RegRef.","category":"page"},{"location":"register_interface/#observable(regs::Vector{Register},-indices,-obs;-somethingnothing,-timenothing)","page":"Register Interface","title":"observable(regs::Vector{Register}, indices, obs; something=nothing, time=nothing)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"indices refers to the slots inside of the given regs.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls uptotime! in order to update any AbstractBackground properties.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls subsystemcompose in order to make one big state. Then goes to observable(state, subsystem_indices, obs; time).","category":"page"},{"location":"register_interface/#observable(state,-subsystem_indices,-obs;-time)","page":"Register Interface","title":"observable(state, subsystem_indices, obs; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"subsystem_indicesrefers to subsystems instate`.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"If operation<:Symbolic, then an express(obs, repr, ::UseAsObservable) call is used to convert the symbolic obs into something workable for the given state type. repr is chosen by dispatch on state.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"warning: Limitations of symbolic-to-explicit conversion\nSimilar to the limitations faced by apply!","category":"page"},{"location":"register_interface/#Interface-Overview-3","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"flowchart TB\n  A[\"<code>observable(refs::Vector{RegRef}, obs; something=nothing, time)</code>\"]\n  B[\"<code>observable(regs::Vector{Register}, indices, obs; something=nothing, time)</code>\"]\n  subgraph TOP [lower from registers to states]\n    direction LR\n    B1[\"<code>uptotime!</code>\"]\n    B2[\"<code>subsystemcompose</code>\"]\n    B1 --> B2\n  end\n  C[\"<code>observable(state, subsystem_indices, obs; time)</code>\"]\n  D{{\"<code>obs<:Symbolic</code>\"}}\n  D1[\"<code>express(obs, repr, ::UseAsObservable)</code>\"]\n  D2([Dispatch on state to low level implementation<br>in an independent library])\n  A --> B --> TOP --> C --> D\n  D --Yes--> D1\n  D --No--> D2\n  D1 --> D2","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"info: Short-circuiting the `express` dispatch\nSimilarly to the case with apply!, you can skips the express functionality by defining a method observable(state::YourStateType, indices, obs<:Symbolic{AbstractOperator}).","category":"page"},{"location":"register_interface/#project_traceout!","page":"Register Interface","title":"project_traceout!","text":"","category":"section"},{"location":"register_interface/#QuantumSavory.project_traceout!-register_interface","page":"Register Interface","title":"QuantumSavory.project_traceout!","text":"Perform a projective measurement on the given slot of the given register.\n\nproject_traceout!(reg, slot, [stateA, stateB]) performs a projective measurement, projecting on either stateA or stateB, returning the index of the subspace on which the projection happened. It assumes the list of possible states forms a basis for the Hilbert space. The Hilbert space of the register is automatically shrunk.\n\nA basis object can be specified on its own as well, e.g. project_traceout!(reg, slot, basis).\n\n\n\n\n\n","category":"function"},{"location":"register_interface/#project_traceout!(r::RegRef,-basis;-time)","page":"Register Interface","title":"project_traceout!(r::RegRef, basis; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Project the state in RegRef on basis at a specified time. basis can be a Vector or Tuple of basis states, or it can be a Matrix like Z or X.","category":"page"},{"location":"register_interface/#project_traceout(reg::Register,-i::Int,-basis;-time)","page":"Register Interface","title":"project_traceout(reg::Register, i::Int, basis; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Project the state in the slot in index i of Register on basis at a specified time.  basis can be a Vector or Tuple of basis states, or it can be a Matrix like Z or X.","category":"page"},{"location":"register_interface/#project_traceout!(f,-r::RegRef,-basis;-time)","page":"Register Interface","title":"project_traceout!(f, r::RegRef, basis; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Project the state in RegRef on basis at a specified time and apply function f on the projected basis state. basis can be a Vector or Tuple of basis states, or it can be a Matrix like Z or X.","category":"page"},{"location":"register_interface/#project_traceout!(f,-reg::Register,-i::Int,-basis;-time)","page":"Register Interface","title":"project_traceout!(f, reg::Register, i::Int, basis; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Project the state in the slot in index i of Register on basis at a specified time and apply function f on the projected basis state. basis can be a Vector or Tuple of basis states, or it can be a Matrix like Z or X. Lowers the representation from registers to states.","category":"page"},{"location":"register_interface/#project_traceout!(state,-stateindex,-basis::Symbolic{AbstractOperator})-and-basis::AbstractVecOrTuple{:Symbolic{AbstractKet}}","page":"Register Interface","title":"project_traceout!(state, stateindex, basis::Symbolic{AbstractOperator}) and basis::AbstractVecOrTuple{<:Symbolic{AbstractKet}}","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Backend implementations. If basis is an operator, call eigvecs to convert it into a matrix whose columns are the eigenvectors of the operator. If basis is a Vector or Tuple of Symbolic basis states, call express to convert it to the necessary representation.","category":"page"},{"location":"register_interface/#Interface-Overview-4","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"flowchart TB\n  A[\"<code>project_traceout!(r::RegRef, basis; time)</code>\"]\n  B[\"<code>project_traceout!(reg::Register, i::Int, basis; time)</code>\"]\n  subgraph TOP [lower from registers to states]\n    direction LR\n    D1[\"<code>reg.staterefs[i].state[]</code>\"]\n    D2[\"<code>reg.stateindices[i]</code>\"]\n  end\n  E1[\"<code>basis::Symbolic{AbstractOperator}</code>\"]\n  F1[\"<code>eigvecs(basis)</code>\"]\n  E2[\"<code>basis::Base.AbstractVecOrTuple{<:Symbolic{AbstractKet}}</code>\"]\n  F2[\"<code>express.(basis)</code>\"]\n  G([Dispatch on state to low level implementation<br>in an independent library])\n  A --> B --> TOP\n  TOP --> E1 --> F1 --> G\n  TOP --> E2 --> F2 --> G","category":"page"},{"location":"register_interface/#traceout!","page":"Register Interface","title":"traceout!","text":"","category":"section"},{"location":"register_interface/#QuantumInterface.traceout!-register_interface","page":"Register Interface","title":"QuantumInterface.traceout!","text":"Delete the given slot of the given register.\n\ntraceout!(reg, slot) would reset (perform a partial trace) over the given subsystem. The Hilbert space of the register gets automatically shrunk.\n\n\n\n\n\n","category":"function"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Perform a partial trace over a part of the system (i.e. discard a part of the system).","category":"page"},{"location":"register_interface/#traceout!(r::RegRef)","page":"Register Interface","title":"traceout!(r::RegRef)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Partial trace over a particular register reference.","category":"page"},{"location":"register_interface/#traceout!(r::Register,-i::Int)","page":"Register Interface","title":"traceout!(r::Register, i::Int)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Partial trace over slot i of register r. Calls down to the state reference stored in that particular register.","category":"page"},{"location":"register_interface/#traceout!(s::StateRef,-i::Int)","page":"Register Interface","title":"traceout!(s::StateRef, i::Int)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Partial trace over subsystem i of state referenced by s.","category":"page"},{"location":"register_interface/#Interface-Overview-5","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"flowchart TB\n  A[\"<code>traceout!(r::RegRef)</code>\"]\n  B[\"<code>traceout!(r::Register, i::Int)</code>\"]\n  C[\"<code>traceout!(r::StateRef, i::Int)</code>\"]\n  D([Dispatch on state to low level implementation<br>in an independent library])\n  A --> B --> C --> D","category":"page"},{"location":"register_interface/#uptotime!","page":"Register Interface","title":"uptotime!","text":"","category":"section"},{"location":"register_interface/#QuantumSavory.uptotime!-register_interface","page":"Register Interface","title":"QuantumSavory.uptotime!","text":"Evolve all the states in a register to a given time, according to the various backgrounds that they might have.\n\njulia> reg = Register(2, T1Decay(1.0))\nRegister with 2 slots: [ Qubit | Qubit ]\n  Slots:\n    nothing\n    nothing\n\njulia> initialize!(reg[1], X₁)\n       observable(reg[1], σᶻ)\n0.0 + 0.0im\n\njulia> uptotime!(reg[1], 10)\n       observable(reg[1], Z)\n0.9999546000702374 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"register_interface/#uptotime!(ref::RegRef,-now)","page":"Register Interface","title":"uptotime!(ref::RegRef, now)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Evolve the state in a RegRef upto a given time now","category":"page"},{"location":"register_interface/#uptotime!(refs::Base.AbstractVecOrTuple{RegRef},-now)","page":"Register Interface","title":"uptotime!(refs::Base.AbstractVecOrTuple{RegRef}, now)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Evolve the state represented by the given RegRefs upto a time now","category":"page"},{"location":"register_interface/#uptotime!(registers,-indices::Base.AbstractVecOrTuple{Int},-now)","page":"Register Interface","title":"uptotime!(registers, indices::Base.AbstractVecOrTuple{Int}, now)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Evolve the state of all the given registers at the slots represented by indices upto a time now","category":"page"},{"location":"register_interface/#uptotime!(stateref::StateRef,-idx::Int,-background,-Δt)","page":"Register Interface","title":"uptotime!(stateref::StateRef, idx::Int, background, Δt)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Evolve a StateRef at index idx with given background and Δt","category":"page"},{"location":"register_interface/#uptotime!(state,-indices::Base.AbstractVecOrTuple{Int},-backgrounds,-Δt)","page":"Register Interface","title":"uptotime!(state, indices::Base.AbstractVecOrTuple{Int}, backgrounds, Δt)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Evolve state at indices given backgrounds and Δt","category":"page"},{"location":"register_interface/#uptotime!(state::QuantumClifford.MixedDestabilizer,-idx::Int,-background,-Δt)","page":"Register Interface","title":"uptotime!(state::QuantumClifford.MixedDestabilizer, idx::Int, background, Δt)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Low level implementation to compute the result of uptotime! for states using Clifford representation","category":"page"},{"location":"register_interface/#uptotime!(state::StateVector,-idx::Int,-background,-Δt)","page":"Register Interface","title":"uptotime!(state::StateVector, idx::Int, background, Δt)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Low level implementation to compute the result of uptotime! for states using Ket representation. The state in ket representation is converted to a density matrix before calling the uptotime! for final computation.","category":"page"},{"location":"register_interface/#uptotime!(state::Operator,-idx::Int,-background,-Δt)","page":"Register Interface","title":"uptotime!(state::Operator, idx::Int, background, Δt)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Low level implementation to compute the result of uptotime! for Operator","category":"page"},{"location":"register_interface/#Interface-Overview-6","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"flowchart TB\n  A[\"<code>uptotime!(ref::RegRef, now)</code>\"]\n  B[\"<code>uptotime!(refs::Base.AbstractVecOrTuple{RegRef}, now)</code>\"]\n  C[\"<code>uptotime!(registers, indices::Base.AbstractVecOrTuple{Int}, now)</code>\"]\n  C1[\"lower from registers to states\"]\n  D[\"<code>uptotime!(stateref::StateRef, idx::Int, background, Δt)</code>\"]\n  E[\"<code>uptotime!(state, indices::Base.AbstractVecOrTuple{Int}, backgrounds, Δt)</code>\"]\n  A --> C\n  B --> C\n  C --> C1\n  C1 --> E\n  D --> E\n  F([Dispatch on state to low level implementation<br>in an independent library])\n  E --> F","category":"page"},{"location":"register_interface/#swap!","page":"Register Interface","title":"swap!","text":"","category":"section"},{"location":"register_interface/#swap!(r1::RegRef,-r2::RegRef)","page":"Register Interface","title":"swap!(r1::RegRef, r2::RegRef)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Swap the state of the given RegRefs","category":"page"},{"location":"register_interface/#swap!(reg1::Register,-reg2::Register,-i1::Int,-i2::Int)","page":"Register Interface","title":"swap!(reg1::Register, reg2::Register, i1::Int, i2::Int)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Swap the state stored in the two Registers at slots i1 and i2 respectively","category":"page"},{"location":"register_interface/#Interface-Overview-7","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"flowchart TB\n  A[\"<code>swap!(r1::RegRef, r2::RegRef)</code>\"]\n  B[\"<code>swap!(reg1::Register, reg2::Register, i1::Int, i2::Int)</code>\"]\n  A --> B","category":"page"},{"location":"register_interface/#overwritetime!","page":"Register Interface","title":"overwritetime!","text":"","category":"section"},{"location":"register_interface/#overwritetime!(refs::Base.AbstractVecOrTuple{RegRef},-now)","page":"Register Interface","title":"overwritetime!(refs::Base.AbstractVecOrTuple{RegRef}, now)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Overwrite the time of the simulation for the given references to now","category":"page"},{"location":"register_interface/#overwritetime!(registers,-indices,-now)","page":"Register Interface","title":"overwritetime!(registers, indices, now)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Overwrite the time of the simulation for the given registers at indices to now","category":"page"},{"location":"register_interface/#Interface-Overview-8","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"flowchart TB\n  A[\"<code>overwritetime!(refs::Base.AbstractVecOrTuple{RegRef}, now)</code>\"]\n  B[\"<code>overwritetime!(registers, indices, now)</code>\"]\n  A --> B","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/#Clifford-Simulations-of-First-Generation-Quantum-Repeater","page":"1st-gen Repeater - Clifford formalism","title":"Clifford Simulations of First Generation Quantum Repeater","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"Here we will simulate a quantum repeater by employing a noisy Clifford circuit simulator.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"Be sure to check out the more detailed tutorial on wavefunction simulations of First Generation Quantum Repeater before proceeding with this one.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"The changes we need to perform to the code are incredibly small. We only change the way the initial states of the entangled pairs are set, without changing any of the code implementing the swapping and purification steps.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"For the wavefunction simulator we had used:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"const perfect_pair = (Z1⊗Z1 + Z2⊗Z2) / sqrt(2)\nconst perfect_pair_dm = SProjector(perfect_pair)\nconst mixed_dm = MixedState(perfect_pair_dm)\nnoisy_pair_func(F) = F*perfect_pair_dm + (1-F)*mixed_dm","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"Here we switch to tableau representation for our initial states. Converting from tableaux to kets or density matrices is cheap and automated, but the reverse direction is difficult, thus we give the initial state explicitly. You can actually use the tableau definition below for all types of simulations (tableau, ket, others).","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"# a tableau corresponding to a Bell pair\nconst tableau = S\"XX\n                  ZZ\"\nconst stab_perfect_pair = StabilizerState(tableau)\nconst stab_perfect_pair_dm = SProjector(stab_perfect_pair)\nstab_noisy_pair_func(F) = F*stab_perfect_pair_dm + (1-F)*mixed_dm","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"We then use that in the entangler setup (the same way we used a similar function when we were doing wavefunction simulations), simply by selecting the appropriate default representation type (CliffordRepr instead of QuantumOpticsRepr):","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"# excerpt from `firstgenrepeater-firstgenrepeater-clifford.jl`\nsim, network = simulation_setup(sizes, T2; representation = CliffordRepr)\nnoisy_pair = stab_noisy_pair_func(F)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"The symbolic-expression-to-density-matrix conversion is cached inside of the symbolic expression noisy_pair, so that it does not need to be recomputed each time. In particular, given that this arbitrary mixed state can not be represented as a tableau, rather as a probability distribution over different tableaux, the cache provides for efficient random sampling.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"note: You can use tableaux states in the Schroedinger simulations.\nConverting from tableaux to kets or density matrices is cheap and automated, so we could have just as well used stab_noisy_pair_func even with the Schroedinger simulations of QuantumOpticsRepr.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/#Simulation-Trace","page":"1st-gen Repeater - Clifford formalism","title":"Simulation Trace","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"Similarly to the wavefunction simulations from the previous tutorial, here we can see how the various observables evolve over time for a Clifford-base simulation. Notice that unlike the wavefunction simulation, the results are very discrete, and we will certainly need to average over multiple repeated simulations of this trajectory.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"<video src=\"../firstgenrepeater-08.clifford.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/#Comparison-Against-a-Wavefunction-based-Simulations","page":"1st-gen Repeater - Clifford formalism","title":"Comparison Against a Wavefunction-based Simulations","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"We can run the either simulation multiple times in order to compare the results from the wavefunction and tableau-based simulations:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"(Image: Comparison Against a Wavefunction-based Simulations)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"The source code is in the examples/firstgenrepeater folder.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater - Clifford formalism","title":"1st-gen Repeater - Clifford formalism","text":"","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#First-Generation-Quantum-Repeater","page":"1st-gen Repeater - low level implementation","title":"First Generation Quantum Repeater","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"There is a convenient classification of quantum repeaters by their logical capabilities[1]. The first, simplest, generation of quantum repeaters involves the generation of physical (unencoded) entangled qubits between neighboring nodes, followed by entanglement swap and entanglement purification operation. No error correcting codes are employed and establishing of a link is a probabilistic process.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"[1]: (Muralidharan et al., 2016)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"We will build a simplistic simulator for such a network.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"We will employ Schroedinger representation (Schroedinger, Lindblad, and other master equation will be used behind the scenes, but we will not need to work at that low level);\nWe will consider a chain of quantum repeater nodes of various sizes (number of qubits);\nThe goal would be to entangle the extreme ends of the chain:\nBy directly entangling nearest neighbors;\nFollowed by entanglement swaps to extend the links;\nAnd entanglement purification to increase the quality of the links.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"For organizing the simulation and simplifying the digital and analog quantum dynamics, we will use the star of QuantumSavory.jl, namely the Register data structure. For a convenient data structure to track per-node metadata in a graph (network) we will use the RegisterNet structure.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Moreover, behind the scenes QuantumSavory.jl will use:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"ConcurrentSim.jl for discrete event scheduling and simulation;\nMakie.jl together with our custom plotting recipes for visualizations;\nQuantumOptics.jl for low-level quantum states.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The user does not need to know much about these libraries, but if they wish, it is easy for them to peek behind the scenes and customize their use.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The full simulation script is available at the bottom.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"info: Low Level Implementation\nThis is a very low-level implementation. You would be better of using already implemented reusable protocols like EntanglerProt like done in the second version of this example firstgenrepeater_v2. On the other hand, the setup here is a simple way to learn about making discrete event simulations without depending on a lot of extra library functionality and opaque black boxes.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#The-Underlying-Data-Structures","page":"1st-gen Repeater - low level implementation","title":"The Underlying Data Structures","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"While the quantum dynamics would be encapsulated in a Register data structure, it is convenient to also set up structures that track the overall topology and events on the network. Our preferred way to do that is to use the RegisterNet structure, which lets you construct a graph and attach arbitrary meta-data to each edge and vertex. While this is not required for using QuantumSavory.jl, it is convenient, and we provide a lot of debugging tools that assume the use of this structure.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Given an array of register sizes, e.g. sizes = [2,3,4,3,2], we will create a linear graph, where each node has the prescribed number of qubits, e.g.:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"(Image: An image of 5 quantum registers)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The RegisterNet would contain, on each node:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"a Register of the appropriate size;\nan array of tuples keeping track of whom each qubit in the register is entangled to (as the :enttracker property);\nan array of locks (from ConcurrentSim.jl) keeping track of whether a process is happening on the given qubit (as the :locks property).","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"note: Note\nTo see how to visualize these data structures as the simulation is proceeding, consult the Visualizations page.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"note: Note\nTo see how to define imperfections, noise processes, and background events, consult the Sub-system Background Noise page.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"<details><summary>Click to expand and see code used to set up the meta-graph and registers</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"\"\"\"Creates the datastructures representing the simulated network\"\"\"\nfunction simulation_setup(\n    sizes, # Array giving the number of qubits in each node\n    T2 # T2 dephasing times for the qubits\n    ;\n    representation = QuantumOpticsRepr # Representation to use for the qubits\n    )\n    R = length(sizes) # Number of registers\n\n    # A scheduler datastructure for the discrete event simulation\n    sim = Simulation()\n\n    # All of the quantum register we will be simulating\n    registers = Register[]\n    for s in sizes\n        traits = [Qubit() for _ in 1:s]\n        repr = [representation() for _ in 1:s]\n        bg = [T2Dephasing(T2) for _ in 1:s]\n        push!(registers, Register(traits,repr,bg))\n    end\n\n    # A graph structure defining the connectivity among registers\n    # It is not necessary to use such a structure, however, it is a convenient way to\n    # store data about the simulation (and we have created helper plotting functions\n    # expecting such a structure).\n    graph = grid([R])\n    network = RegisterNet(graph, registers) # A graphs with extra \"meta data\"\n\n    # Add a register datastructures and event locks to each node.\n    for v in vertices(network)\n        # Create an array specifying whether a qubit is entangled with another qubit\n        network[v,:enttrackers] = Any[nothing for i in 1:sizes[v]]\n        # Create an array of locks, telling us whether a qubit is undergoing an operation\n        network[v,:locks] = [Resource(sim,1) for i in 1:sizes[v]]\n    end\n\n    sim, network\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Entangler","page":"1st-gen Repeater - low level implementation","title":"Entangler","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The first set of processes we need is the \"entanglers\" that enable nearest-neighbor entanglement generation:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"<video src=\"../firstgenrepeater-02.entangler.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"They run in parallel on each edge of the graph, set up by an invocation similar to the following:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"for (;src, dst) in edges(network)\n    @process entangler(sim, network, src, dst, ...)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"As seen in the following flow chart, the entangler repeatedly checks for available pairs of unused qubit slots and attempts to entangle them.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"graph LR\n    A[Entangler starts<br>on node A and B]\n    B{Are there<br>unused qubits on<br>node A and B?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>available qubits])\n    D --> E[Run entanglement<br>generation]\n    E --> F[Write down<br>who was entangled]\n    F --> G([Unlock the<br>qubits])\n    G --> B","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"<details><summary>Click to see the implementation of the Entangler process</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"@resumable function entangler(\n    sim::Environment,   # The scheduler for all simulation events\n    network,            # The graph of quantum nodes\n    nodea, nodeb,       # The two nodes which we will be entangling\n    noisy_pair,         # A raw entangled pair\n    entangler_wait_time,# The wait time in case all qubits are \"busy\"\n    entangler_busy_time # How long it takes to establish entanglement\n    )\n    while true\n        ia = findfreequbit(network, nodea)\n        ib = findfreequbit(network, nodeb)\n        if isnothing(ia) || isnothing(ib)\n            @yield timeout(sim, entangler_wait_time)\n            continue\n        end\n        locka = network[nodea,:locks][ia]\n        lockb = network[nodeb,:locks][ib]\n        @yield request(locka) & request(lockb)\n        registera = network[nodea]\n        registerb = network[nodeb]\n        @yield timeout(sim, entangler_busy_time)\n        initialize!((registera[ia],registerb[ib]),noisy_pair; time=now(sim))\n        network[nodea,:enttrackers][ia] = (node=nodeb,slot=ib)\n        network[nodeb,:enttrackers][ib] = (node=nodea,slot=ia)\n        @simlog sim \"entangled node $(nodea):$(ia) and node $(nodeb):$(ib)\"\n        release(locka)\n        release(lockb)\n    end\nend\n\n\"\"\"Find an uninitialized unlocked qubit on a given node\"\"\"\nfunction findfreequbit(network, node)\n    register = network[node]\n    locks = network[node,:locks]\n    regsize = nsubsystems(register)\n    findfirst(i->!isassigned(register,i) & isfree(locks[i]), 1:regsize)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Notice that the entangler uses the initialize! function to set the state of certain registers, but we never need to explicitly construct the numerical representation of these kets. Rather, we use the symbolic algebra system of QuantumSymbolics.jl, and let the simulator automatically convert the symbolic expression into numerical density matrices. This conversion was governed by the choice of representation = QuantumOpticsRepr. Here is one possible symbolic definition of a noisy_pair:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"const perfect_pair = (Z1⊗Z1 + Z2⊗Z2) / sqrt(2)\nconst perfect_pair_dm = SProjector(perfect_pair)\nconst mixed_dm = MixedState(perfect_pair_dm)\nnoisy_pair_func(F) = F*perfect_pair_dm + (1-F)*mixed_dm","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The symbolic-expression-to-density-matrix conversion is cached inside of the symbolic expression, so that it does not need to be recomputed each time.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Swapper","page":"1st-gen Repeater - low level implementation","title":"Swapper","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Once we have the raw nearest-neighbor entanglement, we can proceed with swap operations that link two Bell pairs that share one common node into a longer Bell pair:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"<video src=\"../firstgenrepeater-03.swapper.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"They run in parallel on each vertex of the graph, set up by an invocation similar to the following:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"for node in vertices(network)\n    @process swapper(sim, network, node, ...)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The Swapper working on a given node simply checks whether there are any qubits on that node that are entangled with other nodes, both on the left and right of the current node. If such qubits are found, the entanglement swap operation is performed on them, as seen in this flowchart.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"graph LR\n    A[Swapper starts<br>on node A]\n    B{Are there<br>qubits entangled with A<br>both on the left and right<br>of A?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>local qubits])\n    D --> E[Run entanglement<br>swapping]\n    E --> F[Write down<br>how the entanglement<br>was redistributed]\n    F --> G([Unlock and erase<br>the local qubits])\n    G --> B","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The entanglement swap operation is performed through the following simple circuit, which entangles the two local qubits belonging to two separate Bell pairs, and then measures them:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"<img alt=\"Entanglement swapping circuit\" src=\"../firstgenrepeater-04.swapcircuit.png\" style=\"max-width:50%\">\n<!--\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CNOT(2, 3),\n Measurement(\"X\", 2, 1),\n ClassicalDecision(\"Z\", 1, 1),\n Measurement(\"Z\", 3, 2),\n ClassicalDecision(\"X\", 4, 2)]\n -->","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The code implementing such a circuit looks like the following (where localslot denotes register slots on which swapping happens, and remslot denotes remote registers on the left and right):","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"apply!((localslot1, localslot2), CNOT; time=time)\nxmeas = project_traceout!(localslot1, X)\nzmeas = project_traceout!(localslot2, Z)\nif xmeas==2\n    apply!(remslot1, Z)\nend\nif zmeas==2\n    apply!(remslot2, X)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"<details><summary>Click to see the implementation of the Swapper process</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"@resumable function swapper(\n    sim::Environment, # The scheduler for all simulation events\n    network,          # The graph of quantum nodes\n    node,             # The node on which the swapper works\n    swapper_wait_time,# The wait time in case there are no available qubits for swapping\n    swapper_busy_time # How long it takes to perform the swap\n    )\n    while true\n        qubit_pair = findswapablequbits(network,node)\n        if isnothing(qubit_pair)\n            @yield timeout(sim, swapper_wait_time)\n            continue\n        end\n        q1, q2 = qubit_pair\n        locks = network[node, :locks][[q1,q2]]\n        @yield mapreduce(request, &, locks)\n        reg = network[node]\n        @yield timeout(sim, swapper_busy_time)\n        node1 = network[node,:enttrackers][q1]\n        reg1 = network[node1.node]\n        node2 = network[node,:enttrackers][q2]\n        reg2 = network[node2.node]\n        swapcircuit(reg[q1], reg[q2], reg1[node1.slot], reg2[node2.slot]; time=now(sim))\n        network[node1.node,:enttrackers][node1.slot] = node2\n        network[node2.node,:enttrackers][node2.slot] = node1\n        network[node,:enttrackers][q1] = nothing\n        network[node,:enttrackers][q2] = nothing\n        @simlog sim \"swap at $(node):$(q1)&$(q2) connecting $(node1) and $(node2)\"\n        release.(locks)\n    end\nend\n\nfunction swapcircuit(localslot1, localslot2, remslot1, remslot2; time=nothing)\n    apply!((localslot1, localslot2), CNOT; time=time)\n    xmeas = project_traceout!(localslot1, X)\n    zmeas = project_traceout!(localslot2, Z)\n    if xmeas==2\n        apply!(remslot1, Z)\n    end\n    if zmeas==2\n        apply!(remslot2, X)\n    end\nend\n\nfunction findswapablequbits(network,node)\n    enttrackers = network[node,:enttrackers]\n    locks = network[node,:locks]\n    left_nodes  = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node<node && isfree(locks[i])]\n    isempty(left_nodes)  && return nothing\n    right_nodes = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node>node && isfree(locks[i])]\n    isempty(right_nodes) && return nothing\n    _, farthest_left  = findmin(n->n.node, left_nodes)\n    _, farthest_right = findmax(n->n.node, right_nodes)\n    return left_nodes[farthest_left].i, right_nodes[farthest_right].i\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Purifier","page":"1st-gen Repeater - low level implementation","title":"Purifier","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Last but not least, there is the Purifier that searches for pairs of nodes that share more than one Bell pair. On such nodes a purification procedure can be performed:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"<video src=\"../firstgenrepeater-05.purifier.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"As you can see, not all purification attempts succeed. On some occasions there is a failure and both pairs get discarded as faulty. Each Purifier is running two purification circuits, one after the other, as a single round of purification is incapable of detecting all types of errors. The two circuits being employed are the following:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"<img alt=\"Entanglement purification circuit\" src=\"../firstgenrepeater-06.purcircuit1.png\" style=\"max-width:40%\">\n<img alt=\"Entanglement purification circuit\" src=\"../firstgenrepeater-06.purcircuit2.png\" style=\"max-width:40%\">\n<!--\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CNOT(1, 3),\n CNOT(2, 4),\n Measurement(\"X\", 1),\n Measurement(\"X\", 2)]\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CPHASE(1, 3),\n CPHASE(2, 4),\n Measurement(\"X\", 1),\n Measurement(\"X\", 2)]\n-->","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"If the coincidence measurements fail, all qubits are reset. If the coincidence measurements are correct, the purified pair would have higher fidelity than what it started with. To implement one of these circuits one can write something akin to the following, where regA and regB are the two registers who share two entangled pairs, and pairXqubitX specifies the slot for each of the qubits of each of the pairs:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"gate = Gates.CNOT # or Gates.CPHASE\napply!((rega[pair2qa],rega[pair1qa]),gate)\napply!((regb[pair2qb],regb[pair1qb]),gate)\nmeasa = project_traceout!(rega[pair2qa], X)\nmeasb = project_traceout!(regb[pair2qb], X)\nif measa!=measb\n    traceout!(rega[pair1qa])\n    traceout!(regb[pair1qb])\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The overall structure of this process is similar to the Entangler and Swapper: repeatedly trying to lock four qubits belonging to two pairs shared by the same nodes, followed by performing the purification procedure.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"graph LR\n    A[Purifier starts<br>on nodes A and B]\n    B{Are there<br>two Bell pairs shared<br>between A and B?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>corresponding qubits])\n    D --> E[Run purification<br>and parity measurement]\n    E --> F{Coincidence<br>was observed?}\n    F --No--> F1[Reset<br>all qubits]\n    F --Yes--> F2[Preserve<br>purified qubits]\n    F1 --> G([Unlock<br>the qubits])\n    F2 --> G([Unlock<br>the qubits])\n    G --> B","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Purification processes are started on all pairs of nodes with an invocation like:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"for nodea in vertices(network)\n    for nodeb in vertices(network)\n        if nodeb>nodea\n            @process purifier(sim, network, nodea, nodeb, ...)\n        end\n    end\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"<details><summary>Click to see the implementation of the Entangler process</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"@resumable function purifier(\n    sim::Environment,  # The scheduler for all simulation events\n    network,           # The graph of quantum nodes\n    nodea,             # One of the nodes on which the pairs to be purified rest\n    nodeb,             # The other such node\n    purifier_wait_time,# The wait time in case there are no pairs available for purification\n    purifier_busy_time # The duration of the purification circuit\n    )\n    round = 0\n    while true\n        pairs_of_bellpairs = findqubitstopurify(network,nodea,nodeb)\n        if isnothing(pairs_of_bellpairs)\n            @yield timeout(sim, purifier_wait_time)\n            continue\n        end\n        pair1qa, pair1qb, pair2qa, pair2qb = pairs_of_bellpairs\n        locks = [network[nodea,:locks][[pair1qa,pair2qa]];\n                 network[nodeb,:locks][[pair1qb,pair2qb]]]\n        @yield mapreduce(request, &, locks)\n        @yield timeout(sim, purifier_busy_time)\n        rega = network[nodea]\n        regb = network[nodeb]\n        gate = (CNOT, CPHASE)[round%2+1]\n        apply!((rega[pair2qa],rega[pair1qa]),gate)\n        apply!((regb[pair2qb],regb[pair1qb]),gate)\n        measa = project_traceout!(rega[pair2qa], X)\n        measb = project_traceout!(regb[pair2qb], X)\n        if measa!=measb\n            traceout!(rega[pair1qa])\n            traceout!(regb[pair1qb])\n            network[nodea,:enttrackers][pair1qa] = nothing\n            network[nodeb,:enttrackers][pair1qb] = nothing\n            @simlog sim \"failed purification at $(nodea):$(pair1qa)&$(pair2qa) and $(nodeb):$(pair1qb)&$(pair2qb)\"\n        else\n            round += 1\n            @simlog sim \"purification at $(nodea):$(pair1qa) $(nodeb):$(pair1qb) by sacrifice of $(nodea):$(pair1qa) $(nodeb):$(pair1qb)\"\n        end\n        network[nodea,:enttrackers][pair2qa] = nothing\n        network[nodeb,:enttrackers][pair2qb] = nothing\n        release.(locks)\n    end\nend\n\nfunction findqubitstopurify(network,nodea,nodeb)\n    enttrackers = network[nodea,:enttrackers]\n    locksa = network[nodea,:locks]\n    locksb = network[nodeb,:locks]\n    enttrackers = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node==nodeb && isfree(locksa[i]) && isfree(locksb[n.slot])]\n    if length(enttrackers)>=2\n        aqubits = [n.i for n in enttrackers[end-1:end]]\n        bqubits = [n.slot for n in enttrackers[end-1:end]]\n        return aqubits[2], bqubits[2], aqubits[1], bqubits[1]\n    else\n        return nothing\n    end\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Running-the-simulations","page":"1st-gen Repeater - low level implementation","title":"Running the simulations","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Now that we have defined the Entangler, Swapper, and Purifier processes, we just need to run the simulation. That is no different from running any other ConcurrentSim.jl simulation, after our custom setup:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"sizes = [2,3,4,3,2]        # Number of qubits in each register\nT2 = 100.0                 # T2 dephasing time of all qubits\nF = 0.97                   # Fidelity of the raw Bell pairs\nentangler_wait_time = 0.1  # How long to wait if all qubits are busy before retring entangling\nentangler_busy_time = 1.0  # How long it takes to establish a newly entangled pair\nswapper_wait_time = 0.1    # How long to wait if all qubits are unavailable for swapping\nswapper_busy_time = 0.15   # How long it takes to swap two qubits\npurifier_wait_time = 0.15  # How long to wait if there are no pairs to be purified\npurifier_busy_time = 0.2   # How long the purification circuit takes to execute\n\nsim, network = simulation_setup(sizes, T2; representation = CliffordRepr)\n\nnoisy_pair = stab_noisy_pair_func(F)\nfor (;src, dst) in edges(network)\n    @process entangler(sim, network, src, dst, noisy_pair, entangler_wait_time, entangler_busy_time)\nend\nfor node in vertices(network)\n    @process swapper(sim, network, node, swapper_wait_time, swapper_busy_time)\nend\nfor nodea in vertices(network)\n    for nodeb in vertices(network)\n        if nodeb>nodea\n            @process purifier(sim, network, nodea, nodeb, purifier_wait_time, purifier_busy_time)\n        end\n    end\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Then to run the simulation up to time t we just write run(sim, t). If we want to run until the next event, whenever that is, we can do ConcurrentSim.step(sim)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Figures-of-Merit-and-Visualizations","page":"1st-gen Repeater - low level implementation","title":"Figures of Merit and Visualizations","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"These simulations are not particularly useful if we do not track the performance of the quantum network. One convenient way to do that is to compute observables related to the quality of entanglement, e.g., the XX and ZZ correlators. We will compute these correlators for the second pair on the extreme ends of the chain of repeaters:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"<video src=\"../firstgenrepeater-07.observable.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Notice how the XX observable drops due to the T₂ dephasing experienced by the qubits. And then it goes back up at the occurrence of a successful purification (or all the way to zero at failed purifications). Here is what it looks like if we do not perform purification:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"<video src=\"../firstgenrepeater-07.observable.nopur.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The plotting itself is realized with the wonderful Makie.jl plotting library. The figure of merrit is obtained through a call to observable, a convenient method for calculating expectation values of various quantum observables.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Summary-of-QuantumSavory-tools-employed-in-the-simulation","page":"1st-gen Repeater - low level implementation","title":"Summary of QuantumSavory tools employed in the simulation","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"We used the Register data structure to automatically track the quantum states describing our mixed analog-digital quantum dynamics.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Much of the analog dynamics was implicit through the use of backgrounds, declaring the noise properties of various qubits.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The digital-ish dynamics was implemented through the use of","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"initialize! for setting initial states to various qubits\napply! for the application of various gates\ntraceout! for deleting qubits\nproject_traceout! for projective measurements over qubits\nobservable for calculating expectation values of quantum observables","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Many of the above functions take the time keyword argument, which ensures that various background analog processes are simulated before the given operation is performed.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"Of note is that we also used Makie.jl for plotting, ConcurrentSim.jl for discrete event scheduling, QuantumClifford.jl for efficient simulation of Clifford circuits, and QuantumOptics.jl for convenient master equation integration. Many of these tools were used under the hood without being invoked directly.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Suggested-Improvements","page":"1st-gen Repeater - low level implementation","title":"Suggested Improvements","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The first and most obvious improvement would be to trigger the various events (Entangler, Swapper, Purifier) from each other, instead of having them all randomly wait and hope the necessary resources are available.\nCalibrating when to perform a purification versus a swap would be important for the performance of the network.\nBalancing what types of entanglement purification is performed, depending on the type of noise experienced, can drastically lower resource requirements.\nImplementing more sophisticated purification schemes can greatly improve the quality of entanglement.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"The source code is in the examples/firstgenrepeater folder.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater - low level implementation","title":"1st-gen Repeater - low level implementation","text":"","category":"page"},{"location":"properties/#Properties","page":"Properties","title":"Properties","text":"","category":"section"},{"location":"properties/","page":"Properties","title":"Properties","text":"When creating a new registers, you can specify what type of physical system it will contain in each slot, e.g. a Qubit or a qudit or a harmonic oscillator or a propagating wave packet.","category":"page"},{"location":"properties/","page":"Properties","title":"Properties","text":"","category":"page"},{"location":"API_CircuitZoo/#Predefined-Quantum-Circuits","page":"CircuitZoo API","title":"Predefined Quantum Circuits","text":"","category":"section"},{"location":"API_CircuitZoo/","page":"CircuitZoo API","title":"CircuitZoo API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API_CircuitZoo/","page":"CircuitZoo API","title":"CircuitZoo API","text":"The submodule QuantumSavory.CircuitZoo provides reusable common quantum circuits.","category":"page"},{"location":"API_CircuitZoo/#Autogenerated-API-list-for-QuantumSavory.CircuitZoo","page":"CircuitZoo API","title":"Autogenerated API list for QuantumSavory.CircuitZoo","text":"","category":"section"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.Purify2to1","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.Purify2to1","text":"struct Purify2to1 <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nleaveout: A symbol specifying which of the three Pauli errors to leave undetectable.\n\nA simple purification circuit sacrificing a Bell pair to produce another. The circuit is parameterized by a single leaveout symbol argument which specifies which of the three possible Pauli errors are to be left undetected. A simple purificaiton circuit is not capable of detecting all errors.\n\nIf an error was detected, the circuit returns false and the state is reset. If no error was detected, the circuit returns true.\n\nThe sacrificial qubits are removed from the register.\n\njulia> a = Register(2)\n       b = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!((a[1], b[1]), bell)\n       initialize!((a[2], b[2]), bell);\n\njulia> Purify2to1(:X)(a[1], b[1], a[2], b[2])\ntrue\n\njulia> observable((a[1], b[1]), projector(bell))\n1.0 + 0.0im\n\nHowever, an error might have occurred on the initial state. If the error is detectable, the Purify2to1 circuit will return false and the state will be reset.\n\njulia> a = Register(2)\n       b = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!((a[1], b[1]), bell)\n       initialize!((a[2], b[2]), bell)\n       apply!(a[1], Z);\n\njulia> Purify2to1(:X)(a[1], b[1], a[2], b[2])\nfalse\n\njulia> a\nRegister with 2 slots: [ Qubit | Qubit ]\n  Slots:\n    nothing\n    nothing\n\nIn some cases the error might not be detectable. In that case, the Purify2to1 circuit does return true, but as you can see below, the state is not what we would expect from a successful purification.\n\njulia> a = Register(2)\n       b = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!((a[1], b[1]), bell)\n       initialize!((a[2], b[2]), bell)\n       apply!(a[1], X);\n\njulia> Purify2to1(:X)(a[1], b[1], a[2], b[2])\ntrue\n\njulia> observable((a[1], b[1]), projector(bell))\n0.0 + 0.0im\n\nSee also: Purify2to1Node, Purify3to1, PurifyExpedient, PurifyStringent\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.Purify2to1Node","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.Purify2to1Node","text":"struct Purify2to1Node <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nleaveout: A symbol specifying which of the three Pauli errors to leave undetectable.\n\nA purification circuit sacrificing 2 Bell qubits to produce another qubit. The circuit is parameterized by a single leaveout symbol argument which specifies which of the three possible Pauli errors are to be left undetected. A simple purificaiton circuit is not capable of detecting all errors.\n\nThis is only \"half\" of the full purification circuit - the local gates to be applied at a network node. For a complete purification circuit, you need to apply this circuit to the remote node as well. Alternatively, you can use the complete Purifiy2to1](@ref) circuit.\n\nThis circuit returns the measurements result (as an integer index among the possible basis states).\n\njulia> a = Register(2)\n       b = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!((a[1], b[1]), bell)\n       initialize!((a[2], b[2]), bell);\n\njulia> Purify2to1Node(:X)(a[1:2]...) == Purify2to1Node(:X)(b[1:2]...)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.Purify3to1","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.Purify3to1","text":"struct Purify3to1 <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nleaveout1: The error to be fixed twice\nleaveout2\n\nA purification circuit sacrificing a Bell pair to produce another. The circuit is parameterized by a leaveout1, and a leaveout2 symbol argument which specifies the leaveout of each of the two purification subcircuits This purificaiton circuit is capable of detecting all errors.\n\nIf an error was detected, the circuit returns false and the state is reset. If no error was detected, the circuit returns true.\n\nThe sacrificial qubits are removed from the register.\n\njulia> a = Register(2)\n       b = Register(2)\n       c = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!(a[1:2], bell)\n       initialize!(b[1:2], bell)\n       initialize!(c[1:2], bell);\n\n\njulia> Purify3to1(:Z, :Y)(a[1], a[2], b[1], c[1], b[2], c[2])\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.Purify3to1Node","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.Purify3to1Node","text":"struct Purify3to1Node <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nleaveout1: The error to be fixed twice\nleaveout2\n\nA purification circuit sacrificing 2 Bell qubits to produce another. The circuit is parameterized by a leaveout1, and a leaveout2 symbol argument which specifies the leaveout of each of the two purification subcircuits This purificaiton circuit is capable of detecting all errors.\n\nThis circuit returns the array of measurements made.\n\nThis circuit is the same as the Purifiy3to1 one but it works on individual qubits (i.e. only one qubit of a pair)\n\nThis algorithm is detailed in (Fujii and Yamamoto, 2009)\n\njulia> a = Register(2)\n       b = Register(2)\n       c = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!(a[1:2], bell)\n       initialize!(b[1:2], bell)\n       initialize!(c[1:2], bell);\n\njulia> Purify3to1Node(:Z, :Y)(a[1], b[1], c[1]) == Purify3to1Node(:Z, :Y)(a[2], b[2], c[2])\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.PurifyExpedient","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.PurifyExpedient","text":"struct PurifyExpedient <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe EXPEDIENT purification circuit. It is composed of a head and a body. The head is repeated twice and the body is also repeating twice\n\nThe difference between it and the STRINGENT circuit is that the body is shorter.\n\nIf an error was detected, the circuit returns false and the state is reset. If no error was detected, the circuit returns true.\n\nThis circuit is detailed in (Naomi H. Nickerson and Benjamin, 2013)\n\nThe sacrificial qubits are removed from the register.\n\njulia> r = Register(22)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       for i in 1:11\n           initialize!(r[(2*i-1):(2*i)], bell)\n       end;\n\njulia> PurifyExpedient()(r[1], r[2], r[3:2:21]..., r[4:2:22]...)\ntrue\n\nSee also: PurifyExpedientNode, PurifyStringent\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.PurifyExpedientNode","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.PurifyExpedientNode","text":"struct PurifyExpedientNode <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe EXPEDIENT purification circuit (only the local half, executed on a single network node).\n\nThis returns the array of measurements made by the circuit.\n\nThis circuit is detailed in (Naomi H. Nickerson and Benjamin, 2013).\n\njulia> r = Register(22)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       for i in 1:11\n           initialize!(r[(2*i-1):(2*i)], bell)\n       end;\n\njulia> PurifyExpedientNode()(r[1], r[3:2:21]...) == PurifyExpedientNode()(r[2], r[4:2:22]...)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.PurifyStringent","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.PurifyStringent","text":"struct PurifyStringent <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe STRINGENT purification circuit. It is composed of a \"head\" and a \"body\". The head is repeated twice and the body is also repeating twice\n\nThis algorithm is detailed in (Stefan Krastanov and Jiang, 2019)\n\nIf an error was detected, the circuit returns false and the state is reset. If no error was detected, the circuit returns true.\n\nThis circuit is detailed in (Naomi H. Nickerson and Benjamin, 2013).\n\nThe sacrificial qubits are removed from the register.\n\njulia> r = Register(26)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       for i in 1:13\n            initialize!(r[(2*i-1):(2*i)], bell)\n       end;\n\njulia> PurifyStringent()(r[1], r[2], r[3:2:25]..., r[4:2:26]...)\ntrue\n\nSee also: PurifyStringentNode, PurifyExpedient\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.PurifyStringentNode","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.PurifyStringentNode","text":"struct PurifyStringentNode <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe STRINGENT purification circuit (only the local half, executed on a single network node).\n\nThis returns the array of measurements made by the circuit.\n\nThis circuit is detailed in (Naomi H. Nickerson and Benjamin, 2013).\n\nSee also: PurifyStringent\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.SDDecode","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.SDDecode","text":"struct SDDecode <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe circuit for Superdense Coding to decode the 2 (classical) bit message using the entangled bell pair stored in the registers regA and regB after Alice's encoding of the first qubit. Returns a Tuple of the decoded message.\n\njulia> regA = Register(1); regB = Register(1);\n\njulia> initialize!((regA[1], regB[1]), (L0⊗L0+L1⊗L1)/√2);\n\njulia> message = (1, 1);\n\njulia> SDEncode()(regA[1], message);\n\njulia> SDDecode()(regA[1], regB[1])\n(1, 1)\n\nSee also SDEncode\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.SDEncode","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.SDEncode","text":"struct SDEncode <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe circuit for Superdense Coding to encode the 2 (classical) bit message to its corresponding Bell pair representation. It takes as argumes a single qubit register containing Alice's half of the entangled Bell pair and the 2 bit message Alice intends to send to Bob.\n\njulia> regA = Register(1); regB = Register(1);\n\njulia> initialize!((regA[1], regB[1]), (L0⊗L0+L1⊗L1)/√2);\n\njulia> message = (1, 1);\n\njulia> SDEncode()(regA[1], message);\n\nSee also SDDecode\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/","page":"CircuitZoo API","title":"CircuitZoo API","text":"","category":"page"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/#Hardware-Abstractions-and-Noise-Models","page":"Bibliography","title":"Hardware Abstractions and Noise Models","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"(Prajit Dhara and Guha, 2023)","category":"page"},{"location":"bibliography/#Quantum-Circuits","page":"Bibliography","title":"Quantum Circuits","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"(Naomi H. Nickerson and Benjamin, 2013)\n(Stefan Krastanov and Jiang, 2019)","category":"page"},{"location":"bibliography/#Network-Protocols","page":"Bibliography","title":"Network Protocols","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"(Promponas et al., 2024)","category":"page"},{"location":"bibliography/#Demos","page":"Bibliography","title":"Demos","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"(Choi et al., 2019)\n(Muralidharan et al., 2016)","category":"page"},{"location":"bibliography/#Complete-References-List","page":"Bibliography","title":"Complete References List","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"Choi, H.; Pant, M.; Guha, S. and Englund, D. (2019). Percolation-based architecture for cluster state creation using photon-mediated entanglement between atomic memories, npj Quantum Information 5, 1–7.\n\n\n\nFujii, K. and Yamamoto, K. (2009). Entanglement purification with double selection. Phys. Rev. A 80, 042308.\n\n\n\nMuralidharan, S.; Li, L.; Kim, J.; Lütkenhaus, N.; Lukin, M. D. and Jiang, L. (2016). Optimal architectures for long distance quantum communication. Scientific reports 6, 1–10.\n\n\n\nNaomi H. Nickerson, Y. L. and Benjamin, S. C. (2013). Topological quantum computing with a very noisy network and local error rates approaching one percent. Nature.\n\n\n\nPrajit Dhara, D. E. and Guha, S. (2023). Entangling quantum memories via heralded photonic Bell measurement. Phys. Rev. Research 5, 033149.\n\n\n\nPromponas, P.; Valls, V.; Guha, S. and Tassiulas, L. (2024). Maximizing Entanglement Rates via Efficient Memory Management in Flexible Quantum Switches. IEEE Journal on Selected Areas in Communications.\n\n\n\nStefan Krastanov, V. V. and Jiang, L. (2019). Optimized Entanglement Purification. Arxiv.\n\n\n\n","category":"page"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"","category":"page"},{"location":"#QuantumSavory.jl","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"A multi-formalism simulator for noisy quantum communication and computation hardware with support for symbolic algebra, multiple simulation backends, a variety of noise models, discrete event simulation, optimization, and visualization.","category":"page"},{"location":"#Capabilities","page":"QuantumSavory.jl","title":"Capabilities","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"QuantumSavory offers features such as:","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"State, Circuit, and Protocols Zoos: Collections of pre-built quantum states, circuits, and protocols to support rapid prototyping and application optimization.\nRealistic Quantum Network Simulation: : Support for simulating noise and decoherence effects.\nVisualization: Tools for visualizing register states and experiment metadata, with support for background maps.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"The rest of the documentation is structured as follows:","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"How-To Guides - fully fleshed out guides to modeling common quantum hardware setups\nExplanations - how is the library structured, what are its conventions, and why were they decided upon\nTutorials - examples covering a specific small feature of the library\nReferences - description of the entire library API","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"Depending on your learning style, you might prefer to start at different locations in the above documentation.","category":"page"},{"location":"#Getting-Started","page":"QuantumSavory.jl","title":"Getting Started","text":"","category":"section"},{"location":"#Installation","page":"QuantumSavory.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"To use QuantumSavory, make sure you have Julia version 1.10 installed. You can download and install Julia from the official Julia website.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"Once Julia is setup, QuantumSavory can be installed with the following command in your in your Julia REPL:","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"$ julia\njulia> ]\npkg> add QuantumSavory","category":"page"},{"location":"#Optional-Dependencies","page":"QuantumSavory.jl","title":"Optional Dependencies","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"There are optional packages that you need to install to use the full plotting feature.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"Makie: For plotting of registers and processes.\nTyler: Enables plotting on a real-world map as a background.","category":"page"},{"location":"#Basic-Demo","page":"QuantumSavory.jl","title":"Basic Demo","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"Here’s a simple example to demonstrate how you can set up a simulation to generate a set of registers with qubit slots. For more advanced examples and detailed guide, seeHow-To Guides and Tutorials sections.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"Below we show some of the results of the How-To guides.","category":"page"},{"location":"#A-simulation-of-a-quantum-repeater:","page":"QuantumSavory.jl","title":"A simulation of a quantum repeater:","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"<video src=\"howto/firstgenrepeater/firstgenrepeater-07.observable.mp4\" autoplay loop muted></video>","category":"page"},{"location":"#A-simulation-of-the-generation-of-a-cluster-state-in-color-center-memories:","page":"QuantumSavory.jl","title":"A simulation of the generation of a cluster state in color-center memories:","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"<video src=\"howto/colorcentermodularcluster/colorcentermodularcluster-02.simdashboard.mp4\" autoplay loop muted></video>","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"warning: Warning\nThis is a limited public demo of a fraction of some internal research code. Full code is slowly being documented and released.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"danger: Danger\nThis is software is still in a fairly unstable alpha state! The documentation is extremely barebones and current users are expected to read the source code.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"A good place to start is the How-To pages. For instance, the implementation of a first generation repeater.","category":"page"},{"location":"#Office-Hours","page":"QuantumSavory.jl","title":"Office Hours","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"Office hours are held every Friday from 12:30 – 1:30 PM Eastern Time via Zoom. Before joining, make sure to check the Julia community events calendar to confirm whether office hours are happening, rescheduled, or canceled for the week. Feel free to bring any questions or suggestions!","category":"page"},{"location":"#Support","page":"QuantumSavory.jl","title":"Support","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"QuantumSavory.jl is developed by many volunteers, managed at Prof. Krastanov's lab at University of Massachusetts Amherst.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"The development effort is supported by The NSF Engineering and Research Center for Quantum Networks, and by NSF Grant 2346089 \"Research Infrastructure: CIRC: New: Full-stack Codesign Tools for Quantum Hardware\".","category":"page"},{"location":"#Bounties","page":"QuantumSavory.jl","title":"Bounties","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"We run many bug bounties and encourage submissions from novices (we are happy to help onboard you in the field).","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"","category":"page"},{"location":"tutorial/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"The tutorial section is an assortment of examples covering a specific small feature of the library and its idiomatic use.","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"","category":"page"}]
}

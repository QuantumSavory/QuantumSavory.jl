var documenterSearchIndex = {"docs":
[{"location":"propbackgrounds/#Properties-and-Backgrounds","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"","category":"section"},{"location":"propbackgrounds/","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"propbackgrounds/","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"When creating a new registers, you can specify what type of physical system it will contain in each slot, e.g. a Qubit or a qudit or a harmonic oscillator or a propagating wave packet.","category":"page"},{"location":"propbackgrounds/","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"For each subsystem (slot in the register), you also specify what background processes and noise parameters describe it. For instance, it could be a T1Decay or T2Dephasing process, or a coherent error, or a non-Markovian bath.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"references/","page":"References","title":"References","text":"The reference section of the documentation mostly consists of the API docs.","category":"page"},{"location":"API_Symbolics/#QuantumSymbolics.jl-reference","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.jl reference","text":"","category":"section"},{"location":"API_Symbolics/","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.jl reference","text":"You can also consult the complete QuantumSymbolics.jl documentation.","category":"page"},{"location":"API_Symbolics/","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.jl reference","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API_Symbolics/#Autogenerated-API-list-for-QuantumSymbolics","page":"QuantumSymbolics.jl reference","title":"Autogenerated API list for QuantumSymbolics","text":"","category":"section"},{"location":"API_Symbolics/","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.jl reference","text":"Modules = [QuantumSymbolics]\nPrivate = false","category":"page"},{"location":"API_Symbolics/#QuantumSymbolics.CNOT","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.CNOT","text":"CNOT gate\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.CPHASE","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.CPHASE","text":"CPHASE gate\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Create","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Create","text":"Creation operator, also available as the constant âꜛ - there is no unicode dagger superscript, so we use the uparrow\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Destroy","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Destroy","text":"Annihilation operator, also available as the constant â\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.F₁","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.F₁","text":"Single photon basis state of n\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.H","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.H","text":"Hadamard gate\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.N","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.N","text":"Number operator, also available as the constant n̂\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Pm","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Pm","text":"Pauli \"minus\" operator, also available as the constant σ₋\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Pp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Pp","text":"Pauli \"plus\" operator, also available as the constant σ₊\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.X","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.X","text":"Pauli X operator, also available as the constant σˣ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.X1","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.X1","text":"Basis state of σˣ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.X2","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.X2","text":"Basis state of σˣ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Y","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Y","text":"Pauli Y operator, also available as the constant σʸ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Y1","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Y1","text":"Basis state of σʸ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Y2","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Y2","text":"Basis state of σʸ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Z","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Z","text":"Pauli Z operator, also available as the constant σᶻ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Z1","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Z1","text":"Basis state of σᶻ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.Z2","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.Z2","text":"Basis state of σᶻ\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.vac","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.vac","text":"Vacuum basis state of n\n\n\n\n\n\n","category":"constant"},{"location":"API_Symbolics/#QuantumSymbolics.AbstractRepresentation","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.AbstractRepresentation","text":"An abstract type for the supported representation of quantum objects.\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.CliffordRepr","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.CliffordRepr","text":"Representation using tableaux governed by QuantumClifford.jl\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.DephasingCPTP","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.DephasingCPTP","text":"Single-qubit dephasing CPTP map\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.GateCPTP","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.GateCPTP","text":"A unitary gate followed by a CPTP map\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.IdentityOp","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.IdentityOp","text":"The identity operator for a given basis\n\njulia> IdentityOp(X1⊗X2)\n𝕀\n\njulia> express(IdentityOp(Z2))\nOperator(dim=2x2)\n  basis: Spin(1/2)sparse([1, 2], [1, 2], ComplexF64[1.0 + 0.0im, 1.0 + 0.0im], 2, 2)\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.MixedState","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.MixedState","text":"Completely depolarized state\n\njulia> MixedState(X1⊗X2)\n𝕄\n\njulia> express(MixedState(X1⊗X2))\nOperator(dim=4x4)\n  basis: [Spin(1/2) ⊗ Spin(1/2)]sparse([1, 2, 3, 4], [1, 2, 3, 4], ComplexF64[0.25 + 0.0im, 0.25 + 0.0im, 0.25 + 0.0im, 0.25 + 0.0im], 4, 4)\n\njulia> express(MixedState(X1⊗X2), CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n\n𝒳ₗ━━\n+ X_\n+ _X\n𝒮𝓉𝒶𝒷\n\n𝒵ₗ━━\n+ Z_\n+ _Z\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.PauliNoiseCPTP","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.PauliNoiseCPTP","text":"Single-qubit Pauli noise CPTP map\n\njulia> apply!(express(Z1), [1], express(PauliNoiseCPTP(1/4,1/4,1/4)))\nOperator(dim=2x2)\n  basis: Spin(1/2)\n 0.5+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.0im\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.QuantumMCRepr","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.QuantumMCRepr","text":"Similar to QuantumOpticsRepr, but using trajectories instead of superoperators.\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.QuantumOpticsRepr","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.QuantumOpticsRepr","text":"Representation using kets, bras, density matrices, and superoperators governed by QuantumOptics.jl.\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SDagger","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SDagger","text":"Dagger a Ket into Bra.\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.SProjector","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.SProjector","text":"Projector for a given ket\n\njulia> SProjector(X1⊗X2)\n𝐏[|X₁⟩|X₂⟩]\n\njulia> express(SProjector(X2))\nOperator(dim=2x2)\n  basis: Spin(1/2)\n  0.5+0.0im  -0.5-0.0im\n -0.5+0.0im   0.5+0.0im\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.StabilizerState","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.StabilizerState","text":"State defined by a stabilizer tableau\n\nFor full functionality you also need to import the QuantumClifford library.\n\njulia> using QuantumClifford, QuantumOptics # needed for the internal representation of the stabilizer tableaux and the conversion to a ket\n\njulia> StabilizerState(S\"XX ZZ\")\n𝒮₂\n\njulia> express(StabilizerState(S\"-X\"))\nKet(dim=2)\n  basis: Spin(1/2)\n  0.7071067811865475 + 0.0im\n -0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"API_Symbolics/#QuantumSymbolics.consistent_representation-Tuple{Any, Any}","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.consistent_representation","text":"Pick a representation that is consistent with given representations and appropriate for the given state.\n\n\n\n\n\n","category":"method"},{"location":"API_Symbolics/#QuantumSymbolics.express","page":"QuantumSymbolics.jl reference","title":"QuantumSymbolics.express","text":"The main interface for expressing quantum objects in various representations.\n\njulia> express(X1)\nKet(dim=2)\n  basis: Spin(1/2)\n 0.7071067811865475 + 0.0im\n 0.7071067811865475 + 0.0im\n\njulia> express(X1, CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n+ X\n\njulia> express(QuantumSymbolics.X, CliffordRepr(), UseAsOperation())\nsX\n\n\n\n\n\n","category":"function"},{"location":"API_ProtocolZoo/#Available-Protocols","page":"ProtocolZoo API","title":"Available Protocols","text":"","category":"section"},{"location":"API_ProtocolZoo/","page":"ProtocolZoo API","title":"ProtocolZoo API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API_ProtocolZoo/#Autogenerated-API-list-for-QuantumSavory.ProtocolZoo","page":"ProtocolZoo API","title":"Autogenerated API list for QuantumSavory.ProtocolZoo","text":"","category":"section"},{"location":"API_ProtocolZoo/","page":"ProtocolZoo API","title":"ProtocolZoo API","text":"Modules = [QuantumSavory.ProtocolZoo]\nPrivate = false","category":"page"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementConsumer","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementConsumer","text":"struct EntanglementConsumer{LT} <: QuantumSavory.ProtocolZoo.AbstractProtocol\n\nA protocol running between two nodes, checking periodically for any entangled pairs between the two nodes and consuming/emptying the qubit slots.\n\nsim: time-and-schedule-tracking instance from ConcurrentSim\nnet: a network graph of registers\nnodeA: the vertex index of node A\nnodeB: the vertex index of node B\nperiod: time period between successive queries on the nodes (nothing for queuing up and waiting for available pairs)\nlog: stores the time and resulting observable from querying nodeA and nodeB for EntanglementCounterpart\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementTracker","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementTracker","text":"struct EntanglementTracker <: QuantumSavory.ProtocolZoo.AbstractProtocol\n\nA protocol, running at a given node, listening for messages that indicate something has happened to a remote qubit entangled with one of the local qubits.\n\nsim::ConcurrentSim.Simulation: time-and-schedule-tracking instance from ConcurrentSim\nnet::RegisterNet: a network graph of registers\nnode::Int64: the vertex of the node where the tracker is working\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglerProt","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglerProt","text":"struct EntanglerProt{LT} <: QuantumSavory.ProtocolZoo.AbstractProtocol\n\nA protocol that generates entanglement between two nodes. Whenever a pair of empty slots is available, the protocol locks them and starts probabilistic attempts to establish entanglement.\n\nsim::ConcurrentSim.Simulation: time-and-schedule-tracking instance from ConcurrentSim\nnet::RegisterNet: a network graph of registers\nnodeA::Int64: the vertex index of node A\nnodeB::Int64: the vertex index of node B\npairstate::Any: the state being generated (supports symbolic, numeric, noisy, and pure)\nsuccess_prob::Float64: success probability of one attempt of entanglement generation\nattempt_time::Float64: duration of single entanglement attempt\nlocal_busy_time_pre::Float64: fixed \"busy time\" duration immediately before starting entanglement generation attempts\nlocal_busy_time_post::Float64: fixed \"busy time\" duration immediately after the a successful entanglement generation attempt\nretry_lock_time::Any: how long to wait before retrying to lock qubits if no qubits are available (nothing for queuing up)\nrounds::Int64: how many rounds of this protocol to run (-1 for infinite))\nrandomize::Bool: whether the protocol should find the first available free slots in the nodes to be entangled or check for free slots randomly from the available slots\nmargin::Int64: Repeated rounds of this protocol may lead to monopolizing all slots of a pair of registers, starving or deadlocking other protocols. This field can be used to always leave a minimum number of slots free if there already exists entanglement between the current pair of nodes.\nhardmargin::Int64: Like margin, but it is enforced even when no entanglement has been established yet. Usually smaller than margin.\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglerProt-Tuple{ConcurrentSim.Simulation, RegisterNet, Int64, Int64}","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglerProt","text":"Convenience constructor for specifying rate of generation instead of success probability and time\n\n\n\n\n\n","category":"method"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.SwapperProt","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.SwapperProt","text":"struct SwapperProt{NL, NH, CL, CH, LT} <: QuantumSavory.ProtocolZoo.AbstractProtocol\n\nA protocol, running at a given node, that finds swappable entangled pairs and performs the swap.\n\nsim::ConcurrentSim.Simulation: time-and-schedule-tracking instance from ConcurrentSim\nnet::RegisterNet: a network graph of registers\nnode::Int64: the vertex of the node where swapping is happening\nnodeL::Any: the vertex of one of the remote nodes for the swap, arbitrarily referred to as the \"low\" node (or a predicate function or a wildcard); if you are working on a repeater chain, a good choice is <(current_node), i.e. any node to the \"left\" of the current node\nnodeH::Any: the vertex of the other remote node for the swap, the \"high\" counterpart of nodeL; if you are working on a repeater chain, a good choice is >(current_node), i.e. any node to the \"right\" of the current node\nchooseL::Any: the nodeL predicate can return many positive candidates; chooseL picks one of them (by index into the array of filtered nodeL results), defaults to a random pick arr->rand(keys(arr)); if you are working on a repeater chain a good choice is argmin, i.e. the node furthest to the \"left\"\nchooseH::Any: the nodeH counterpart for chooseH; if you are working on a repeater chain a good choice is argmax, i.e. the node furthest to the \"right\"\nlocal_busy_time::Float64: fixed \"busy time\" duration immediately before starting entanglement generation attempts\nretry_lock_time::Any: how long to wait before retrying to lock qubits if no qubits are available (nothing for queuing up and waiting)\nrounds::Int64: how many rounds of this protocol to run (-1 for infinite))\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#Non-exported-custom-tags-used-by-these-protocols","page":"ProtocolZoo API","title":"Non-exported custom tags used by these protocols","text":"","category":"section"},{"location":"API_ProtocolZoo/","page":"ProtocolZoo API","title":"ProtocolZoo API","text":"QuantumSavory.ProtocolZoo.EntanglementCounterpart\nQuantumSavory.ProtocolZoo.EntanglementHistory\nQuantumSavory.ProtocolZoo.EntanglementUpdateX\nQuantumSavory.ProtocolZoo.EntanglementUpdateZ","category":"page"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementCounterpart","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementCounterpart","text":"struct EntanglementCounterpart\n\nIndicates the current entanglement status with a remote node's slot. Added when a new entanglement is generated through EntanglerProt or when a swap happens and  the EntanglementTracker receives an [EntanglementUpdate] message.\n\nremote_node::Int64: the id of the remote node to which we are entangled\nremote_slot::Int64: the slot in the remote node containing the qubit we are entangled to\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementHistory","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementHistory","text":"struct EntanglementHistory\n\nThis tag is used to store the outdated entanglement information after a swap. It helps to direct incoming entanglement update messages to the right node after a swap. It helps in situations when locally we have performed a swap, but we are now receiving a message from a distant node that does not know yet that the swap has occurred (thus the distant node might have outdated information about who is entangled to whom and we need to update that information).\n\nremote_node::Int64: the id of the remote node we used to be entangled to\nremote_slot::Int64: the slot of the remote node we used to be entangled to\nswap_remote_node::Int64: the id of remote node to which we are entangled after the swap\nswap_remote_slot::Int64: the slot of the remote node to which we are entangled after the swap\nswapped_local::Int64: the slot in this register with whom we performed a swap\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementUpdateX","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementUpdateX","text":"struct EntanglementUpdateX\n\nThis tag arrives as a message from a remote node to which the current node was entangled to update the entanglement information and apply an X correction after the remote node performs an entanglement swap.\n\npast_local_node::Int64: the id of the node to which you were entangled before the swap\npast_local_slot::Int64: the slot of the node to which you were entangled before the swap\npast_remote_slot::Int64: the slot of your node that we were entangled to\nnew_remote_node::Int64: the id of the node to which you are now entangled after the swap\nnew_remote_slot::Int64: the slot of the node to which you are now entangled after the swap\ncorrection::Int64: what Pauli correction you need to perform\n\n\n\n\n\n","category":"type"},{"location":"API_ProtocolZoo/#QuantumSavory.ProtocolZoo.EntanglementUpdateZ","page":"ProtocolZoo API","title":"QuantumSavory.ProtocolZoo.EntanglementUpdateZ","text":"struct EntanglementUpdateZ\n\nThis tag arrives as a message from a remote node to which the current node was entangled to update the entanglement information and apply a Z correction after the remote node performs an entanglement swap.\n\npast_local_node::Int64: the id of the node to which you were entangled before the swap\npast_local_slot::Int64: the slot of the node to which you were entangled before the swap\npast_remote_slot::Int64: the slot of your node that we were entangled to\nnew_remote_node::Int64: the id of the node to which you are now entangled after the swap\nnew_remote_slot::Int64: the slot of the node to which you are now entangled after the swap\ncorrection::Int64: what Pauli correction you need to perform\n\n\n\n\n\n","category":"type"},{"location":"howto/#How-To-Guides","page":"How-To Guides","title":"How-To Guides","text":"","category":"section"},{"location":"howto/","page":"How-To Guides","title":"How-To Guides","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"howto/","page":"How-To Guides","title":"How-To Guides","text":"\"HowTo\"s are fully fleshed out examples of how to use QuantumSavory to set up a complete simulation of a system of interest. They do not go into details of how the library is structured internally and do not provide in-depth discussion of APIs, rather they showcase idiomatic use of the library.","category":"page"},{"location":"howto/#A-simulation-of-a-quantum-repeater:","page":"How-To Guides","title":"A simulation of a quantum repeater:","text":"","category":"section"},{"location":"howto/","page":"How-To Guides","title":"How-To Guides","text":"<video src=\"firstgenrepeater/firstgenrepeater-07.observable.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/#A-simulation-of-the-generation-of-a-cluster-state-in-color-center-memories:","page":"How-To Guides","title":"A simulation of the generation of a cluster state in color-center memories:","text":"","category":"section"},{"location":"howto/","page":"How-To Guides","title":"How-To Guides","text":"<video src=\"colorcentermodularcluster/colorcentermodularcluster-02.simdashboard.mp4\" autoplay loop muted></video>","category":"page"},{"location":"visualizations/#Visualizations","page":"Visualizations","title":"Visualizations","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"We provide many visualization tools build on top of the Makie.jl framework for interactive visualizations.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The plotting functions generally return a tuple of (subfigure, axis, plot, observable). The observable can be used to issue a notify call that updates the plot with the current state of the network without replotting from scratch. This is particularly useful for live simulation visualizations.","category":"page"},{"location":"visualizations/#The-quantum-registers-in-the-network","page":"Visualizations","title":"The quantum registers in the network","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The registernetplot_axis function can be used to draw a given set of registers, together with the quantum states they contain. It also provides interactive tools for inspecting the content of the registers (by hovering or clicking on the corresponding register slot). Here we give an example where we define a network and then plot it:","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"using GLMakie\nusing QuantumSavory\n\n# create a network of qubit registers\nnet = RegisterNet([Register(2),Register(3),Register(2),Register(5)])\n\n# add some states, entangle a few slots, perform some gates\ninitialize!(net[1,1])\ninitialize!(net[2,3], X₁)\ninitialize!((net[3,1],net[4,2]), X₁⊗Z₂)\napply!((net[2,3],net[3,1]), CNOT)\n\n# create the plot\nfig = Figure(resolution=(800,400))\n_, ax, plt, obs = registernetplot_axis(fig[1,1],net)\nfig","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The tall rectangles are registers, the gray squares are the slots of these registers, and the (connected) black diamonds denote when a slot is occupied by some subsystem (of a potentially larger) quantum state.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The visualization is capable of showing tooltips when hovering over different components of the plot, particularly valuable for debugging. Quantum observables can be directly calculated and plotted as well (through the observables keyword).","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"Other configuration options are available as well (the ones ending on plot let you access the subplot objects used to create the visualization and the ones ending on backref provide convenient inverse mapping from graphical elements to the registers or states being visualized):","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"propertynames(plt)","category":"page"},{"location":"visualizations/#State-and-tag-metadata-in-interactive-visualizations","page":"Visualizations","title":"State and tag metadata in interactive visualizations","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"When working with interactive plots, you can also hover over different parts of the visualization to see the registers, what is stored in them, and potentially whether they contain any tagged metadata in use by simulated networking protocols.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"Here is what the data panels look like. (showmetada is used to force-show the panel, but when working interactively you simply need to hover with the cursor)","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"network = RegisterNet([Register(2),Register(3),Register(2),Register(5)]) # hide\ninitialize!(network[1,1]) # hide\ninitialize!(network[2,3], X₁) # hide\ninitialize!((network[3,1],network[4,2]), X₁⊗Z₂) # hide\napply!((network[2,3],network[3,1]), CNOT) # hide\nfig = Figure(resolution=(400,400)) # hide\n_, _, plt, obs = registernetplot_axis(fig[1,1],network) # hide\nQuantumSavory.showmetadata(fig,ax,plt,1,1)\nfig","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"And here with some extra tag metadata.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"tag!(net[2,3], :specialplace, 1, 2)\ntag!(net[2,3], :otherdata, 3, 4)\nQuantumSavory.showmetadata(fig,ax,plt,2,3)\nfig","category":"page"},{"location":"visualizations/#The-state-of-locks-and-various-metadata-in-the-network","page":"Visualizations","title":"The state of locks and various metadata in the network","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The resourceplot_axis function can be used to draw all locks and resources stored in a meta-graph governing a discrete event simulation. Metadata stored at the vertices is plotted as colored or grayed out dots depending on their state. Metadata stored at the edges is shown as lines.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"using Graphs\nusing ConcurrentSim\n\nsim = Simulation()\n\n# add random metadata to vertices and edges of the network\nfor v in vertices(net)\n    net[v,:bool] = rand(Bool)\n    net[v,:resource] = Resource(sim,1)\n    rand(Bool) && request(net[v,:resource])\nend\nfor e in edges(net)\n    net[e,:edge_bool] = true\n    net[e,:another_bool] = rand(Bool)\nend\n\n# plot the resources and metadata\n\nfig = Figure(resolution=(700,400))\nresourceplot_axis(fig[1,1],net,\n    [:edge_bool,:another_bool], # list of edge metadata to plot\n    [:bool,:resource],          # list of vertex metadata\n    registercoords=plt[:registercoords] # optionally, reuse register coordinates\n)\nfig","category":"page"},{"location":"visualizations/#Updating-the-plots","page":"Visualizations","title":"Updating the plots","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"You can call notify on the returned plot object to replot the state of the network after a change.","category":"page"},{"location":"tag_query/#tagging-and-querying","page":"Tagging and Querying","title":"Tagging and Querying","text":"","category":"section"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"DocTestSetup =  quote\n    using QuantumSavory\nend","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"The query and tag! interface lets you manage \"classical state\" metadata in your simulations. In particular, this interface enables the creation of modular interoperable control protocols. Each protocol can operate independently of others without knowledge of each others' internals. This is done by using various \"tags\" to communicate metadata between the network nodes running the protocols, and by the protocols querying for the presence of such tags, leading to greater flexibility when setting up different simulations.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"The components of the query interface which make this possible are described below.","category":"page"},{"location":"tag_query/#The-Tag-type","page":"Tagging and Querying","title":"The Tag type","text":"","category":"section"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"QuantumSavory.Tag","category":"page"},{"location":"tag_query/#QuantumSavory.Tag-tag_query","page":"Tagging and Querying","title":"QuantumSavory.Tag","text":"Tags are used to represent classical metadata describing the state (or even history) of nodes and their registers. The library allows the construction of custom tags using the Tag constructor. Currently tags are implemented as instances of a sum type and have fairly constrained structure. Most of them are constrained to contain only Symbol instances and integers.\n\nHere is an example of such a generic tag:\n\njulia> Tag(:sometagdescriptor, 1, 2, -3)\nSymbolIntIntInt(:sometagdescriptor, 1, 2, -3)::Tag\n\nA tag can have a custom DataType as first argument, in which case additional customability in printing is available. E.g. consider the [EntanglementHistory] tag used to track how pairs were entangled before a swap happened.\n\njulia> using QuantumSavory.ProtocolZoo: EntanglementHistory\n\njulia> Tag(EntanglementHistory, 1, 2, 3, 4, 5)\nWas entangled to 1.2, but swapped with .5 which was entangled to 3.4\n\nSee also: tag!, query\n\n\n\n\n\n","category":"type"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"And here are all currently supported tag signatures:","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"using QuantumSavory #hide\n[tuple(m.sig.types[2:end]...) for m in methods(Tag) if m.sig.types[2] ∈ (Symbol, DataType)]","category":"page"},{"location":"tag_query/#Assigning-and-removing-tags","page":"Tagging and Querying","title":"Assigning and removing tags","text":"","category":"section"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"QuantumSavory.tag!\nQuantumSavory.untag!","category":"page"},{"location":"tag_query/#QuantumSavory.tag!-tag_query","page":"Tagging and Querying","title":"QuantumSavory.tag!","text":"tag!(ref::RegRef, tag::Tag) -> Vector{Tag}\n\n\nAssign a tag to a slot in a register.\n\nIt returns the list of all currently present tags for that register.\n\nSee also: query, untag!\n\n\n\n\n\n","category":"function"},{"location":"tag_query/#QuantumSavory.untag!-tag_query","page":"Tagging and Querying","title":"QuantumSavory.untag!","text":"untag!(ref::RegRef, tag::Tag) -> Vector{Tag}\n\n\nRemoves the first instance of tag from the list to tags associated with a RegRef in a Register\n\nIt returns the list of all currently present tags for that register.\n\nSee also: query, tag!\n\n\n\n\n\n","category":"function"},{"location":"tag_query/#Querying-for-the-presence-of-a-tag","page":"Tagging and Querying","title":"Querying for the presence of a tag","text":"","category":"section"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"The query function allows the user to query for Tags in three different cases:","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"on a particular qubit slot (RegRef) in a Register node;\non a Register to query for any slot that contains the passed Tag;\non a messagebuffer to query for a particular Tag received from another node in a network.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"The Tag description passed to query can include predicate functions (of the form x -> pass::Bool) and wildcards (the ❓ variable), for situations where we have freedom in what tag we are exactly searching for.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"The queries can search in FIFO or FILO order (FILO by default). E.g., for the default FILO, a query on a RegRef returns the Tag which is at the end of the vector of tags stored the given slot (as new tags are appended at the end). On a Register it returns the slot with the \"youngest\" age.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"One can also query by \"lock\" and \"assignment\" status of a given slot, by using the locked and assigned boolean keywords. By default these keywords are set to nothing and these properties are not checked.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"Following is a detailed description of each query method","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"query(::Register,::Tag)\nquery(::RegRef,::Tag) \nquery(::MessageBuffer,::Tag)","category":"page"},{"location":"tag_query/#QuantumSavory.query-Tuple{Register, Tag}-tag_query","page":"Tagging and Querying","title":"QuantumSavory.query","text":"query(\n    reg::Register,\n    tag::Tag;\n    ...\n) -> Union{Nothing, @NamedTuple{slot::RegRef, depth::Int64, tag::Tag}}\nquery(\n    reg::Register,\n    tag::Tag,\n    ::Val{allB};\n    locked,\n    assigned,\n    filo\n) -> Union{Nothing, @NamedTuple{slot::RegRef, depth::Int64, tag::Tag}, Vector{@NamedTuple{slot::RegRef, depth::Int64, tag::Tag}}}\n\n\nA query function searching for the first slot in a register that has a given tag.\n\nWildcards are supported (instances of Wildcard also available as the constants W or the emoji ❓ which can be entered as \\:question: in the REPL). Predicate functions are also supported (they have to be Int↦Bool functions). The order of query lookup can be specified in terms of FIFO or FILO and defaults to FILO if not specified. The keyword arguments locked and assigned can be used to check, respectively, whether the given slot is locked or whether it contains a quantum state. The keyword argument filo can be used to specify whether the search should be done in a FIFO or FILO order, defaulting to filo=true (i.e. a stack-like behavior).\n\njulia> r = Register(10);\n       tag!(r[1], :symbol, 2, 3);\n       tag!(r[2], :symbol, 4, 5);\n\n\njulia> query(r, :symbol, 4, 5)\n(slot = Slot 2, depth = 1, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n\njulia> lock(r[1]);\n\njulia> query(r, :symbol, 4, 5; locked=false) |> isnothing\nfalse\n\njulia> query(r, :symbol, ❓, 3)\n(slot = Slot 1, depth = 1, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\njulia> query(r, :symbol, ❓, 3; assigned=true) |> isnothing\ntrue\n\njulia> query(r, :othersym, ❓, ❓) |> isnothing\ntrue\n\njulia> tag!(r[5], Int, 4, 5);\n\njulia> query(r, Float64, 4, 5) |> isnothing\ntrue\n\njulia> query(r, Int, 4, >(7)) |> isnothing\ntrue\n\njulia> query(r, Int, 4, <(7))\n(slot = Slot 5, depth = 1, tag = TypeIntInt(Int64, 4, 5)::Tag)\n\nSee also: queryall, tag!, W, ❓\n\n\n\n\n\n","category":"method"},{"location":"tag_query/#QuantumSavory.query-Tuple{RegRef, Tag}-tag_query","page":"Tagging and Querying","title":"QuantumSavory.query","text":"query(\n    ref::RegRef,\n    tag::Tag;\n    ...\n) -> Union{Nothing, @NamedTuple{depth::Int64, tag::Tag}}\nquery(\n    ref::RegRef,\n    tag::Tag,\n    ::Val{allB};\n    filo\n) -> Union{Nothing, @NamedTuple{depth::Int64, tag::Tag}, Vector{@NamedTuple{depth::Int64, tag::Tag}}}\n\n\nA query on a single slot of a register.\n\njulia> r = Register(5);\n\njulia> tag!(r[2], :symbol, 2, 3);\n\njulia> query(r[2], :symbol, 2, 3)\n(depth = 1, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\njulia> query(r[3], :symbol, 2, 3) === nothing\ntrue\n\njulia> queryall(r[2], :symbol, 2, 3)\n1-element Vector{@NamedTuple{depth::Int64, tag::Tag}}:\n (depth = 1, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\n\n\n\n\n","category":"method"},{"location":"tag_query/#QuantumSavory.query-Tuple{MessageBuffer, Tag}-tag_query","page":"Tagging and Querying","title":"QuantumSavory.query","text":"query(\n    mb::MessageBuffer,\n    tag::Tag\n) -> Union{Nothing, NamedTuple{(:depth, :src, :tag), <:Tuple{Int64, Int64, Any}}}\nquery(\n    mb::MessageBuffer,\n    tag::Tag,\n    ::Val{allB}\n) -> Union{Nothing, NamedTuple{(:depth, :src, :tag), <:Tuple{Int64, Int64, Any}}}\n\n\nYou are advised to actually use querydelete!, not query when working with classical message buffers.\n\n\n\n\n\n","category":"method"},{"location":"tag_query/#Wildcards","page":"Tagging and Querying","title":"Wildcards","text":"","category":"section"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"W\n❓","category":"page"},{"location":"tag_query/#QuantumSavory.W-tag_query","page":"Tagging and Querying","title":"QuantumSavory.W","text":"A wildcard instance for use with the tag querying functionality.\n\nSee also: query, tag!, ❓\n\n\n\n\n\n","category":"constant"},{"location":"tag_query/#QuantumSavory.❓-tag_query","page":"Tagging and Querying","title":"QuantumSavory.❓","text":"A wildcard instance for use with the tag querying functionality.\n\nThis emoji can be inputted with the \\:question: emoji shortcut, or you can simply use the ASCII alternative W.\n\nSee also: query, tag!, W\n\n\n\n\n\n","category":"constant"},{"location":"tag_query/#querydelete!","page":"Tagging and Querying","title":"querydelete!","text":"","category":"section"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"A method on top of query, which allows to query for tag in a RegRef or a messagebuffer, returning the tag that satisfies the passed predicates and wildcars, and deleting it from the list at the same time. It otherwise has the same signature as query.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"querydelete!(::RegRef)\nquerydelete!(::MessageBuffer)","category":"page"},{"location":"tag_query/#QuantumSavory.querydelete!-Tuple{RegRef}-tag_query","page":"Tagging and Querying","title":"QuantumSavory.querydelete!","text":"querydelete!(ref::RegRef, args...) -> Union{Nothing, Tag}\n\n\nA query for RegRef that also deletes the tag from the tag list for the RegRef.\n\n\n\n\n\n","category":"method"},{"location":"tag_query/#QuantumSavory.querydelete!-Tuple{MessageBuffer}-tag_query","page":"Tagging and Querying","title":"QuantumSavory.querydelete!","text":"querydelete!(\n    mb::MessageBuffer,\n    args...\n) -> Union{Nothing, @NamedTuple{src::Int64, tag::T} where T}\n\n\nA query for classical message buffers that also deletes the message out of the buffer.\n\njulia> net = RegisterNet([Register(3), Register(2)])\nA network of 2 registers in a graph of 1 edges\n\njulia> put!(channel(net, 1=>2), Tag(:my_tag));\n\njulia> put!(channel(net, 1=>2), Tag(:another_tag, 123, 456));\n\njulia> query(messagebuffer(net, 2), :my_tag)\n\njulia> run(get_time_tracker(net))\n\njulia> query(messagebuffer(net, 2), :my_tag)\n(depth = 1, src = 1, tag = Symbol(:my_tag)::Tag)\n\njulia> querydelete!(messagebuffer(net, 2), :my_tag)\n(src = 1, tag = Symbol(:my_tag)::Tag)\n\njulia> querydelete!(messagebuffer(net, 2), :my_tag) === nothing\ntrue\n\njulia> querydelete!(messagebuffer(net, 2), :another_tag, ❓, ❓)\n(src = 1, tag = SymbolIntInt(:another_tag, 123, 456)::Tag)\n\njulia> querydelete!(messagebuffer(net, 2), :another_tag, ❓, ❓) === nothing\ntrue\n\nYou can also wait on a message buffer for a message to arrive before running a query:\n\njulia> using ResumableFunctions; using ConcurrentSim;\n\njulia> net = RegisterNet([Register(3), Register(2), Register(3)])\nA network of 3 registers in a graph of 2 edges\n\njulia> env = get_time_tracker(net);\n\njulia> @resumable function receive_tags(env)\n           while true\n               mb = messagebuffer(net, 2)\n               @yield wait(mb)\n               msg = querydelete!(mb, :second_tag, ❓, ❓)\n               print(\"t=$(now(env)): query returns \")\n               if isnothing(msg)\n                   println(\"nothing\")\n               else\n                   println(\"$(msg.tag) received from node $(msg.src)\")\n               end\n           end\n       end\nreceive_tags (generic function with 1 method)\n\njulia> @resumable function send_tags(env)\n           @yield timeout(env, 1.0)\n           put!(channel(net, 1=>2), Tag(:my_tag))\n           @yield timeout(env, 2.0)\n           put!(channel(net, 3=>2), Tag(:second_tag, 123, 456))\n       end\nsend_tags (generic function with 1 method)\n\njulia> @process send_tags(env);\n\njulia> @process receive_tags(env);\n\njulia> run(env, 10)\nt=1.0: query returns nothing\nt=3.0: query returns SymbolIntInt(:second_tag, 123, 456)::Tag received from node 3\n\n\n\n\n\n","category":"method"},{"location":"tag_query/#queryall","page":"Tagging and Querying","title":"queryall","text":"","category":"section"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"A method defined on top of query which allows to query for all tags in a RegRef or a Register that match the query.","category":"page"},{"location":"tag_query/","page":"Tagging and Querying","title":"Tagging and Querying","text":"QuantumSavory.queryall","category":"page"},{"location":"tag_query/#QuantumSavory.queryall-tag_query","page":"Tagging and Querying","title":"QuantumSavory.queryall","text":"queryall(args...; filo, kwargs...) -> Any\n\n\nA query function that returns all slots of a register that have a given tag, with support for predicates and wildcards.\n\njulia> r = Register(10);\n       tag!(r[1], :symbol, 2, 3);\n       tag!(r[2], :symbol, 4, 5);\n\njulia> queryall(r, :symbol, ❓, ❓)\n2-element Vector{@NamedTuple{slot::RegRef, depth::Int64, tag::Tag}}:\n (slot = Slot 1, depth = 1, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n (slot = Slot 2, depth = 1, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n\njulia> queryall(r, :symbol, ❓, >(4))\n1-element Vector{@NamedTuple{slot::RegRef, depth::Int64, tag::Tag}}:\n (slot = Slot 2, depth = 1, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n\njulia> queryall(r, :symbol, ❓, >(5))\n@NamedTuple{slot::RegRef, depth::Int64, tag::Tag}[]\n\n\n\n\n\n","category":"function"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/#Cluster-State-on-Color-Centers","page":"Cluster States in Atomic Memories","title":"Cluster State on Color Centers","text":"","category":"section"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"Cluster states are highly entangled state of qubits useful as a computational resource. The cluster state is also a graph state where the graph has a 2D grid topology.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"One interesting hardware implementation involves entangling a large number of color centers[1].","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"[1]: (Choi et al., 2019)","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"We will build a simulator for such a piece of hardware. Each node will be a register of one electron spin for networking and one nuclear spin in which the actual long-term entanglement is \"stored\". The visualization below shows an example of the state being generated, together with tracking the state of various locks and other metadata that needs to be tracked.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"<video src=\"../colorcentermodularcluster-02.simdashboard.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"Of interest is both the time it takes to prepare a full cluster state, as well as the fidelity of state being prepared in that fashion. The fidelity can be lowered due to the numerous noise processes experience by the hardware. The duration can be quite long due to the low efficiencies of photon capture during typical entanglement procedures. The plot below shows the distribution of these figures of merit, sampled from a large number of independent runs of the simulation (gathering the entirety of this date takes less than a second).","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"(Image: Time to cluster preparation versus fidelity of cluster)","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"For organizing the simulation and simplifying the digital and analog quantum dynamics, we will use the star of QuantumSavory.jl, namely the Register data structure. For a convenient data structure to track per-node metadata in a graph (network) we will use the RegisterNet structure.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"Moreover, behind the scenes QuantumSavory.jl will use:","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"ConcurrentSim.jl for discrete event scheduling and simulation;\nMakie.jl together with our custom plotting recipes for visualizations;\nQuantumOptics.jl for low-level quantum states.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"The user does not need to know much about these libraries, but if they wish, it is easy for them to peek behind the scenes and customize their use.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"warning: Warning\nThis example is not yet well documented, nor is it modeling all of the noise processes of interest in this hardware. The code is not particularly clean yet either.","category":"page"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/#Full-Code","page":"Cluster States in Atomic Memories","title":"Full Code","text":"","category":"section"},{"location":"howto/colorcentermodularcluster/colorcentermodularcluster/","page":"Cluster States in Atomic Memories","title":"Cluster States in Atomic Memories","text":"The entirety of the code necessary for reproducing these results is in the examples folder of the QuantumSavory.jl repository.","category":"page"},{"location":"manual/#manual","page":"Getting Started Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Getting Started Manual","title":"Getting Started Manual","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"explanations/#Explanations","page":"Explanations","title":"Explanations","text":"","category":"section"},{"location":"explanations/","page":"Explanations","title":"Explanations","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"explanations/","page":"Explanations","title":"Explanations","text":"This section covers how is the library structured, what are its conventions, and why were they decided upon.","category":"page"},{"location":"explanations/","page":"Explanations","title":"Explanations","text":"You probably want to cover the:","category":"page"},{"location":"explanations/","page":"Explanations","title":"Explanations","text":"Register and RegisterNet structures\nbasic interface used by the library\nsymbolic capabilities for formalism-agnostic description\nmetadata tagging and metadata queries for interoperability between protocols\navailable simulator backends\ndiscrete event simulations and time-tracking capabilities\nbackground noise processes\ngraphical visualization and plotting recipes","category":"page"},{"location":"tutorial/noninstantgate/#Gate-duration,-i.e.-gates-that-are-not-instant","page":"Gate duration","title":"Gate duration, i.e. gates that are not instant","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"DocTestSetup = quote\n    using QuantumSavory\n    using CairoMakie\nend","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"There are a number of different ways to represent a gate that is not instantaneous in QuantumSavory. They are not necessarily equivalent. Here we show a couple of typical approaches.","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"We start with a quick initial setup of a register with two qubits and an observable pop representing the population in the excited state in the Z basis. The gate duration will be set to 1.0 (as given in ts) and the qubits will have decay time T1 = 2.0 so that we can more clearly demonstrate effects due to the non-instant nature of the gate.","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"using QuantumSavory\nusing CairoMakie\n\nT1 = 2.0\nreg = Register([Qubit(), Qubit()], [nothing, T1Decay(T1)])\ninitialize!(reg[1], Z₂)\ninitialize!(reg[2], Z₂)\n\npop = SProjector(Z₂)\ninitial_pop = observable(reg[2], pop)\n\nSTEPS = 20\nts = range(0,1,length=STEPS)","category":"page"},{"location":"tutorial/noninstantgate/#Approach-1:-Apply-an-instantaneous-gate-and-then-simply-wait","page":"Gate duration","title":"Approach 1: Apply an instantaneous gate and then simply wait","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"A rather manual and simple approach. We will plot the value of the population observable over the entire waiting period.","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"reg_gate_wait = deepcopy(reg) # copy the register\napply!([reg_gate_wait[1],reg_gate_wait[2]], CNOT)\npop_gate_wait = [observable(reg_gate_wait[2], pop; time) for time in ts]\nall_pop_gate_wait = real.([initial_pop, pop_gate_wait...])                           #hide\nfig = Figure(resolution=(600,300))                                                   #hide\naxis = Axis(fig[1,1])                                                                #hide\nlines!([0,ts...], all_pop_gate_wait, color=Cycled(1), label=\"apply gate then wait\")  #hide\nfig[1, 2] = Legend(fig, axis, \"Implementation\", framevisible = false)                #hide\nfig                                                                                  #hide","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"Given that the gate flips from the initial excited state to the ground state, the T1 decay does not have any effect.","category":"page"},{"location":"tutorial/noninstantgate/#Approach-2:-Wait-and-then-apply-an-instantaneous-gate","page":"Gate duration","title":"Approach 2: Wait and then apply an instantaneous gate","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"reg_wait_gate = deepcopy(reg)\npop_wait_gate = [observable(reg_wait_gate[2], pop; time) for time in ts]\napply!([reg_wait_gate[1],reg_wait_gate[2]], CNOT)\nfinal_pop_wait_gate = observable(reg_wait_gate[2], pop)\nall_pop_wait_gate = real.([initial_pop, pop_wait_gate..., final_pop_wait_gate])             #hide\nfig = Figure(resolution=(600,300))                                                          #hide\naxis = Axis(fig[1,1])                                                                       #hide\nlines!([0,ts...,ts[end]], all_pop_wait_gate, color=Cycled(2), label=\"wait then apply gate\") #hide\nfig[1, 2] = Legend(fig, axis, \"Implementation\", framevisible = false)                       #hide\nfig                                                                                         #hide","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"There has been significant decay before the gate is applied, which leads to only partially flipping the state (which is also mixed).","category":"page"},{"location":"tutorial/noninstantgate/#Approach-3:-The-[NonInstantGate](@ref)","page":"Gate duration","title":"Approach 3: The NonInstantGate","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"using QuantumSavory: NonInstantGate\n\nreg_slow_cnot = deepcopy(reg)\ngate = NonInstantGate(CNOT, 1.0)\napply!([reg_slow_cnot[1],reg_slow_cnot[2]], CNOT)\nfinal_pop_slow_cnot = observable(reg_slow_cnot[2], pop)\nfig = Figure(resolution=(600,300))                                                #hide\naxis = Axis(fig[1,1])                                                             #hide\nscatter!([0,ts[end]], real.([initial_pop, final_pop_slow_cnot]), color=Cycled(3), label=\"NonInstantGate\") #hide\nfig[1, 2] = Legend(fig, axis, \"Implementation\", framevisible = false)             #hide\nfig                                                                               #hide","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"NonInstantGate is convenient way to store a \"gate duration\" together with an arbitrary gate. As it does not permit sampling while the gate is being performed, we have only initial and final state. Internally, this is implemented by applying the gate instantaneously and then waiting.","category":"page"},{"location":"tutorial/noninstantgate/#Approach-4:-Continuous-application-of-a-Hamiltonian","page":"Gate duration","title":"Approach 4: Continuous application of a Hamiltonian","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"The approximation of a gate+waiting above might be inappropriate for real systems (or at least it might be difficult to calibrate). Instead, one can simply provide the Hamiltonian that implements a give gate and QuantumSavory will automatically solve the corresponding dynamical equation.","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"Below we do it in two different ways: A single evolution for duration 1.0 (which does not permit sampling of the state in intermediary times):","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"reg_slow_ham  = deepcopy(reg)\nham_gate = ConstantHamiltonianEvolution(pi/2*SProjector(Z₂)⊗σˣ,1.0)\napply!([reg_slow_ham[1],reg_slow_ham[2]], ham_gate)\nfinal_pop_slow_ham = observable(reg_slow_ham[2], pop)","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"... and the same but performed in multiple separate steps in order to be able to plot the intermediary results:","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"reg_slow_ham_steps  = deepcopy(reg)\nham_gate_step = ConstantHamiltonianEvolution(pi/2*SProjector(Z₂)⊗σˣ, ts[2])\npop_slow_ham_steps = [\n    begin\n        apply!([reg_slow_ham_steps[1], reg_slow_ham_steps[2]], ham_gate_step)\n        observable(reg_slow_ham_steps[2], pop)\n    end\n    for _ in 2:STEPS\n]\nall_pop_slow_ham_steps = real.([initial_pop, pop_slow_ham_steps...])              #hide\nfig = Figure(resolution=(600,300))                                                #hide\naxis = Axis(fig[1,1])                                                             #hide\nscatter!([0,ts[end]], real.([initial_pop, final_pop_slow_ham]), color=Cycled(4), label=\"Hamiltonian\", marker='▴', markersize=18) #hide\nlines!(ts, all_pop_slow_ham_steps, color=Cycled(5), label=\"Hamiltonian (steps)\")  #hide\nfig[1, 2] = Legend(fig, axis, \"Implementation\", framevisible = false)             #hide\nfig                                                                               #hide","category":"page"},{"location":"tutorial/noninstantgate/#Summary-and-comparison-of-all-results","page":"Gate duration","title":"Summary and comparison of all results","text":"","category":"section"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"Below we plot the results of each approach. As you can see, they are physically different and it might be important to calibrate them carefully to the situation at hand.","category":"page"},{"location":"tutorial/noninstantgate/","page":"Gate duration","title":"Gate duration","text":"all_pop_gate_wait = real.([initial_pop, pop_gate_wait...])\nall_pop_wait_gate = real.([initial_pop, pop_wait_gate..., final_pop_wait_gate])\nall_pop_slow_ham_steps = real.([initial_pop, pop_slow_ham_steps...])\nfig = Figure(resolution=(600,300))\naxis = Axis(fig[1,1])\nlines!([0,ts...], all_pop_gate_wait, color=Cycled(1), label=\"apply gate then wait\")\nlines!([0,ts...,ts[end]], all_pop_wait_gate, color=Cycled(2), label=\"wait then apply gate\")\nscatter!([0,ts[end]], real.([initial_pop, final_pop_slow_cnot]), color=Cycled(3), label=\"NonInstantGate\")\nscatter!([0,ts[end]], real.([initial_pop, final_pop_slow_ham]), color=Cycled(4), label=\"Hamiltonian\", marker='▴', markersize=18)\nlines!(ts, all_pop_slow_ham_steps, color=Cycled(5), label=\"Hamiltonian (steps)\")\nfig[1, 2] = Legend(fig, axis, \"Implementation\", framevisible = false)\nfig","category":"page"},{"location":"symbolics/#Symbolic-Expressions","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"","category":"section"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"QuantumSavory supports symbolic expressions for the quantum states and operations being simulated thanks to the QuantumSymbolics library. It serves two purposes:","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"It provides for algebraic manipulation of mathematical expressions related to your models. Particularly helpful when having to automatically generate or simplify expressions of significant complexity.\nAn assortment of \"expression translators\" are provided that can turn a symbolic expression into a numerical one in any of the representations supported by the simulator (e.g. wavefunctions, tableaux, etc).","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Below we list some commonly used expressions. For more detailed documentation consult QuantumSymbolics.jl.","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"using QuantumSavory","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<table>\n<tr>\n<th></th><th>Symbolic Example</th><th>Conversion Example</th>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Qubit Basis States -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Qubit Basis States X1, X2, Y1, Y2, Z1, Z2","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Z1","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(Z1)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(Y2, CliffordRepr())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Common gates -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Common gates: CNOT, H, etc","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"CNOT","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(H)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(CNOT, CliffordRepr(), UseAsOperation())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Tensor products and sums -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Tensor products ⊗ and sums +","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"(X1⊗Z2 + Y1⊗Y2 ) / √3","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(X1⊗Z1)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(X1⊗Y2, CliffordRepr())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Projectors -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Projectors, pure density matrices","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"SProjector(X1⊗Z2)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(SProjector(X1⊗Z1))","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(SProjector(X1⊗Z1), CliffordRepr())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Completely mixed state -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Completely depolarized (mixed) state","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"MixedState(X1)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(MixedState(X1))","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(MixedState(X1), CliffordRepr())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"<!-- Mixtures -->\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"Impure states, represented as sum of density matrices","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"(MixedState(X1)+SProjector(Z1)) / 2","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n<td>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express((MixedState(X1)+SProjector(Z1)) / 2)","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"When a Clifford representation is used, an efficient sampler is generated, and stabilizer states are randomly sampled from the correct distribution:","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"express(MixedState(X1)/2+SProjector(Z1)/2, CliffordRepr())","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"</tr>\n</table>","category":"page"},{"location":"symbolics/","page":"Symbolic Expressions","title":"Symbolic Expressions","text":"warning: Stabilizer state expressions\nThe state written as fracZ₁Z₁+Z₂Z₂2 is a well known stabilizer state, namely a Bell state. However, automatically expressing it as a stabilizer is a prohibitively expensive computational operation in general. We do not perform that computation automatically. If you want to ensure that states you define can be automatically converted to tableaux for Clifford simulations, avoid using sumation of kets. On the other hand, in all of our Clifford Monte-Carlo simulations, ⊗ is fully supported, as well as SProjector, MixedState, StabilizerState, and sumation of density matrices.","category":"page"},{"location":"API_StatesZoo/#Available-States","page":"StatesZoo API","title":"Available States","text":"","category":"section"},{"location":"API_StatesZoo/","page":"StatesZoo API","title":"StatesZoo API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API_StatesZoo/#Autogenerated-API-list-for-QuantumSavory.StatesZoo","page":"StatesZoo API","title":"Autogenerated API list for QuantumSavory.StatesZoo","text":"","category":"section"},{"location":"API_StatesZoo/","page":"StatesZoo API","title":"StatesZoo API","text":"Modules = [QuantumSavory.StatesZoo]\nPrivate = false","category":"page"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.DualRailMidSwapBell","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.DualRailMidSwapBell","text":"struct DualRailMidSwapBell <: QuantumSavory.StatesZoo.AbstractTwoQubitState\n\nFields:\n\neA: Link efficiencies for memory A upto the swap (include link loss, detector efficiency, etc.)\neB: Link efficiencies for memory B upto the swap (include link loss, detector efficiency, etc.)\ngA: Memory initialization parameter for memory A\ngB: Memory initialization parameter for memory B\nPd: Detector dark count probability per photonic mode (assumed to be the same for both detectors)\nVis: Interferometer visibility for the midpoint swap\nmetadata\n\nGenerates the normalized spin-spin density matrix for linear photonic entanglement swap with emissive  memories emitting dual rail photonic qubits from the paper (Prajit Dhara and Guha, 2023).\n\njulia> using QuantumSavory.StatesZoo: DualRailMidSwapBell\n\njulia> r = Register(2);\n\njulia> initialize!(r[1:2], DualRailMidSwapBell(0.9, 0.9, 0.5, 0.5, 1e-8, 0.99));\n\njulia> observable(r[1:2], Z⊗Z)\n-0.9999999911111113 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.DualRailMidSwapBellW","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.DualRailMidSwapBellW","text":"struct DualRailMidSwapBellW <: QuantumSavory.StatesZoo.AbstractTwoQubitState\n\nFields:\n\neA: Link efficiencies for memory A upto the swap (include link loss, detector efficiency, etc.)\neB: Link efficiencies for memory B upto the swap (include link loss, detector efficiency, etc.)\ngA: Memory initialization parameter for memory A\ngB: Memory initialization parameter for memory B\nPd: Detector dark count probability per photonic mode (assumed to be the same for both detectors)\nVis: Interferometer visibility for the midpoint swap\nmetadata\n\nGenerates the unnormalized spin-spin density matrix for linear photonic entanglement swap with emissive  memories emitting dual rail photonic qubits from the paper (Prajit Dhara and Guha, 2023).   Since the matrix is 'weighted' by the probability for success, it is suffixed with a W to distinguish it  from the normalized object DualRailMidSwapBell.\n\njulia> using QuantumSavory.StatesZoo: DualRailMidSwapBellW\n\njulia> r = Register(2);\n\njulia> initialize!(r[1:2], DualRailMidSwapBellW(0.9, 0.9, 0.5, 0.5, 1e-8, 0.99));\n\njulia> observable(r[1:2], Z⊗Z)\n-0.10124999595000005 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.SingleRailMidSwapBell","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.SingleRailMidSwapBell","text":"struct SingleRailMidSwapBell <: QuantumSavory.StatesZoo.AbstractTwoQubitState\n\nFields:\n\neA: Link efficiencies for memory A upto the swap (include link loss, detector efficiency, etc.)\neB: Link efficiencies for memory B upto the swap (include link loss, detector efficiency, etc.)\ngA: Memory initialization parameter for memory A\ngB: Memory initialization parameter for memory B\nPd: Detector dark count probability per photonic mode (assumed to be the same for both detectors)\nVis: Interferometer visibility for the midpoint swap' can be complex to account for phase instability\nmetadata\n\nGenerates the normalized spin-spin density matrix for linear photonic entanglement swap  with emissive memories emitting single rail photonic qubits from the paper (Prajit Dhara and Guha, 2023)\n\njulia> using QuantumSavory.StatesZoo: SingleRailMidSwapBell\n\njulia> r = Register(2);\n\njulia> initialize!(r[1:2], SingleRailMidSwapBell(0.9, 0.9, 0.5, 0.5, 1e-8, 0.99));\n\njulia> observable(r[1:2], Z⊗Z)\n-0.8181818000000001 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.SingleRailMidSwapBellW","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.SingleRailMidSwapBellW","text":"struct SingleRailMidSwapBellW <: QuantumSavory.StatesZoo.AbstractTwoQubitState\n\nFields:\n\neA: Link efficiencies for memory A upto the swap (include link loss, detector efficiency, etc.)\neB: Link efficiencies for memory B upto the swap (include link loss, detector efficiency, etc.)\ngA: Memory initialization parameter for memory A\ngB: Memory initialization parameter for memory B\nPd: Detector dark count probability per photonic mode (assumed to be the same for both detectors)\nVis: Interferometer visibility for the midpoint swap' can be complex to account for phase instability\nmetadata\n\nGenerates the unnormalized spin-spin density matrix for linear photonic entanglement swap  with emissive memories emitting single rail photonic qubits from the paper (Prajit Dhara and Guha, 2023). Since the matrix is 'weighted' by the probability for success, it is suffixed with a W to distinguish it  from the normalized object SingleRailMidSwapBell.\n\njulia> using QuantumSavory.StatesZoo: SingleRailMidSwapBellW\n\njulia> r = Register(2);\n\njulia> initialize!(r[1:2], SingleRailMidSwapBellW(0.9, 0.9, 0.5, 0.5, 1e-8, 0.99));\n\njulia> observable(r[1:2], Z⊗Z)\n-0.202499993925 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.ZALMSpinPair","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.ZALMSpinPair","text":"struct ZALMSpinPair <: QuantumSavory.StatesZoo.AbstractTwoQubitState\n\nFields:\n\nNs: mean photon number per mode of the cascaded source model\ngA: qubit initialization parameter on Alice's side\ngB: qubit initialization parameter on Bob's side\neAm: memory out-coupling efficiency for Alice's side (Allowed range: [0,1])\neBm: memory out-coupling efficiency for Bob's side (Allowed range: [0,1])\neAs: source out-coupling efficiency for Alice's side (Allowed range: [0,1])\neBs: source out-coupling efficiency for Bob's side (Allowed range: [0,1])\neD: detector efficiency (Allowed range: [0,1])\nPd: dark click probability per photonic mode on source's swap\nPdo1: dark click probability per photonic mode on Alice side swap\nPdo2: dark click probability per photonic mode on Bob side swap\nVisF: product of visibilities of all three  interferometers (Allowed range: [0,1])\nmetadata\n\nGenerate symbolic object for the normalized spin-spin density matrix for a  cascaded source swapped with emissive spin memories. The cascaded  source from papers (and Guha, 2022) and (and Englund, 2023)  is stored in spin memories as discussed in (Prajit Dhara and Guha, 2023).\n\njulia> using QuantumSavory.StatesZoo: ZALMSpinPair\n\njulia> r = Register(2);\n\njulia> initialize!(r[1:2], ZALMSpinPair(1e-3, 0.5, 0.5, 1, 1, 1, 1, 0.9, 1e-8, 1e-8, 1e-8, 0.99));\n\njulia> observable(r[1:2], Z⊗Z)\n-0.9999999911111112 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"API_StatesZoo/#QuantumSavory.StatesZoo.ZALMSpinPairW","page":"StatesZoo API","title":"QuantumSavory.StatesZoo.ZALMSpinPairW","text":"struct ZALMSpinPairW <: QuantumSavory.StatesZoo.AbstractTwoQubitState\n\nFields:\n\nNs: mean photon number per mode of the cascaded source model\ngA: qubit initialization parameter on Alice's side\ngB: qubit initialization parameter on Bob's side\neAm: memory out-coupling efficiency for Alice's side (Allowed range: [0,1])\neBm: memory out-coupling efficiency for Bob's side (Allowed range: [0,1])\neAs: source out-coupling efficiency for Alice's side (Allowed range: [0,1])\neBs: source out-coupling efficiency for Bob's side (Allowed range: [0,1])\neD: detector efficiency (Allowed range: [0,1])\nPd: dark click probability per photonic mode on source's swap\nPdo1: dark click probability per photonic mode on Alice side swap\nPdo2: dark click probability per photonic mode on Bob side swap\nVisF: product of visibilities of all three  interferometers (Allowed range: [0,1])\nmetadata\n\nGenerate symbolic object for the unnormalized spin-spin density matrix for a  cascaded source swapped with emissive spin memories. Since the matrix is 'weighted' by the probability for  success, it is suffixed with a W to distinguish it from the normalized object ZALMSpinPair. The cascaded  source from papers (and Guha, 2022) and (and Englund, 2023)  is stored in spin memories as discussed in (Prajit Dhara and Guha, 2023).\n\njulia> using QuantumSavory.StatesZoo: ZALMSpinPairW\n\njulia> r = Register(2);\n\njulia> initialize!(r[1:2], ZALMSpinPairW(1e-3, 0.5, 0.5, 1, 1, 1, 1, 0.9, 1e-8, 1e-8, 1e-8, 0.99));\n\njulia> observable(r[1:2], Z⊗Z)\n-6.290288032211147e-9 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [QuantumSavory]\nPrivate = false","category":"page"},{"location":"API/#QuantumSavory.W","page":"API","title":"QuantumSavory.W","text":"A wildcard instance for use with the tag querying functionality.\n\nSee also: query, tag!, ❓\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSavory.❓","page":"API","title":"QuantumSavory.❓","text":"A wildcard instance for use with the tag querying functionality.\n\nThis emoji can be inputted with the \\:question: emoji shortcut, or you can simply use the ASCII alternative W.\n\nSee also: query, tag!, W\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSavory.AbstractBackground","page":"API","title":"QuantumSavory.AbstractBackground","text":"An abstract type for the various background processes that might be inflicted upon a Register slot, e.g. decay, dephasing, etc.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.AmplitudeDamping","page":"API","title":"QuantumSavory.AmplitudeDamping","text":"A depolarization background.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.ConstantHamiltonianEvolution","page":"API","title":"QuantumSavory.ConstantHamiltonianEvolution","text":"Represents a Hamiltonian being applied for the given duration. See also NonInstantGate.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Depolarization","page":"API","title":"QuantumSavory.Depolarization","text":"A depolarization background.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.NonInstantGate","page":"API","title":"QuantumSavory.NonInstantGate","text":"Represents an gate applied instantaneously followed by a waiting period. See also ConstantHamiltonianEvolution.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.PauliNoise","page":"API","title":"QuantumSavory.PauliNoise","text":"A Pauli noise background.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.QuantumChannel","page":"API","title":"QuantumSavory.QuantumChannel","text":"Quantum channel for transmitting quantum states from one register to another.\n\nDelay and background noise processes are supported.\n\nThe function put! is used to take the contents of a RegRef and put it in the channel. That state can can then be received by a register (after a delay) using the take! method.\n\njulia> using QuantumSavory, ResumableFunctions, ConcurrentSim\n\njulia> regA = Register(1); regB = Register(1);\n\njulia> initialize!(regA[1], Z1);\n\njulia> sim = Simulation();\n\njulia> qc = QuantumChannel(sim, 10.0) # a delay of 10 units\nQuantumChannel{Qubit}(Qubit(), DelayQueue{Register}(ConcurrentSim.QueueStore{Register, Int64}, 10.0), nothing)\n\njulia> @resumable function alice_node(env, qc)\n            println(\"Putting Alice's qubit in the channel at \", now(env))\n            put!(qc, regA[1])\n        end\nalice_node (generic function with 1 method)\n\njulia> @resumable function bob_node(env, qc)\n            @yield take!(qc, regB[1])\n            println(\"Taking the qubit from alice at \", now(env))\n        end\nbob_node (generic function with 1 method)\n\njulia> @process alice_node(sim, qc); @process bob_node(sim, qc);\n\njulia> run(sim)\nPutting Alice's qubit in the channel at 0.0\nTaking the qubit from alice at 10.0\n\njulia> regA\nRegister with 1 slots: [ Qubit ]\n  Slots:\n    nothing\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.QuantumStateTrait","page":"API","title":"QuantumSavory.QuantumStateTrait","text":"An abstract type for the various types of states that can be given to Register slots, e.g. qubit, harmonic oscillator, etc.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Qubit","page":"API","title":"QuantumSavory.Qubit","text":"Specifies that a given register slot contains qubits.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Qumode","page":"API","title":"QuantumSavory.Qumode","text":"Specifies that a given register slot contains qumodes.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.RegRef","page":"API","title":"QuantumSavory.RegRef","text":"A reference to a Register slot, convenient for use with functions like apply!, etc.\n\njulia> r = Register(2)\n       initialize!(r[1], X₁)\n       observable(r[1], X)\n0.9999999999999998 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Register","page":"API","title":"QuantumSavory.Register","text":"The main data structure in QuantumSavory, used to represent a quantum register in an arbitrary formalism.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.RegisterNet","page":"API","title":"QuantumSavory.RegisterNet","text":"A network of Registers with convenient graph API as well.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.RegisterNet-Tuple{Graphs.SimpleGraphs.SimpleGraph, Any}","page":"API","title":"QuantumSavory.RegisterNet","text":"Construct a RegisterNet from a given list of Registers and a graph.\n\njulia> graph = grid([2,2]) # from Graphs.jl\n{4, 4} undirected simple Int64 graph\n\njulia> registers = [Register(1), Register(2), Register(1), Register(2)]\n4-element Vector{Register}:\n Register with 1 slots: [ Qubit ]\n  Slots:\n    nothing\n Register with 2 slots: [ Qubit | Qubit ]\n  Slots:\n    nothing\n    nothing\n Register with 1 slots: [ Qubit ]\n  Slots:\n    nothing\n Register with 2 slots: [ Qubit | Qubit ]\n  Slots:\n    nothing\n    nothing\n\njulia> net = RegisterNet(graph, registers)\nA network of 4 registers in a graph of 4 edges\n\n\njulia> neighbors(net, 1) # from Graphs.jl\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.RegisterNet-Tuple{Vector{Register}}","page":"API","title":"QuantumSavory.RegisterNet","text":"Construct a RegisterNet from a given list of Registers, defaulting to a chain topology.\n\njulia> net = RegisterNet([Register(2), Register(4), Register(2)])\nA network of 3 registers in a graph of 2 edges\n\njulia> neighbors(net,2) # from Graphs.jl\n2-element Vector{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.T1Decay","page":"API","title":"QuantumSavory.T1Decay","text":"A background describing the T₁ decay of a two-level system.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.T2Dephasing","page":"API","title":"QuantumSavory.T2Dephasing","text":"A background describing the T₂ dephasing of a two-level system.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Tag","page":"API","title":"QuantumSavory.Tag","text":"Tags are used to represent classical metadata describing the state (or even history) of nodes and their registers. The library allows the construction of custom tags using the Tag constructor. Currently tags are implemented as instances of a sum type and have fairly constrained structure. Most of them are constrained to contain only Symbol instances and integers.\n\nHere is an example of such a generic tag:\n\njulia> Tag(:sometagdescriptor, 1, 2, -3)\nSymbolIntIntInt(:sometagdescriptor, 1, 2, -3)::Tag\n\nA tag can have a custom DataType as first argument, in which case additional customability in printing is available. E.g. consider the [EntanglementHistory] tag used to track how pairs were entangled before a swap happened.\n\njulia> using QuantumSavory.ProtocolZoo: EntanglementHistory\n\njulia> Tag(EntanglementHistory, 1, 2, 3, 4, 5)\nWas entangled to 1.2, but swapped with .5 which was entangled to 3.4\n\nSee also: tag!, query\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumInterface.apply!-Tuple{Vector{Register}, Vector{Int64}, Any}","page":"API","title":"QuantumInterface.apply!","text":"Apply a given operation on the given set of register slots.\n\napply!([regA, regB], [slot1, slot2], Gates.CNOT) would apply a CNOT gate on the content of the given registers at the given slots. The appropriate representation of the gate is used, depending on the formalism under which a quantum state is stored in the given registers. The Hilbert spaces of the registers are automatically joined if necessary.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.traceout!-Tuple{Register, Int64}","page":"API","title":"QuantumInterface.traceout!","text":"Delete the given slot of the given register.\n\ntraceout!(reg, slot) would reset (perform a partial trace) over the given subsystem. The Hilbert space of the register gets automatically shrunk.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.channel-Tuple{RegisterNet, Vararg{Any}}","page":"API","title":"QuantumSavory.channel","text":"Get a handle to a classical channel between two registers.\n\nUsually used for sending classical messages between registers. It can be used for receiving as well, but a more convenient choice is messagebuffer, which is a message buffer listening to all channels sending to a given destination register.\n\njulia> net = RegisterNet([Register(2), Register(2), Register(2)]) # defaults to a chain topology\nA network of 3 registers in a graph of 2 edges\n\njulia> channel(net, 1=>2)\nConcurrentSim.DelayQueue{Tag}(ConcurrentSim.QueueStore{Tag, Int64}, 0.0)\n\njulia> channel(net, 1=>2)\nConcurrentSim.DelayQueue{Tag}(ConcurrentSim.QueueStore{Tag, Int64}, 0.0)\n\njulia> channel(net, 1=>2) === channel(net, net[1]=>net[2])\ntrue\n\nSee also: qchannel, messagebuffer\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.findfreeslot-Tuple{Register}","page":"API","title":"QuantumSavory.findfreeslot","text":"Find an empty unlocked slot in a given Register.\n\njulia> reg = Register(3); initialize!(reg[1], X); lock(reg[2]);\n\njulia> findfreeslot(reg) == reg[3]\ntrue\n\njulia> lock(findfreeslot(reg));\n\njulia> findfreeslot(reg) |> isnothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.initialize!-Tuple{Vector{Register}, Vector{Int64}, Any}","page":"API","title":"QuantumSavory.initialize!","text":"Set the state of a given set of registers.\n\ninitialize!([regA,regB], [slot1,slot2], state) would set the state of the given slots in the given registers to state. state can be any supported state representation, e.g., kets or density matrices from QuantumOptics.jl or tableaux from QuantumClifford.jl.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.messagebuffer-Tuple{RegisterNet, Int64}","page":"API","title":"QuantumSavory.messagebuffer","text":"Get a handle to a classical message buffer corresponding to all channels sending to a given destination register.\n\nSee also: channel\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.observable","page":"API","title":"QuantumSavory.observable","text":"Calculate the expectation value of a quantum observable on the given register and slot.\n\nobservable([regA, regB], [slot1, slot2], obs) would calculate the expectation value of the obs observable (using the appropriate formalism, depending on the state representation in the given registers).\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.project_traceout!","page":"API","title":"QuantumSavory.project_traceout!","text":"Perform a projective measurement on the given slot of the given register.\n\nproject_traceout!(reg, slot, [stateA, stateB]) performs a projective measurement, projecting on either stateA or stateB, returning the index of the subspace on which the projection happened. It assumes the list of possible states forms a basis for the Hilbert space. The Hilbert space of the register is automatically shrunk.\n\nA basis object can be specified on its own as well, e.g. project_traceout!(reg, slot, basis).\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.qchannel-Tuple{RegisterNet, Vararg{Any}}","page":"API","title":"QuantumSavory.qchannel","text":"Get a handle to a quantum channel between two registers.\n\njulia> net = RegisterNet([Register(2), Register(2), Register(2)]) # defaults to a chain topology\nA network of 3 registers in a graph of 2 edges\n\njulia> qchannel(net, 1=>2)\nQuantumChannel{Qubit}(Qubit(), ConcurrentSim.DelayQueue{Register}(ConcurrentSim.QueueStore{Register, Int64}, 0.0), nothing)\n\njulia> qchannel(net, 1=>2) === qchannel(net, net[1]=>net[2])\ntrue\n\nSee also: channel\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.query-Union{Tuple{allB}, Tuple{MessageBuffer, Tag}, Tuple{MessageBuffer, Tag, Val{allB}}} where allB","page":"API","title":"QuantumSavory.query","text":"query(\n    mb::MessageBuffer,\n    tag::Tag\n) -> Union{Nothing, NamedTuple{(:depth, :src, :tag), <:Tuple{Int64, Int64, Any}}}\nquery(\n    mb::MessageBuffer,\n    tag::Tag,\n    ::Val{allB}\n) -> Union{Nothing, NamedTuple{(:depth, :src, :tag), <:Tuple{Int64, Int64, Any}}}\n\n\nYou are advised to actually use querydelete!, not query when working with classical message buffers.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.query-Union{Tuple{allB}, Tuple{RegRef, Tag}, Tuple{RegRef, Tag, Val{allB}}} where allB","page":"API","title":"QuantumSavory.query","text":"query(\n    ref::RegRef,\n    tag::Tag;\n    ...\n) -> Union{Nothing, @NamedTuple{depth::Int64, tag::Tag}}\nquery(\n    ref::RegRef,\n    tag::Tag,\n    ::Val{allB};\n    filo\n) -> Union{Nothing, @NamedTuple{depth::Int64, tag::Tag}, Vector{@NamedTuple{depth::Int64, tag::Tag}}}\n\n\nA query on a single slot of a register.\n\njulia> r = Register(5);\n\njulia> tag!(r[2], :symbol, 2, 3);\n\njulia> query(r[2], :symbol, 2, 3)\n(depth = 1, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\njulia> query(r[3], :symbol, 2, 3) === nothing\ntrue\n\njulia> queryall(r[2], :symbol, 2, 3)\n1-element Vector{@NamedTuple{depth::Int64, tag::Tag}}:\n (depth = 1, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.query-Union{Tuple{allB}, Tuple{Register, Tag}, Tuple{Register, Tag, Val{allB}}} where allB","page":"API","title":"QuantumSavory.query","text":"query(\n    reg::Register,\n    tag::Tag;\n    ...\n) -> Union{Nothing, @NamedTuple{slot::RegRef, depth::Int64, tag::Tag}}\nquery(\n    reg::Register,\n    tag::Tag,\n    ::Val{allB};\n    locked,\n    assigned,\n    filo\n) -> Union{Nothing, @NamedTuple{slot::RegRef, depth::Int64, tag::Tag}, Vector{@NamedTuple{slot::RegRef, depth::Int64, tag::Tag}}}\n\n\nA query function searching for the first slot in a register that has a given tag.\n\nWildcards are supported (instances of Wildcard also available as the constants W or the emoji ❓ which can be entered as \\:question: in the REPL). Predicate functions are also supported (they have to be Int↦Bool functions). The order of query lookup can be specified in terms of FIFO or FILO and defaults to FILO if not specified. The keyword arguments locked and assigned can be used to check, respectively, whether the given slot is locked or whether it contains a quantum state. The keyword argument filo can be used to specify whether the search should be done in a FIFO or FILO order, defaulting to filo=true (i.e. a stack-like behavior).\n\njulia> r = Register(10);\n       tag!(r[1], :symbol, 2, 3);\n       tag!(r[2], :symbol, 4, 5);\n\n\njulia> query(r, :symbol, 4, 5)\n(slot = Slot 2, depth = 1, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n\njulia> lock(r[1]);\n\njulia> query(r, :symbol, 4, 5; locked=false) |> isnothing\nfalse\n\njulia> query(r, :symbol, ❓, 3)\n(slot = Slot 1, depth = 1, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n\njulia> query(r, :symbol, ❓, 3; assigned=true) |> isnothing\ntrue\n\njulia> query(r, :othersym, ❓, ❓) |> isnothing\ntrue\n\njulia> tag!(r[5], Int, 4, 5);\n\njulia> query(r, Float64, 4, 5) |> isnothing\ntrue\n\njulia> query(r, Int, 4, >(7)) |> isnothing\ntrue\n\njulia> query(r, Int, 4, <(7))\n(slot = Slot 5, depth = 1, tag = TypeIntInt(Int64, 4, 5)::Tag)\n\nSee also: queryall, tag!, W, ❓\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.queryall-Tuple","page":"API","title":"QuantumSavory.queryall","text":"queryall(args...; filo, kwargs...) -> Any\n\n\nA query function that returns all slots of a register that have a given tag, with support for predicates and wildcards.\n\njulia> r = Register(10);\n       tag!(r[1], :symbol, 2, 3);\n       tag!(r[2], :symbol, 4, 5);\n\njulia> queryall(r, :symbol, ❓, ❓)\n2-element Vector{@NamedTuple{slot::RegRef, depth::Int64, tag::Tag}}:\n (slot = Slot 1, depth = 1, tag = SymbolIntInt(:symbol, 2, 3)::Tag)\n (slot = Slot 2, depth = 1, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n\njulia> queryall(r, :symbol, ❓, >(4))\n1-element Vector{@NamedTuple{slot::RegRef, depth::Int64, tag::Tag}}:\n (slot = Slot 2, depth = 1, tag = SymbolIntInt(:symbol, 4, 5)::Tag)\n\njulia> queryall(r, :symbol, ❓, >(5))\n@NamedTuple{slot::RegRef, depth::Int64, tag::Tag}[]\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.querydelete!-Tuple{MessageBuffer, Vararg{Any}}","page":"API","title":"QuantumSavory.querydelete!","text":"querydelete!(\n    mb::MessageBuffer,\n    args...\n) -> Union{Nothing, @NamedTuple{src::Int64, tag::T} where T}\n\n\nA query for classical message buffers that also deletes the message out of the buffer.\n\njulia> net = RegisterNet([Register(3), Register(2)])\nA network of 2 registers in a graph of 1 edges\n\njulia> put!(channel(net, 1=>2), Tag(:my_tag));\n\njulia> put!(channel(net, 1=>2), Tag(:another_tag, 123, 456));\n\njulia> query(messagebuffer(net, 2), :my_tag)\n\njulia> run(get_time_tracker(net))\n\njulia> query(messagebuffer(net, 2), :my_tag)\n(depth = 1, src = 1, tag = Symbol(:my_tag)::Tag)\n\njulia> querydelete!(messagebuffer(net, 2), :my_tag)\n(src = 1, tag = Symbol(:my_tag)::Tag)\n\njulia> querydelete!(messagebuffer(net, 2), :my_tag) === nothing\ntrue\n\njulia> querydelete!(messagebuffer(net, 2), :another_tag, ❓, ❓)\n(src = 1, tag = SymbolIntInt(:another_tag, 123, 456)::Tag)\n\njulia> querydelete!(messagebuffer(net, 2), :another_tag, ❓, ❓) === nothing\ntrue\n\nYou can also wait on a message buffer for a message to arrive before running a query:\n\njulia> using ResumableFunctions; using ConcurrentSim;\n\njulia> net = RegisterNet([Register(3), Register(2), Register(3)])\nA network of 3 registers in a graph of 2 edges\n\njulia> env = get_time_tracker(net);\n\njulia> @resumable function receive_tags(env)\n           while true\n               mb = messagebuffer(net, 2)\n               @yield wait(mb)\n               msg = querydelete!(mb, :second_tag, ❓, ❓)\n               print(\"t=$(now(env)): query returns \")\n               if isnothing(msg)\n                   println(\"nothing\")\n               else\n                   println(\"$(msg.tag) received from node $(msg.src)\")\n               end\n           end\n       end\nreceive_tags (generic function with 1 method)\n\njulia> @resumable function send_tags(env)\n           @yield timeout(env, 1.0)\n           put!(channel(net, 1=>2), Tag(:my_tag))\n           @yield timeout(env, 2.0)\n           put!(channel(net, 3=>2), Tag(:second_tag, 123, 456))\n       end\nsend_tags (generic function with 1 method)\n\njulia> @process send_tags(env);\n\njulia> @process receive_tags(env);\n\njulia> run(env, 10)\nt=1.0: query returns nothing\nt=3.0: query returns SymbolIntInt(:second_tag, 123, 456)::Tag received from node 3\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.querydelete!-Tuple{RegRef, Vararg{Any}}","page":"API","title":"QuantumSavory.querydelete!","text":"querydelete!(ref::RegRef, args...) -> Union{Nothing, Tag}\n\n\nA query for RegRef that also deletes the tag from the tag list for the RegRef.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.registernetplot","page":"API","title":"QuantumSavory.registernetplot","text":"Draw the given register network.\n\nRequires a Makie backend be already imported.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.registernetplot!","page":"API","title":"QuantumSavory.registernetplot!","text":"Draw the given register network on a given Makie axis.\n\nRequires a Makie backend be already imported.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.registernetplot_axis","page":"API","title":"QuantumSavory.registernetplot_axis","text":"Draw the given register network on a given Makie subfigure and modify the axis with numerous visualization enhancements.\n\nRequires a Makie backend be already imported.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.resourceplot_axis","page":"API","title":"QuantumSavory.resourceplot_axis","text":"Draw the various resources and locks stored in the given meta-graph on a given Makie axis.\n\nRequires a Makie backend be already imported.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.subsystemcompose-Tuple{Union{Tuple{Vararg{Register}}, AbstractVector{<:Register}}, Any}","page":"API","title":"QuantumSavory.subsystemcompose","text":"Ensure that the all slots of the given registers are represented by one single state object, i.e. that all the register slots are tracked in the same Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.tag!-Tuple{RegRef, Tag}","page":"API","title":"QuantumSavory.tag!","text":"tag!(ref::RegRef, tag::Tag) -> Vector{Tag}\n\n\nAssign a tag to a slot in a register.\n\nIt returns the list of all currently present tags for that register.\n\nSee also: query, untag!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.untag!-Tuple{RegRef, Tag}","page":"API","title":"QuantumSavory.untag!","text":"untag!(ref::RegRef, tag::Tag) -> Vector{Tag}\n\n\nRemoves the first instance of tag from the list to tags associated with a RegRef in a Register\n\nIt returns the list of all currently present tags for that register.\n\nSee also: query, tag!\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.uptotime!","page":"API","title":"QuantumSavory.uptotime!","text":"Evolve all the states in a register to a given time, according to the various backgrounds that they might have.\n\njulia> reg = Register(2, T1Decay(1.0))\nRegister with 2 slots: [ Qubit | Qubit ]\n  Slots:\n    nothing\n    nothing\n\njulia> initialize!(reg[1], X₁)\n       observable(reg[1], σᶻ)\n0.0 + 0.0im\n\njulia> uptotime!(reg[1], 10)\n       observable(reg[1], Z)\n0.9999546000702374 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"register_interface/#Register-Interface","page":"Register Interface","title":"Register Interface","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"A rather diverse set of simulation libraries is used under the hood. Long term the Julia Quantum Science community might be able to converge to a common interface that would slightly simplify work between the libraries, but in the interim the Julia multimethod paradigm is sufficient. Below we describe the interface that enables us to operate with many distinct underlying simulators.","category":"page"},{"location":"register_interface/#initialize!","page":"Register Interface","title":"initialize!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Initialize the state of a register to a known state.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"initialize!","category":"page"},{"location":"register_interface/#QuantumSavory.initialize!-register_interface","page":"Register Interface","title":"QuantumSavory.initialize!","text":"Set the state of a given set of registers.\n\ninitialize!([regA,regB], [slot1,slot2], state) would set the state of the given slots in the given registers to state. state can be any supported state representation, e.g., kets or density matrices from QuantumOptics.jl or tableaux from QuantumClifford.jl.\n\n\n\n\n\n","category":"function"},{"location":"register_interface/#initialize!(refs::Vector{RegRef},-state;-time)","page":"Register Interface","title":"initialize!(refs::Vector{RegRef}, state; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Store a state in the given register slots.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"refs can also be Tuple{Vararg{RegRef, N}} or a single RegRef.","category":"page"},{"location":"register_interface/#initialize!(r::Vector{Register},-i::Vector{Int64},-state;-time)","page":"Register Interface","title":"initialize!(r::Vector{Register}, i::Vector{Int64}, state; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"r can also be a single Register.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"The accesstimes attributes of the slots are reset to the given time.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"If state<:Symbolic, then consistent_representation is used to choose an appropriate representation based on the AbstractRepresentation properties of the register slots. Then an express call is made to transform the symbolic object into the appropriate representation.","category":"page"},{"location":"register_interface/#initialize!(r::RegRef;-time)-and-initialize!(reg::Register,-i::Int64;-time)","page":"Register Interface","title":"initialize!(r::RegRef; time) and initialize!(reg::Register, i::Int64; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"When a state is not provided, a default one is calculated from newstate, depending on the register slot's QuantumStateTrait (e.g. qubit vs qumode) and AbstractRepresentation (e.g. ket vs tableaux).","category":"page"},{"location":"register_interface/#Interface-Overview","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>initialize!(refs::Vector{RegRef}, state; time)</code>\"]\n  B[\"<code>initialize!(r::Vector{Register}, i, state; time)</code>\"]\n  subgraph TOP [lower from registers to states]\n    direction LR\n  end\n  D{{\"<code>state<:Symbolic</code>\"}}\n  subgraph D1 [express state]\n    direction LR\n    d11[\"<code>consistent_representation(r,i,state)</code>\"]\n    d12[\"<code>express(state,repr)</code>\"]\n    d11 --> d12\n  end\n  D2([Store a state reference\\nin the register slots])\n  A --> B --> TOP --> D\n  D --Yes--> D1\n  D --No--> D2\n  D1 --> D2\n  Ap[\"<code>initialize!(::RegRef; time)</code>\"]\n  Bp[\"<code>initialize!(::Register, i; time)</code>\"]\n  Cp[\"<code>newstate(::QuantumStateTrait, ::AbstractRepresentation)</code>\"]\n  subgraph TOPp [lower from registers to states]\n    direction LR\n  end\n  Ap --> Bp --> TOPp --> Cp ---> D2\n</div>","category":"page"},{"location":"register_interface/#apply!","page":"Register Interface","title":"apply!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Apply a quantum operation to a register.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"apply!","category":"page"},{"location":"register_interface/#QuantumInterface.apply!-register_interface","page":"Register Interface","title":"QuantumInterface.apply!","text":"Apply a given operation on the given set of register slots.\n\napply!([regA, regB], [slot1, slot2], Gates.CNOT) would apply a CNOT gate on the content of the given registers at the given slots. The appropriate representation of the gate is used, depending on the formalism under which a quantum state is stored in the given registers. The Hilbert spaces of the registers are automatically joined if necessary.\n\n\n\n\n\n","category":"function"},{"location":"register_interface/#apply!(refs::Vector{RegRef},-operation;-time)","page":"Register Interface","title":"apply!(refs::Vector{RegRef}, operation; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Applying an operation to the qubits referred to by the sequence of RegRefs at a specified time.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"refs can also be Tuple{Vararg{RegRef, N}} or a single RegRef.","category":"page"},{"location":"register_interface/#apply!(regs::Vector{Register},-indices,-operation;-time)","page":"Register Interface","title":"apply!(regs::Vector{Register}, indices, operation; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"indices refers to the slots inside of the given regs.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls uptotime! in order to update any AbstractBackground properties.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls subsystemcompose in order to make one big state. Then goes to apply!(state, subsystem_indices, operation; time).","category":"page"},{"location":"register_interface/#apply!(state,-subsystem_indices,-operation;-time)","page":"Register Interface","title":"apply!(state, subsystem_indices, operation; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"subsystem_indices refers to subsystems in state.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"If operation<:Symbolic, then express(operation, repr, ::UseAsOperation) is used to convert the symbolic operation into something workable for the given state type. repr is chosen by dispatch on state.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"warning: Limitations of symbolic-to-explicit conversion\nCurrently, the decision of how to convert a symbolic operation is based only on the state on which the operation would act. It can not be modified by the AbstractRepresentation properties of the Registers containing the state.","category":"page"},{"location":"register_interface/#Interface-Overview-2","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>apply!(refs::Vector{RegRef}, operation; time)</code>\"]\n  B[\"<code>apply!(regs::Vector{Register}, indices, operation; time)</code>\"]\n  subgraph TOP [lower from registers to states]\n    direction LR\n    B1[\"<code>uptotime!</code>\"]\n    B2[\"<code>subsystemcompose</code>\"]\n    B1 --> B2\n  end\n  C[\"<code>apply!(state, subsystem_indices, operation; time)</code>\"]\n  D{{\"<code>operation<:Symbolic</code>\"}}\n  D1[\"<code>express(operation, repr, ::UseAsOperation)</code>\"]\n  D2([Dispatch on state to low level implementation<br>in an independent library])\n  A --> B --> TOP --> C --> D\n  D --Yes--> D1\n  D --No--> D2\n  D1 --> D2\n</div>","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"warning: Limitations of symbolic-to-explicit conversion\nAs mentioned above, converting from symbolic to explicit representation for the operation is dependent only on the type of state, i.e. by the time the conversion is done, no knowledge of the register and its properties are kept (in particular its preferred representation is not considered).","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"info: Short-circuiting the `express` dispatch\nYou can add a custom dispatch that skips the express functionality by defining a method apply!(state::YourStateType, indices, operation<:Symbolic{AbstractOperator}). This would preemt the default apply!(state, indices, operation<:Symbolic{AbstractOperator}) containing the express logic. The drawback is that this would also skip the memoization employed by express.","category":"page"},{"location":"register_interface/#observable","page":"Register Interface","title":"observable","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Measure a quantum observable. The dispatch down the call three is very similar to the one for apply!.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"observable","category":"page"},{"location":"register_interface/#QuantumSavory.observable-register_interface","page":"Register Interface","title":"QuantumSavory.observable","text":"Calculate the expectation value of a quantum observable on the given register and slot.\n\nobservable([regA, regB], [slot1, slot2], obs) would calculate the expectation value of the obs observable (using the appropriate formalism, depending on the state representation in the given registers).\n\n\n\n\n\n","category":"function"},{"location":"register_interface/#observable(refs::Tuple{Vararg{RegRef,-N}},-obs,-somethingnothing;-time)","page":"Register Interface","title":"observable(refs::Tuple{Vararg{RegRef, N}}, obs, something=nothing; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calculate the value of an observable on the state in the sequence of RegRefs at a specified time. If these registers are not instantiated, return something.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"refs can also be Tuple{Vararg{RegRef, N}} or a single RegRef.","category":"page"},{"location":"register_interface/#observable(regs::Vector{Register},-indices,-obs,-somethingnothing;-time)","page":"Register Interface","title":"observable(regs::Vector{Register}, indices, obs, something=nothing; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"indices refers to the slots inside of the given regs.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls uptotime! in order to update any AbstractBackground properties.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls subsystemcompose in order to make one big state. Then goes to observable(state, subsystem_indices, obs; time).","category":"page"},{"location":"register_interface/#observable(state,-subsystem_indices,-obs;-time)","page":"Register Interface","title":"observable(state, subsystem_indices, obs; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"subsystem_indicesrefers to subsystems instate`.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"If operation<:Symbolic, then an express(obs, repr, ::UseAsObservable) call is used to convert the symbolic obs into something workable for the given state type. repr is chosen by dispatch on state.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"warning: Limitations of symbolic-to-explicit conversion\nSimilar to the limitations faced by apply!","category":"page"},{"location":"register_interface/#Interface-Overview-3","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>observable(refs::Vector{RegRef}, obs, something=nothing; time)</code>\"]\n  B[\"<code>observable(regs::Vector{Register}, indices, obs, something=nothing; time)</code>\"]\n  subgraph TOP [lower from registers to states]\n    direction LR\n    B1[\"<code>uptotime!</code>\"]\n    B2[\"<code>subsystemcompose</code>\"]\n    B1 --> B2\n  end\n  C[\"<code>observable(state, subsystem_indices, obs; time)</code>\"]\n  D{{\"<code>obs<:Symbolic</code>\"}}\n  D1[\"<code>express(obs, repr, ::UseAsObservable)</code>\"]\n  D2([Dispatch on state to low level implementation<br>in an independent library])\n  A --> B --> TOP --> C --> D\n  D --Yes--> D1\n  D --No--> D2\n  D1 --> D2\n</div>","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"info: Short-circuiting the `express` dispatch\nSimilarly to the case with apply!, you can skips the express functionality by defining a method observable(state::YourStateType, indices, obs<:Symbolic{AbstractOperator}).","category":"page"},{"location":"register_interface/#project_traceout!","page":"Register Interface","title":"project_traceout!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"project_traceout!","category":"page"},{"location":"register_interface/#QuantumSavory.project_traceout!-register_interface","page":"Register Interface","title":"QuantumSavory.project_traceout!","text":"Perform a projective measurement on the given slot of the given register.\n\nproject_traceout!(reg, slot, [stateA, stateB]) performs a projective measurement, projecting on either stateA or stateB, returning the index of the subspace on which the projection happened. It assumes the list of possible states forms a basis for the Hilbert space. The Hilbert space of the register is automatically shrunk.\n\nA basis object can be specified on its own as well, e.g. project_traceout!(reg, slot, basis).\n\n\n\n\n\n","category":"function"},{"location":"register_interface/#project_traceout!(r::RegRef,-basis;-time)","page":"Register Interface","title":"project_traceout!(r::RegRef, basis; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Project the state in RegRef on basis at a specified time. basis can be a Vector or Tuple of basis states, or it can be a Matrix like Z or X.","category":"page"},{"location":"register_interface/#project_traceout(reg::Register,-i::Int,-basis;-time)","page":"Register Interface","title":"project_traceout(reg::Register, i::Int, basis; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Project the state in the slot in index i of Register on basis at a specified time.  basis can be a Vector or Tuple of basis states, or it can be a Matrix like Z or X.","category":"page"},{"location":"register_interface/#project_traceout!(f,-r::RegRef,-basis;-time)","page":"Register Interface","title":"project_traceout!(f, r::RegRef, basis; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Project the state in RegRef on basis at a specified time and apply function f on the projected basis state. basis can be a Vector or Tuple of basis states, or it can be a Matrix like Z or X.","category":"page"},{"location":"register_interface/#project_traceout!(f,-reg::Register,-i::Int,-basis;-time)","page":"Register Interface","title":"project_traceout!(f, reg::Register, i::Int, basis; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Project the state in the slot in index i of Register on basis at a specified time and apply function f on the projected basis state. basis can be a Vector or Tuple of basis states, or it can be a Matrix like Z or X. Lowers the representation from registers to states.","category":"page"},{"location":"register_interface/#project_traceout!(state,-stateindex,-basis::Symbolic{AbstractOperator})-and-basis::AbstractVecOrTuple{:Symbolic{AbstractKet}}","page":"Register Interface","title":"project_traceout!(state, stateindex, basis::Symbolic{AbstractOperator}) and basis::AbstractVecOrTuple{<:Symbolic{AbstractKet}}","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Backend implementations. If basis is an operator, call eigvecs to convert it into a matrix whose columns are the eigenvectors of the operator. If basis is a Vector or Tuple of Symbolic basis states, call express to convert it to the necessary representation.","category":"page"},{"location":"register_interface/#Interface-Overview-4","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>project_traceout!(r::RegRef, basis; time)</code>\"]\n  B[\"<code>project_traceout!(reg::Register, i::Int, basis; time)</code>\"]\n  subgraph TOP [lower from registers to states]\n    direction LR\n    D1[\"<code>reg.staterefs[i].state[]</code>\"]\n    D2[\"<code>reg.stateindices[i]</code>\"]\n  end\n  E1[\"<code>basis::Symbolic{AbstractOperator}</code>\"]\n  F1[\"<code>eigvecs(basis)</code>\"]\n  E2[\"<code>basis::Base.AbstractVecOrTuple{<:Symbolic{AbstractKet}}</code>\"]\n  F2[\"<code>express.(basis)</code>\"]\n  G([Dispatch on state to low level implementation<br>in an independent library])\n  A --> B --> TOP\n  TOP --> E1 --> F1 --> G\n  TOP --> E2 --> F2 --> G\n</div>","category":"page"},{"location":"register_interface/#traceout!","page":"Register Interface","title":"traceout!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"traceout!","category":"page"},{"location":"register_interface/#QuantumInterface.traceout!-register_interface","page":"Register Interface","title":"QuantumInterface.traceout!","text":"Delete the given slot of the given register.\n\ntraceout!(reg, slot) would reset (perform a partial trace) over the given subsystem. The Hilbert space of the register gets automatically shrunk.\n\n\n\n\n\n","category":"function"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Perform a partial trace over a part of the system (i.e. discard a part of the system).","category":"page"},{"location":"register_interface/#traceout!(r::RegRef)","page":"Register Interface","title":"traceout!(r::RegRef)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Partial trace over a particular register reference.","category":"page"},{"location":"register_interface/#traceout!(r::Register,-i::Int)","page":"Register Interface","title":"traceout!(r::Register, i::Int)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Partial trace over slot i of register r. Calls down to the state reference stored in that particular register.","category":"page"},{"location":"register_interface/#traceout!(s::StateRef,-i::Int)","page":"Register Interface","title":"traceout!(s::StateRef, i::Int)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Partial trace over subsystem i of state referenced by s.","category":"page"},{"location":"register_interface/#Interface-Overview-5","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>traceout!(r::RegRef)</code>\"]\n  B[\"<code>traceout!(r::Register, i::Int)</code>\"]\n  C[\"<code>traceout!(r::StateRef, i::Int)</code>\"]\n  D([Dispatch on state to low level implementation<br>in an independent library])\n  A --> B --> C --> D\n</div>","category":"page"},{"location":"register_interface/#uptotime!","page":"Register Interface","title":"uptotime!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"uptotime!","category":"page"},{"location":"register_interface/#QuantumSavory.uptotime!-register_interface","page":"Register Interface","title":"QuantumSavory.uptotime!","text":"Evolve all the states in a register to a given time, according to the various backgrounds that they might have.\n\njulia> reg = Register(2, T1Decay(1.0))\nRegister with 2 slots: [ Qubit | Qubit ]\n  Slots:\n    nothing\n    nothing\n\njulia> initialize!(reg[1], X₁)\n       observable(reg[1], σᶻ)\n0.0 + 0.0im\n\njulia> uptotime!(reg[1], 10)\n       observable(reg[1], Z)\n0.9999546000702374 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"register_interface/#uptotime!(ref::RegRef,-now)","page":"Register Interface","title":"uptotime!(ref::RegRef, now)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Evolve the state in a RegRef upto a given time now","category":"page"},{"location":"register_interface/#uptotime!(refs::Base.AbstractVecOrTuple{RegRef},-now)","page":"Register Interface","title":"uptotime!(refs::Base.AbstractVecOrTuple{RegRef}, now)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Evolve the state represented by the given RegRefs upto a time now","category":"page"},{"location":"register_interface/#uptotime!(registers,-indices::Base.AbstractVecOrTuple{Int},-now)","page":"Register Interface","title":"uptotime!(registers, indices::Base.AbstractVecOrTuple{Int}, now)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Evolve the state of all the given registers at the slots represented by indices upto a time now","category":"page"},{"location":"register_interface/#uptotime!(stateref::StateRef,-idx::Int,-background,-Δt)","page":"Register Interface","title":"uptotime!(stateref::StateRef, idx::Int, background, Δt)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Evolve a StateRef at index idx with given background and Δt","category":"page"},{"location":"register_interface/#uptotime!(state,-indices::Base.AbstractVecOrTuple{Int},-backgrounds,-Δt)","page":"Register Interface","title":"uptotime!(state, indices::Base.AbstractVecOrTuple{Int}, backgrounds, Δt)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Evolve state at indices given backgrounds and Δt","category":"page"},{"location":"register_interface/#uptotime!(state::QuantumClifford.MixedDestabilizer,-idx::Int,-background,-Δt)","page":"Register Interface","title":"uptotime!(state::QuantumClifford.MixedDestabilizer, idx::Int, background, Δt)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Low level implementation to compute the result of uptotime! for states using Clifford representation","category":"page"},{"location":"register_interface/#uptotime!(state::StateVector,-idx::Int,-background,-Δt)","page":"Register Interface","title":"uptotime!(state::StateVector, idx::Int, background, Δt)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Low level implementation to compute the result of uptotime! for states using Ket representation. The state in ket representation is converted to a density matrix before calling the uptotime! for final computation.","category":"page"},{"location":"register_interface/#uptotime!(state::Operator,-idx::Int,-background,-Δt)","page":"Register Interface","title":"uptotime!(state::Operator, idx::Int, background, Δt)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Low level implementation to compute the result of uptotime! for Operator","category":"page"},{"location":"register_interface/#Interface-Overview-6","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>uptotime!(ref::RegRef, now)</code>\"]\n  B[\"<code>uptotime!(refs::Base.AbstractVecOrTuple{RegRef}, now)</code>\"]\n  C[\"<code>uptotime!(registers, indices::Base.AbstractVecOrTuple{Int}, now)</code>\"]\n  C1[\"lower from registers to states\"]\n  D[\"<code>uptotime!(stateref::StateRef, idx::Int, background, Δt)</code>\"]\n  E[\"<code>uptotime!(state, indices::Base.AbstractVecOrTuple{Int}, backgrounds, Δt)</code>\"]\n  A --> C\n  B --> C\n  C --> C1\n  C1 --> E\n  D --> E\n  F([Dispatch on state to low level implementation<br>in an independent library])\n  E --> F\n</div>","category":"page"},{"location":"register_interface/#swap!","page":"Register Interface","title":"swap!","text":"","category":"section"},{"location":"register_interface/#swap!(r1::RegRef,-r2::RegRef)","page":"Register Interface","title":"swap!(r1::RegRef, r2::RegRef)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Swap the state of the given RegRefs","category":"page"},{"location":"register_interface/#swap!(reg1::Register,-reg2::Register,-i1::Int,-i2::Int)","page":"Register Interface","title":"swap!(reg1::Register, reg2::Register, i1::Int, i2::Int)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Swap the state stored in the two Registers at slots i1 and i2 respectively","category":"page"},{"location":"register_interface/#Interface-Overview-7","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>swap!(r1::RegRef, r2::RegRef)</code>\"]\n  B[\"<code>swap!(reg1::Register, reg2::Register, i1::Int, i2::Int)</code>\"]\n  A --> B\n</div>","category":"page"},{"location":"register_interface/#overwritetime!","page":"Register Interface","title":"overwritetime!","text":"","category":"section"},{"location":"register_interface/#overwritetime!(refs::Base.AbstractVecOrTuple{RegRef},-now)","page":"Register Interface","title":"overwritetime!(refs::Base.AbstractVecOrTuple{RegRef}, now)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Overwrite the time of the simulation for the given references to now","category":"page"},{"location":"register_interface/#overwritetime!(registers,-indices,-now)","page":"Register Interface","title":"overwritetime!(registers, indices, now)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Overwrite the time of the simulation for the given registers at indices to now","category":"page"},{"location":"register_interface/#Interface-Overview-8","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>overwritetime!(refs::Base.AbstractVecOrTuple{RegRef}, now)</code>\"]\n  B[\"<code>overwritetime!(registers, indices, now)</code>\"]\n  A --> B\n</div>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/#Clifford-Simulations-of-First-Generation-Quantum-Repeater","page":"1st-gen Repeater (Clifford formalism)","title":"Clifford Simulations of First Generation Quantum Repeater","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"Here we will simulate a quantum repeater by employing a noisy Clifford circuit simulator.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"Be sure to check out the more detailed tutorial on wavefunction simulations of First Generation Quantum Repeater before proceeding with this one.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"The changes we need to perform to the code are incredibly small. We only change the way the initial states of the entangled pairs are set, without changing any of the code implementing the swapping and purification steps.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"For the wavefunction simulator we had used:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"const perfect_pair = (Z1⊗Z1 + Z2⊗Z2) / sqrt(2)\nconst perfect_pair_dm = SProjector(perfect_pair)\nconst mixed_dm = MixedState(perfect_pair_dm)\nnoisy_pair_func(F) = F*perfect_pair_dm + (1-F)*mixed_dm","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"Here we switch to tableau representation for our initial states. Converting from tableaux to kets or density matrices is cheap and automated, but the reverse direction is difficult, thus we give the initial state explicitly. You can actually use the tableau definition below for all types of simulations (tableau, ket, others).","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"# a tableau corresponding to a Bell pair\nconst tableau = S\"XX\n                  ZZ\"\nconst stab_perfect_pair = StabilizerState(tableau)\nconst stab_perfect_pair_dm = SProjector(stab_perfect_pair)\nstab_noisy_pair_func(F) = F*stab_perfect_pair_dm + (1-F)*mixed_dm","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"We then use that in the entangler setup (the same way we used a similar function when we were doing wavefunction simulations), simply by selecting the appropriate default representation type (CliffordRepr instead of QuantumOpticsRepr):","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"# excerpt from `firstgenrepeater-firstgenrepeater-clifford.jl`\nsim, network = simulation_setup(sizes, T2; representation = CliffordRepr)\nnoisy_pair = stab_noisy_pair_func(F)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"The symbolic-expression-to-density-matrix conversion is cached inside of the symbolic expression noisy_pair, so that it does not need to be recomputed each time. In particular, given that this arbitrary mixed state can not be represented as a tableau, rather as a probability distribution over different tableaux, the cache provides for efficient random sampling.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"note: You can use tableaux states in the Schroedinger simulations.\nConverting from tableaux to kets or density matrices is cheap and automated, so we could have just as well used stab_noisy_pair_func even with the Schroedinger simulations of QuantumOpticsRepr.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/#Simulation-Trace","page":"1st-gen Repeater (Clifford formalism)","title":"Simulation Trace","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"Similarly to the wavefunction simulations from the previous tutorial, here we can see how the various observables evolve over time for a Clifford-base simulation. Notice that unlike the wavefunction simulation, the results are very discrete, and we will certainly need to average over multiple repeated simulations of this trajectory.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"<video src=\"../firstgenrepeater-08.clifford.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/#Comparison-Against-a-Wavefunction-based-Simulations","page":"1st-gen Repeater (Clifford formalism)","title":"Comparison Against a Wavefunction-based Simulations","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"We can run the either simulation multiple times in order to compare the results from the wavefunction and tableau-based simulations:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"(Image: Comparison Against a Wavefunction-based Simulations)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/#Full-Code","page":"1st-gen Repeater (Clifford formalism)","title":"Full Code","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"The entirety of the code necessary for reproducing these results is in the examples folder of the QuantumSavory.jl repository.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#First-Generation-Quantum-Repeater","page":"1st-gen Repeater","title":"First Generation Quantum Repeater","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"There is a convenient classification of quantum repeaters by their logical capabilities[1]. The first, simplest, generation of quantum repeaters involves the generation of physical (unencoded) entangled qubits between neighboring nodes, followed by entanglement swap and entanglement purification operation. No error correcting codes are employed and establishing of a link is a probabilistic process.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"[1]: (Muralidharan et al., 2016)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"We will build a simplistic simulator for such a network.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"We will employ Schroedinger representation (Schroedinger, Lindblad, and other master equation will be used behind the scenes, but we will not need to work at that low level);\nWe will consider a chain of quantum repeater nodes of various sizes (number of qubits);\nThe goal would be to entangle the extreme ends of the chain:\nBy directly entangling nearest neighbors;\nFollowed by entanglement swaps to extend the links;\nAnd entanglement purification to increase the quality of the links.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"For organizing the simulation and simplifying the digital and analog quantum dynamics, we will use the star of QuantumSavory.jl, namely the Register data structure. For a convenient data structure to track per-node metadata in a graph (network) we will use the RegisterNet structure.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Moreover, behind the scenes QuantumSavory.jl will use:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"ConcurrentSim.jl for discrete event scheduling and simulation;\nMakie.jl together with our custom plotting recipes for visualizations;\nQuantumOptics.jl for low-level quantum states.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The user does not need to know much about these libraries, but if they wish, it is easy for them to peek behind the scenes and customize their use.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The full simulation script is available at the bottom.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#The-Underlying-Data-Structures","page":"1st-gen Repeater","title":"The Underlying Data Structures","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"While the quantum dynamics would be encapsulated in a Register data structure, it is convenient to also set up structures that track the overall topology and events on the network. Our preferred way to do that is to use the RegisterNet structure, which lets you construct a graph and attach arbitrary meta-data to each edge and vertex. While this is not required for using QuantumSavory.jl, it is convenient, and we provide a lot of debugging tools that assume the use of this structure.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Given an array of register sizes, e.g. sizes = [2,3,4,3,2], we will create a linear graph, where each node has the prescribed number of qubits, e.g.: ","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"(Image: An image of 5 quantum registers)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The RegisterNet would contain, on each node:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"a Register of the appropriate size;\nan array of tuples keeping track of whom each qubit in the register is entangled to (as the :enttracker property);\nan array of locks (from ConcurrentSim.jl) keeping track of whether a process is happening on the given qubit (as the :locks property).","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"note: Note\nTo see how to visualize these data structures as the simulation is proceeding, consult the Visualizations page.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"note: Note\nTo see how to define imperfections, noise processes, and background events, consult the Sub-system Properties page.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to expand and see code used to set up the meta-graph and registers</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"\"\"\"Creates the datastructures representing the simulated network\"\"\"\nfunction simulation_setup(\n    sizes, # Array giving the number of qubits in each node\n    T2 # T2 dephasing times for the qubits\n    ;\n    representation = QuantumOpticsRepr # Representation to use for the qubits\n    )\n    R = length(sizes) # Number of registers\n\n    # A scheduler datastructure for the discrete event simulation\n    sim = Simulation()\n\n    # All of the quantum register we will be simulating\n    registers = Register[]\n    for s in sizes\n        traits = [Qubit() for _ in 1:s]\n        repr = [representation() for _ in 1:s]\n        bg = [T2Dephasing(T2) for _ in 1:s]\n        push!(registers, Register(traits,repr,bg))\n    end\n\n    # A graph structure defining the connectivity among registers\n    # It is not necessary to use such a structure, however, it is a convenient way to\n    # store data about the simulation (and we have created helper plotting functions\n    # expecting such a structure).\n    graph = grid([R])\n    network = RegisterNet(graph, registers) # A graphs with extra \"meta data\"\n\n    # Add a register datastructures and event locks to each node.\n    for v in vertices(network)\n        # Create an array specifying whether a qubit is entangled with another qubit\n        network[v,:enttrackers] = Any[nothing for i in 1:sizes[v]]\n        # Create an array of locks, telling us whether a qubit is undergoing an operation\n        network[v,:locks] = [Resource(sim,1) for i in 1:sizes[v]]\n    end\n\n    sim, network\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Entangler","page":"1st-gen Repeater","title":"Entangler","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The first set of processes we need is the \"entanglers\" that enable nearest-neighbor entanglement generation:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-02.entangler.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"They run in parallel on each edge of the graph, set up by an invocation similar to the following:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"for (;src, dst) in edges(network)\n    @process entangler(sim, network, src, dst, ...)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"As seen in the following flow chart, the entangler repeatedly checks for available pairs of unused qubit slots and attempts to entangle them.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<div class=\"mermaid\">\ngraph LR\n    A[Entangler starts<br>on node A and B]\n    B{Are there<br>unused qubits on<br>node A and B?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>available qubits])\n    D --> E[Run entanglement<br>generation]\n    E --> F[Write down<br>who was entangled]\n    F --> G([Unlock the<br>qubits])\n    G --> B\n</div>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to see the implementation of the Entangler process</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"@resumable function entangler(\n    sim::Environment,   # The scheduler for all simulation events\n    network,            # The graph of quantum nodes\n    nodea, nodeb,       # The two nodes which we will be entangling\n    noisy_pair,         # A raw entangled pair\n    entangler_wait_time,# The wait time in case all qubits are \"busy\"\n    entangler_busy_time # How long it takes to establish entanglement\n    )\n    while true\n        ia = findfreequbit(network, nodea)\n        ib = findfreequbit(network, nodeb)\n        if isnothing(ia) || isnothing(ib)\n            @yield timeout(sim, entangler_wait_time)\n            continue\n        end\n        locka = network[nodea,:locks][ia]\n        lockb = network[nodeb,:locks][ib]\n        @yield request(locka) & request(lockb)\n        registera = network[nodea]\n        registerb = network[nodeb]\n        @yield timeout(sim, entangler_busy_time)\n        initialize!((registera[ia],registerb[ib]),noisy_pair; time=now(sim))\n        network[nodea,:enttrackers][ia] = (node=nodeb,slot=ib)\n        network[nodeb,:enttrackers][ib] = (node=nodea,slot=ia)\n        @simlog sim \"entangled node $(nodea):$(ia) and node $(nodeb):$(ib)\"\n        release(locka)\n        release(lockb)\n    end\nend\n\n\"\"\"Find an uninitialized unlocked qubit on a given node\"\"\"\nfunction findfreequbit(network, node)\n    register = network[node]\n    locks = network[node,:locks]\n    regsize = nsubsystems(register)\n    findfirst(i->!isassigned(register,i) & isfree(locks[i]), 1:regsize)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Notice that the entangler uses the initialize! function to set the state of certain registers, but we never need to explicitly construct the numerical representation of these kets. Rather, we use the symbolic algebra system of QuantumSymbolics.jl, and let the simulator automatically convert the symbolic expression into numerical density matrices. This conversion was governed by the choice of representation = QuantumOpticsRepr. Here is one possible symbolic definition of a noisy_pair:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"const perfect_pair = (Z1⊗Z1 + Z2⊗Z2) / sqrt(2)\nconst perfect_pair_dm = SProjector(perfect_pair)\nconst mixed_dm = MixedState(perfect_pair_dm)\nnoisy_pair_func(F) = F*perfect_pair_dm + (1-F)*mixed_dm","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The symbolic-expression-to-density-matrix conversion is cached inside of the symbolic expression, so that it does not need to be recomputed each time.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Swapper","page":"1st-gen Repeater","title":"Swapper","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Once we have the raw nearest-neighbor entanglement, we can proceed with swap operations that link two Bell pairs that share one common node into a longer Bell pair:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-03.swapper.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"They run in parallel on each vertex of the graph, set up by an invocation similar to the following:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"for node in vertices(network)\n    @process swapper(sim, network, node, ...)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The Swapper working on a given node simply checks whether there are any qubits on that node that are entangled with other nodes, both on the left and right of the current node. If such qubits are found, the entanglement swap operation is performed on them, as seen in this flowchart.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<div class=\"mermaid\">\ngraph LR\n    A[Swapper starts<br>on node A]\n    B{Are there<br>qubits entangled with A<br>both on the left and right<br>of A?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>local qubits])\n    D --> E[Run entanglement<br>swapping]\n    E --> F[Write down<br>how the entanglement<br>was redistributed]\n    F --> G([Unlock and erase<br>the local qubits])\n    G --> B\n</div>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The entanglement swap operation is performed through the following simple circuit, which entangles the two local qubits belonging to two separate Bell pairs, and then measures them:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<img alt=\"Entanglement swapping circuit\" src=\"../firstgenrepeater-04.swapcircuit.png\" style=\"max-width:50%\">\n<!--\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CNOT(2, 3),\n Measurement(\"X\", 2, 1),\n ClassicalDecision(\"Z\", 1, 1),\n Measurement(\"Z\", 3, 2),\n ClassicalDecision(\"X\", 4, 2)]\n -->","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The code implementing such a circuit looks like the following (where localslot denotes register slots on which swapping happens, and remslot denotes remote registers on the left and right):","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"apply!((localslot1, localslot2), CNOT; time=time)\nxmeas = project_traceout!(localslot1, X)\nzmeas = project_traceout!(localslot2, Z)\nif xmeas==2\n    apply!(remslot1, Z)\nend\nif zmeas==2\n    apply!(remslot2, X)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to see the implementation of the Swapper process</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"@resumable function swapper(\n    sim::Environment, # The scheduler for all simulation events\n    network,          # The graph of quantum nodes\n    node,             # The node on which the swapper works\n    swapper_wait_time,# The wait time in case there are no available qubits for swapping\n    swapper_busy_time # How long it takes to perform the swap\n    )\n    while true\n        qubit_pair = findswapablequbits(network,node)\n        if isnothing(qubit_pair)\n            @yield timeout(sim, swapper_wait_time)\n            continue\n        end\n        q1, q2 = qubit_pair\n        locks = network[node, :locks][[q1,q2]]\n        @yield mapreduce(request, &, locks)\n        reg = network[node]\n        @yield timeout(sim, swapper_busy_time)\n        node1 = network[node,:enttrackers][q1]\n        reg1 = network[node1.node]\n        node2 = network[node,:enttrackers][q2]\n        reg2 = network[node2.node]\n        swapcircuit(reg[q1], reg[q2], reg1[node1.slot], reg2[node2.slot]; time=now(sim))\n        network[node1.node,:enttrackers][node1.slot] = node2\n        network[node2.node,:enttrackers][node2.slot] = node1\n        network[node,:enttrackers][q1] = nothing\n        network[node,:enttrackers][q2] = nothing\n        @simlog sim \"swap at $(node):$(q1)&$(q2) connecting $(node1) and $(node2)\"\n        release.(locks)\n    end\nend\n\nfunction swapcircuit(localslot1, localslot2, remslot1, remslot2; time=nothing)\n    apply!((localslot1, localslot2), CNOT; time=time)\n    xmeas = project_traceout!(localslot1, X)\n    zmeas = project_traceout!(localslot2, Z)\n    if xmeas==2\n        apply!(remslot1, Z)\n    end\n    if zmeas==2\n        apply!(remslot2, X)\n    end\nend\n\nfunction findswapablequbits(network,node)\n    enttrackers = network[node,:enttrackers]\n    locks = network[node,:locks]\n    left_nodes  = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node<node && isfree(locks[i])]\n    isempty(left_nodes)  && return nothing\n    right_nodes = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node>node && isfree(locks[i])]\n    isempty(right_nodes) && return nothing\n    _, farthest_left  = findmin(n->n.node, left_nodes)\n    _, farthest_right = findmax(n->n.node, right_nodes)\n    return left_nodes[farthest_left].i, right_nodes[farthest_right].i\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Purifier","page":"1st-gen Repeater","title":"Purifier","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Last but not least, there is the Purifier that searches for pairs of nodes that share more than one Bell pair. On such nodes a purification procedure can be performed:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-05.purifier.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"As you can see, not all purification attempts succeed. On some occasions there is a failure and both pairs get discarded as faulty. Each Purifier is running two purification circuits, one after the other, as a single round of purification is incapable of detecting all types of errors. The two circuits being employed are the following:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<img alt=\"Entanglement purification circuit\" src=\"../firstgenrepeater-06.purcircuit1.png\" style=\"max-width:40%\">\n<img alt=\"Entanglement purification circuit\" src=\"../firstgenrepeater-06.purcircuit2.png\" style=\"max-width:40%\">\n<!--\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CNOT(1, 3),\n CNOT(2, 4),\n Measurement(\"X\", 1),\n Measurement(\"X\", 2)]\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CPHASE(1, 3),\n CPHASE(2, 4),\n Measurement(\"X\", 1),\n Measurement(\"X\", 2)]\n-->","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"If the coincidence measurements fail, all qubits are reset. If the coincidence measurements are correct, the purified pair would have higher fidelity than what it started with. To implement one of these circuits one can write something akin to the following, where regA and regB are the two registers who share two entangled pairs, and pairXqubitX specifies the slot for each of the qubits of each of the pairs:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"gate = Gates.CNOT # or Gates.CPHASE\napply!((rega[pair2qa],rega[pair1qa]),gate)\napply!((regb[pair2qb],regb[pair1qb]),gate)\nmeasa = project_traceout!(rega[pair2qa], X)\nmeasb = project_traceout!(regb[pair2qb], X)\nif measa!=measb\n    traceout!(rega[pair1qa])\n    traceout!(regb[pair1qb])\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The overall structure of this process is similar to the Entangler and Swapper: repeatedly trying to lock four qubits belonging to two pairs shared by the same nodes, followed by performing the purification procedure.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<div class=\"mermaid\">\ngraph LR\n    A[Purifier starts<br>on nodes A and B]\n    B{Are there<br>two Bell pairs shared<br>between A and B?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>corresponding qubits])\n    D --> E[Run purification<br>and parity measurement]\n    E --> F{Coincidence<br>was observed?}\n    F --No--> F1[Reset<br>all qubits]\n    F --Yes--> F2[Preserve<br>purified qubits]\n    F1 --> G([Unlock<br>the qubits])\n    F2 --> G([Unlock<br>the qubits])\n    G --> B\n</div>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Purification processes are started on all pairs of nodes with an invocation like:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"for nodea in vertices(network)\n    for nodeb in vertices(network)\n        if nodeb>nodea\n            @process purifier(sim, network, nodea, nodeb, ...)\n        end\n    end\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to see the implementation of the Entangler process</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"@resumable function purifier(\n    sim::Environment,  # The scheduler for all simulation events\n    network,           # The graph of quantum nodes\n    nodea,             # One of the nodes on which the pairs to be purified rest\n    nodeb,             # The other such node\n    purifier_wait_time,# The wait time in case there are no pairs available for purification\n    purifier_busy_time # The duration of the purification circuit\n    )\n    round = 0\n    while true\n        pairs_of_bellpairs = findqubitstopurify(network,nodea,nodeb)\n        if isnothing(pairs_of_bellpairs)\n            @yield timeout(sim, purifier_wait_time)\n            continue\n        end\n        pair1qa, pair1qb, pair2qa, pair2qb = pairs_of_bellpairs\n        locks = [network[nodea,:locks][[pair1qa,pair2qa]];\n                 network[nodeb,:locks][[pair1qb,pair2qb]]]\n        @yield mapreduce(request, &, locks)\n        @yield timeout(sim, purifier_busy_time)\n        rega = network[nodea]\n        regb = network[nodeb]\n        gate = (CNOT, CPHASE)[round%2+1]\n        apply!((rega[pair2qa],rega[pair1qa]),gate)\n        apply!((regb[pair2qb],regb[pair1qb]),gate)\n        measa = project_traceout!(rega[pair2qa], X)\n        measb = project_traceout!(regb[pair2qb], X)\n        if measa!=measb\n            traceout!(rega[pair1qa])\n            traceout!(regb[pair1qb])\n            network[nodea,:enttrackers][pair1qa] = nothing\n            network[nodeb,:enttrackers][pair1qb] = nothing\n            @simlog sim \"failed purification at $(nodea):$(pair1qa)&$(pair2qa) and $(nodeb):$(pair1qb)&$(pair2qb)\"\n        else\n            round += 1\n            @simlog sim \"purification at $(nodea):$(pair1qa) $(nodeb):$(pair1qb) by sacrifice of $(nodea):$(pair1qa) $(nodeb):$(pair1qb)\"\n        end\n        network[nodea,:enttrackers][pair2qa] = nothing\n        network[nodeb,:enttrackers][pair2qb] = nothing\n        release.(locks)\n    end\nend\n\nfunction findqubitstopurify(network,nodea,nodeb)\n    enttrackers = network[nodea,:enttrackers]\n    locksa = network[nodea,:locks]\n    locksb = network[nodeb,:locks]\n    enttrackers = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node==nodeb && isfree(locksa[i]) && isfree(locksb[n.slot])]\n    if length(enttrackers)>=2\n        aqubits = [n.i for n in enttrackers[end-1:end]]\n        bqubits = [n.slot for n in enttrackers[end-1:end]]\n        return aqubits[2], bqubits[2], aqubits[1], bqubits[1]\n    else\n        return nothing\n    end\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Running-the-simulations","page":"1st-gen Repeater","title":"Running the simulations","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Now that we have defined the Entangler, Swapper, and Purifier processes, we just need to run the simulation. That is no different from running any other ConcurrentSim.jl simulation, after our custom setup:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"sizes = [2,3,4,3,2]        # Number of qubits in each register\nT2 = 100.0                 # T2 dephasing time of all qubits\nF = 0.97                   # Fidelity of the raw Bell pairs\nentangler_wait_time = 0.1  # How long to wait if all qubits are busy before retring entangling\nentangler_busy_time = 1.0  # How long it takes to establish a newly entangled pair\nswapper_wait_time = 0.1    # How long to wait if all qubits are unavailable for swapping\nswapper_busy_time = 0.15   # How long it takes to swap two qubits\npurifier_wait_time = 0.15  # How long to wait if there are no pairs to be purified\npurifier_busy_time = 0.2   # How long the purification circuit takes to execute\n\nsim, network = simulation_setup(sizes, T2; representation = CliffordRepr)\n\nnoisy_pair = stab_noisy_pair_func(F)\nfor (;src, dst) in edges(network)\n    @process entangler(sim, network, src, dst, noisy_pair, entangler_wait_time, entangler_busy_time)\nend\nfor node in vertices(network)\n    @process swapper(sim, network, node, swapper_wait_time, swapper_busy_time)\nend\nfor nodea in vertices(network)\n    for nodeb in vertices(network)\n        if nodeb>nodea\n            @process purifier(sim, network, nodea, nodeb, purifier_wait_time, purifier_busy_time)\n        end\n    end\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Then to run the simulation up to time t we just write run(sim, t). If we want to run until the next event, whenever that is, we can do ConcurrentSim.step(sim)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Figures-of-Merit-and-Visualizations","page":"1st-gen Repeater","title":"Figures of Merit and Visualizations","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"These simulations are not particularly useful if we do not track the performance of the quantum network. One convenient way to do that is to compute observables related to the quality of entanglement, e.g., the XX and ZZ correlators. We will compute these correlators for the second pair on the extreme ends of the chain of repeaters:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-07.observable.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Notice how the XX observable drops due to the T₂ dephasing experienced by the qubits. And then it goes back up at the occurrence of a successful purification (or all the way to zero at failed purifications). Here is what it looks like if we do not perform purification:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-07.observable.nopur.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The plotting itself is realized with the wonderful Makie.jl plotting library. The figure of merrit is obtained through a call to observable, a convenient method for calculating expectation values of various quantum observables.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Summary-of-QuantumSavory-tools-employed-in-the-simulation","page":"1st-gen Repeater","title":"Summary of QuantumSavory tools employed in the simulation","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"We used the Register data structure to automatically track the quantum states describing our mixed analog-digital quantum dynamics.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Much of the analog dynamics was implicit through the use of backgrounds, declaring the noise properties of various qubits.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The digital-ish dynamics was implemented through the use of","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"initialize! for setting initial states to various qubits\napply! for the application of various gates\ntraceout! for deleting qubits\nproject_traceout! for projective measurements over qubits\nobservable for calculating expectation values of quantum observables","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Many of the above functions take the time keyword argument, which ensures that various background analog processes are simulated before the given operation is performed.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Of note is that we also used Makie.jl for plotting, ConcurrentSim.jl for discrete event scheduling, QuantumClifford.jl for efficient simulation of Clifford circuits, and QuantumOptics.jl for convenient master equation integration. Many of these tools were used under the hood without being invoked directly.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Full-Code","page":"1st-gen Repeater","title":"Full Code","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The entirety of the code necessary for reproducing these results is in the examples folder of the QuantumSavory.jl repository.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Suggested-Improvements","page":"1st-gen Repeater","title":"Suggested Improvements","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The first and most obvious improvement would be to trigger the various events (Entangler, Swapper, Purifier) from each other, instead of having them all randomly wait and hope the necessary resources are available.\nCalibrating when to perform a purification versus a swap would be important for the performance of the network.\nBalancing what types of entanglement purification is performed, depending on the type of noise experienced, can drastically lower resource requirements.\nImplementing more sophisticated purification schemes can greatly improve the quality of entanglement.","category":"page"},{"location":"API_CircuitZoo/#Available-Circuits","page":"CircuitZoo API","title":"Available Circuits","text":"","category":"section"},{"location":"API_CircuitZoo/","page":"CircuitZoo API","title":"CircuitZoo API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API_CircuitZoo/#Autogenerated-API-list-for-QuantumSavory.CircuitZoo","page":"CircuitZoo API","title":"Autogenerated API list for QuantumSavory.CircuitZoo","text":"","category":"section"},{"location":"API_CircuitZoo/","page":"CircuitZoo API","title":"CircuitZoo API","text":"Modules = [QuantumSavory.CircuitZoo]\nPrivate = false","category":"page"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.Purify2to1","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.Purify2to1","text":"struct Purify2to1 <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nleaveout: A symbol specifying which of the three Pauli errors to leave undetectable.\n\nA simple purification circuit sacrificing a Bell pair to produce another. The circuit is parameterized by a single leaveout symbol argument which specifies which of the three possible Pauli errors are to be left undetected. A simple purificaiton circuit is not capable of detecting all errors.\n\nIf an error was detected, the circuit returns false and the state is reset. If no error was detected, the circuit returns true.\n\nThe sacrificial qubits are removed from the register.\n\njulia> a = Register(2)\n       b = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!((a[1], b[1]), bell)\n       initialize!((a[2], b[2]), bell);\n\njulia> Purify2to1(:X)(a[1], b[1], a[2], b[2])\ntrue\n\njulia> observable((a[1], b[1]), projector(bell))\n1.0 + 0.0im\n\nHowever, an error might have occurred on the initial state. If the error is detectable, the Purify2to1 circuit will return false and the state will be reset.\n\njulia> a = Register(2)\n       b = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!((a[1], b[1]), bell)\n       initialize!((a[2], b[2]), bell)\n       apply!(a[1], Z);\n\njulia> Purify2to1(:X)(a[1], b[1], a[2], b[2])\nfalse\n\njulia> a\nRegister with 2 slots: [ Qubit | Qubit ]\n  Slots:\n    nothing\n    nothing\n\nIn some cases the error might not be detectable. In that case, the Purify2to1 circuit does return true, but as you can see below, the state is not what we would expect from a successful purification.\n\njulia> a = Register(2)\n       b = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!((a[1], b[1]), bell)\n       initialize!((a[2], b[2]), bell)\n       apply!(a[1], X);\n\njulia> Purify2to1(:X)(a[1], b[1], a[2], b[2])\ntrue\n\njulia> observable((a[1], b[1]), projector(bell))\n0.0 + 0.0im\n\nSee also: Purify2to1Node, Purify3to1, PurifyExpedient, PurifyStringent\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.Purify2to1Node","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.Purify2to1Node","text":"struct Purify2to1Node <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nleaveout: A symbol specifying which of the three Pauli errors to leave undetectable.\n\nA purification circuit sacrificing 2 Bell qubits to produce another qubit. The circuit is parameterized by a single leaveout symbol argument which specifies which of the three possible Pauli errors are to be left undetected. A simple purificaiton circuit is not capable of detecting all errors.\n\nThis is only \"half\" of the full purification circuit - the local gates to be applied at a network node. For a complete purification circuit, you need to apply this circuit to the remote node as well. Alternatively, you can use the complete Purifiy2to1](@ref) circuit.\n\nThis circuit returns the measurements result (as an integer index among the possible basis states).\n\njulia> a = Register(2)\n       b = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!((a[1], b[1]), bell)\n       initialize!((a[2], b[2]), bell);\n\njulia> Purify2to1Node(:X)(a[1:2]...) == Purify2to1Node(:X)(b[1:2]...)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.Purify3to1","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.Purify3to1","text":"struct Purify3to1 <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nleaveout1: The error to be fixed twice\nleaveout2\n\nA purification circuit sacrificing a Bell pair to produce another. The circuit is parameterized by a leaveout1, and a leaveout2 symbol argument which specifies the leaveout of each of the two purification subcircuits This purificaiton circuit is capable of detecting all errors.\n\nIf an error was detected, the circuit returns false and the state is reset. If no error was detected, the circuit returns true.\n\nThe sacrificial qubits are removed from the register.\n\njulia> a = Register(2)\n       b = Register(2)\n       c = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!(a[1:2], bell)\n       initialize!(b[1:2], bell)\n       initialize!(c[1:2], bell);\n\n\njulia> Purify3to1(:Z, :Y)(a[1], a[2], b[1], c[1], b[2], c[2])\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.Purify3to1Node","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.Purify3to1Node","text":"struct Purify3to1Node <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nleaveout1: The error to be fixed twice\nleaveout2\n\nA purification circuit sacrificing 2 Bell qubits to produce another. The circuit is parameterized by a leaveout1, and a leaveout2 symbol argument which specifies the leaveout of each of the two purification subcircuits This purificaiton circuit is capable of detecting all errors.\n\nThis circuit returns the array of measurements made.\n\nThis circuit is the same as the Purifiy3to1 one but it works on individual qubits (i.e. only one qubit of a pair)\n\nThis algorithm is detailed in (Fujii and Yamamoto, 2009)\n\njulia> a = Register(2)\n       b = Register(2)\n       c = Register(2)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       initialize!(a[1:2], bell)\n       initialize!(b[1:2], bell)\n       initialize!(c[1:2], bell);\n\njulia> Purify3to1Node(:Z, :Y)(a[1], b[1], c[1]) == Purify3to1Node(:Z, :Y)(a[2], b[2], c[2])\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.PurifyExpedient","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.PurifyExpedient","text":"struct PurifyExpedient <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe EXPEDIENT purification circuit. It is composed of a head and a body. The head is repeated twice and the body is also repeating twice\n\nThe difference between it and the STRINGENT circuit is that the body is shorter.\n\nIf an error was detected, the circuit returns false and the state is reset. If no error was detected, the circuit returns true.\n\nThis circuit is detailed in (Naomi H. Nickerson and Benjamin, 2013)\n\nThe sacrificial qubits are removed from the register.\n\njulia> r = Register(22)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       for i in 1:11\n           initialize!(r[(2*i-1):(2*i)], bell)\n       end;\n\njulia> PurifyExpedient()(r[1], r[2], r[3:2:21]..., r[4:2:22]...)\ntrue\n\nSee also: PurifyExpedientNode, PurifyStringent\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.PurifyExpedientNode","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.PurifyExpedientNode","text":"struct PurifyExpedientNode <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe EXPEDIENT purification circuit (only the local half, executed on a single network node).\n\nThis returns the array of measurements made by the circuit.\n\nThis circuit is detailed in (Naomi H. Nickerson and Benjamin, 2013).\n\njulia> r = Register(22)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       for i in 1:11\n           initialize!(r[(2*i-1):(2*i)], bell)\n       end;\n\njulia> PurifyExpedientNode()(r[1], r[3:2:21]...) == PurifyExpedientNode()(r[2], r[4:2:22]...)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.PurifyStringent","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.PurifyStringent","text":"struct PurifyStringent <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe STRINGENT purification circuit. It is composed of a \"head\" and a \"body\". The head is repeated twice and the body is also repeating twice\n\nThis algorithm is detailed in (Stefan Krastanov and Jiang, 2019)\n\nIf an error was detected, the circuit returns false and the state is reset. If no error was detected, the circuit returns true.\n\nThis circuit is detailed in (Naomi H. Nickerson and Benjamin, 2013).\n\nThe sacrificial qubits are removed from the register.\n\njulia> r = Register(26)\n       bell = (Z₁⊗Z₁+Z₂⊗Z₂)/√2\n       for i in 1:13\n            initialize!(r[(2*i-1):(2*i)], bell)\n       end;\n\njulia> PurifyStringent()(r[1], r[2], r[3:2:25]..., r[4:2:26]...)\ntrue\n\nSee also: PurifyStringentNode, PurifyExpedient\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.PurifyStringentNode","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.PurifyStringentNode","text":"struct PurifyStringentNode <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe STRINGENT purification circuit (only the local half, executed on a single network node).\n\nThis returns the array of measurements made by the circuit.\n\nThis circuit is detailed in (Naomi H. Nickerson and Benjamin, 2013).\n\nSee also: PurifyStringent\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.SDDecode","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.SDDecode","text":"struct SDDecode <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe circuit for Superdense Coding to decode the 2 (classical) bit message using the entangled bell pair stored in the registers regA and regB after Alice's encoding of the first qubit. Returns a Tuple of the decoded message.\n\njulia> regA = Register(1); regB = Register(1);\n\njulia> initialize!((regA[1], regB[1]), (L0⊗L0+L1⊗L1)/√2);\n\njulia> message = (1, 1);\n\njulia> SDEncode()(regA[1], message);\n\njulia> SDDecode()(regA[1], regB[1])\n(1, 1)\n\nSee also SDEncode\n\n\n\n\n\n","category":"type"},{"location":"API_CircuitZoo/#QuantumSavory.CircuitZoo.SDEncode","page":"CircuitZoo API","title":"QuantumSavory.CircuitZoo.SDEncode","text":"struct SDEncode <: QuantumSavory.CircuitZoo.AbstractCircuit\n\nFields:\n\nThe circuit for Superdense Coding to encode the 2 (classical) bit message to its corresponding Bell pair representation. It takes as argumes a single qubit register containing Alice's half of the entangled Bell pair and the 2 bit message Alice intends to send to Bob.\n\njulia> regA = Register(1); regB = Register(1);\n\njulia> initialize!((regA[1], regB[1]), (L0⊗L0+L1⊗L1)/√2);\n\njulia> message = (1, 1);\n\njulia> SDEncode()(regA[1], message);\n\nSee also SDDecode\n\n\n\n\n\n","category":"type"},{"location":"#QuantumSavory.jl","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"A multi-formalism simulator for noisy quantum communication and computation hardware with support for symbolic algebra, multiple simulation backends, a variety of noise models, discrete event simulation, optimization, and visualization.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"We are also preparing a getting started manual.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"The rest of the documentation is structured as follows:","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"How-To Guides - fully fleshed out guides to modeling common quantum hardware setups\nExplanations - how is the library structured, what are its conventions, and why were they decided upon\nTutorials - examples covering a specific small feature of the library\nReferences - description of the entire library API","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"Depending on your learning style, you might prefer to start at different locations in the above documentation.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"Below we demo some of the results of the How-To guides.","category":"page"},{"location":"#A-simulation-of-a-quantum-repeater:","page":"QuantumSavory.jl","title":"A simulation of a quantum repeater:","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"<video src=\"howto/firstgenrepeater/firstgenrepeater-07.observable.mp4\" autoplay loop muted></video>","category":"page"},{"location":"#A-simulation-of-the-generation-of-a-cluster-state-in-color-center-memories:","page":"QuantumSavory.jl","title":"A simulation of the generation of a cluster state in color-center memories:","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"<video src=\"howto/colorcentermodularcluster/colorcentermodularcluster-02.simdashboard.mp4\" autoplay loop muted></video>","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"warning: Warning\nThis is a limited public demo of a fraction of some internal research code. Full code is slowly being documented and released.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"danger: Danger\nThis is software is still in a fairly unstable alpha state! The documentation is extremely barebones and current users are expected to read the source code.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"A good place to start is the How-To pages. For instance, the implementation of a first generation repeater.","category":"page"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"and Englund, D. (2023). Zero-Added-Loss Entangled-Photon Multiplexing for Ground- and Space-Based Quantum Networks. Phys. Rev. Applied 19, 054029.\n\n\n\nand Guha, S. (2022). Heralded Multiplexed High-Efficiency Cascaded Source of Dual-Rail Entangled Photon Pairs Using Spontaneous Parametric Down-Conversion. Phys. Rev. Applied 17, 034071.\n\n\n\nChoi, H.; Pant, M.; Guha, S. and Englund, D. (2019). Percolation-based architecture for cluster state creation using photon-mediated entanglement between atomic memories, npj Quantum Information 5, 1–7.\n\n\n\nFujii, K. and Yamamoto, K. (2009). Entanglement purification with double selection. Phys. Rev. A 80, 042308.\n\n\n\nMuralidharan, S.; Li, L.; Kim, J.; Lütkenhaus, N.; Lukin, M. D. and Jiang, L. (2016). Optimal architectures for long distance quantum communication. Scientific reports 6, 1–10.\n\n\n\nNaomi H. Nickerson, Y. L. and Benjamin, S. C. (2013). Topological quantum computing with a very noisy network and local error rates approaching one percent. Nature.\n\n\n\nPrajit Dhara, D. E. and Guha, S. (2023). Entangling quantum memories via heralded photonic Bell measurement. Phys. Rev. Research 5, 033149.\n\n\n\nStefan Krastanov, V. V. and Jiang, L. (2019). Optimized Entanglement Purification. Arxiv.\n\n\n\n","category":"page"},{"location":"tutorial/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"tutorial/","page":"Tutorials","title":"Tutorials","text":"The tutorial section is an assortment of examples covering a specific small feature of the library and its idiomatic use.","category":"page"}]
}

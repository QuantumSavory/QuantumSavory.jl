var documenterSearchIndex = {"docs":
[{"location":"register_interface/#Register-Interface","page":"Register Interface","title":"Register Interface","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"A rather diverse set of simulation libraries is used under the hood. Long term the Julia Quantum Science community might be able to converge to a common interface that would slightly simplify work between the libraries, but in the interim the Julia multimethod paradigm is sufficient. Below we describe the interface that enables us to operate with many distinct underlying simulators.","category":"page"},{"location":"register_interface/#initialize!","page":"Register Interface","title":"initialize!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Initialize the state of a register to a known state.","category":"page"},{"location":"register_interface/#initialize!(refs::Vector{RegRef},-state;-time)","page":"Register Interface","title":"initialize!(refs::Vector{RegRef}, state; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Store a state in the given register slots.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"refs can also be Tuple{Vararg{RegRef, N}} or a single RegRef.","category":"page"},{"location":"register_interface/#initialize!(r::Vector{Register},-i::Vector{Int64},-state;-time)","page":"Register Interface","title":"initialize!(r::Vector{Register}, i::Vector{Int64}, state; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"r can also be a single Register.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"The accesstimes attributes of the slots are reset to the given time.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"If state<:Symbolic, then consistent_representation is used to choose an appropriate representation based on the AbstractRepresentation properties of the register slots. Then an express call is made to transform the symbolic object into the appropriate representation.","category":"page"},{"location":"register_interface/#initialize!(r::RegRef;-time)-and-initialize!(reg::Register,-i::Int64;-time)","page":"Register Interface","title":"initialize!(r::RegRef; time) and initialize!(reg::Register, i::Int64; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"When a state is not provided, a default one is calculated from newstate, depending on the register slot's QuantumStateTrait (e.g. qubit vs qumode) and AbstractRepresentation (e.g. ket vs tableaux).","category":"page"},{"location":"register_interface/#Interface-Overview","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>initialize!(refs::Vector{RegRef}, state; time)</code>\"]\n  B[\"<code>initialize!(r::Vector{Register}, i, state; time)</code>\"]\n  subgraph TOP [lower from registers to states]\n    direction LR\n  end\n  D{{\"<code>state<:Symbolic</code>\"}}\n  subgraph D1 [express state]\n    direction LR\n    d11[\"<code>consistent_representation(r,i,state)</code>\"]\n    d12[\"<code>express(state,repr)</code>\"]\n    d11 --> d12\n  end\n  D2([Store a state reference\\nin the register slots])\n  A --> B --> TOP --> D\n  D --Yes--> D1\n  D --No--> D2\n  D1 --> D2\n  Ap[\"<code>initialize!(::RegRef; time)</code>\"]\n  Bp[\"<code>initialize!(::Register, i; time)</code>\"]\n  Cp[\"<code>newstate(::QuantumStateTrait, ::AbstractRepresentation)</code>\"]\n  subgraph TOPp [lower from registers to states]\n    direction LR\n  end\n  Ap --> Bp --> TOPp --> Cp ---> D2\n</div>","category":"page"},{"location":"register_interface/#apply!","page":"Register Interface","title":"apply!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Apply a quantum operation to a register.","category":"page"},{"location":"register_interface/#apply!(refs::Vector{RegRef},-operation;-time)","page":"Register Interface","title":"apply!(refs::Vector{RegRef}, operation; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Applying an operation to the qubits referred to by the sequence of RegRefs at a specified time.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"refs can also be Tuple{Vararg{RegRef, N}} or a single RegRef.","category":"page"},{"location":"register_interface/#apply!(regs::Vector{Register},-indices,-operation;-time)","page":"Register Interface","title":"apply!(regs::Vector{Register}, indices, operation; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"indices refers to the slots inside of the given regs.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls uptotime! in order to update any AbstractBackground properties.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls subsystemcompose! in order to make one big state. Then goes to apply!(state, subsystem_indices, operatin; time).","category":"page"},{"location":"register_interface/#apply!(state,-subsystem_indices,-operation;-time)","page":"Register Interface","title":"apply!(state, subsystem_indices, operation; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"subsystem_indices refers to subsystems in state.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"If operation<:Symbolic, then express(operation, repr, ::UseAsOperation) is used to convert the symbolic operation into something workable for the given state type. repr is chosen by dispatch on state.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"warning: Limitations of symbolic-to-explicit conversion\nCurrently, the decision of how to convert a symbolic operation is based only on the state on which the operation would act. It can not be modified by the AbstractRepresentation properties of the Registers containing the state.","category":"page"},{"location":"register_interface/#Interface-Overview-2","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>apply!(refs::Vector{RegRef}, operation; time)</code>\"]\n  B[\"<code>apply!(regs::Vector{Register}, indices, operation; time)</code>\"]\n  subgraph TOP [lower from registers to states]\n    direction LR\n    B1[\"<code>uptotime!</code>\"]\n    B2[\"<code>subsystemcompose!</code>\"]\n    B1 --> B2\n  end\n  C[\"<code>apply!(state, subsystem_indices, operation; time)</code>\"]\n  D{{\"<code>operation<:Symbolic</code>\"}}\n  D1[\"<code>express(operation, repr, ::UseAsOperation)</code>\"]\n  D2([Dispatch on state to low level implementation<br>in an independent library])\n  A --> B --> TOP --> C --> D\n  D --Yes--> D1\n  D --No--> D2\n  D1 --> D2\n</div>","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"warning: Limitations of symbolic-to-explicit conversion\nAs mentioned above, converting from symbolic to explicit representation for the operation is dependent only on the type of state, i.e. by the time the conversion is done, no knowledge of the register and its properties are kept (in particular its prefered representation is not considered).","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"info: Short-circuiting the `express` dispatch\nYou can add a custom dispatch that skips the express functionality by defining a method apply!(state::YourStateType, indices, operation<:Symbolic{Operator}). This would preemt the default apply!(state, indices, operation<:Symbolic{Operator}) containing the express logic. The drawback is that this would also skip the memoization employed by express.","category":"page"},{"location":"register_interface/#observable","page":"Register Interface","title":"observable","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Measure a quantum observable. The dispatch down the call three is very similar to the one for apply!.","category":"page"},{"location":"register_interface/#observable(refs::Tuple{Vararg{RegRef,-N}},-obs,-somethingnothing;-time)","page":"Register Interface","title":"observable(refs::Tuple{Vararg{RegRef, N}}, obs, something=nothing; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calculate the value of an observable on the state in the sequence of RegRefs at a specified time. If these registers are not instantiated, return something.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"refs can also be Tuple{Vararg{RegRef, N}} or a single RegRef.","category":"page"},{"location":"register_interface/#observable(regs::Vector{Register},-indices,-obs,-somethingnothing;-time)","page":"Register Interface","title":"observable(regs::Vector{Register}, indices, obs, something=nothing; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"indices refers to the slots inside of the given regs.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls uptotime! in order to update any AbstractBackground properties.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Calls subsystemcompose! in order to make one big state. Then goes to observable(state, subsystem_indices, obs; time).","category":"page"},{"location":"register_interface/#observable(state,-subsystem_indices,-obs;-time)","page":"Register Interface","title":"observable(state, subsystem_indices, obs; time)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"subsystem_indicesrefers to subsystems instate`.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"If operation<:Symbolic, then an express(obs, repr, ::UseAsObservable) call is used to convert the symbolic obs into something workable for the given state type. repr is chosen by dispatch on state.","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"warning: Limitations of symbolic-to-explicit conversion\nSimilar to the limitations faced by apply!","category":"page"},{"location":"register_interface/#Interface-Overview-3","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>observable(refs::Vector{RegRef}, obs, something=nothing; time)</code>\"]\n  B[\"<code>observable(regs::Vector{Register}, indices, obs, something=nothing; time)</code>\"]\n  subgraph TOP [lower from registers to states]\n    direction LR\n    B1[\"<code>uptotime!</code>\"]\n    B2[\"<code>subsystemcompose!</code>\"]\n    B1 --> B2\n  end\n  C[\"<code>observable(state, subsystem_indices, obs; time)</code>\"]\n  D{{\"<code>obs<:Symbolic</code>\"}}\n  D1[\"<code>express(obs, repr, ::UseAsObservable)</code>\"]\n  D2([Dispatch on state to low level implementation<br>in an independent library])\n  A --> B --> TOP --> C --> D\n  D --Yes--> D1\n  D --No--> D2\n  D1 --> D2\n</div>","category":"page"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"info: Short-circuiting the `express` dispatch\nSimilarly to the case with apply!, you can skips the express functionality by defining a method observable(state::YourStateType, indices, obs<:Symbolic{Operator}).","category":"page"},{"location":"register_interface/#project_traceout!","page":"Register Interface","title":"project_traceout!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"TODO","category":"page"},{"location":"register_interface/#traceout!","page":"Register Interface","title":"traceout!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Perform a partial trace over a part of the system (i.e. discard a part of the system).","category":"page"},{"location":"register_interface/#traceout!(r::RegRef)","page":"Register Interface","title":"traceout!(r::RegRef)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Partial trace over a particular register reference.","category":"page"},{"location":"register_interface/#traceout!(r::Register,-i::Int)","page":"Register Interface","title":"traceout!(r::Register, i::Int)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Partial trace over slot i of register r. Calls down to the state reference stored in that particular register.","category":"page"},{"location":"register_interface/#traceout!(s::StateRef,-i::Int)","page":"Register Interface","title":"traceout!(s::StateRef, i::Int)","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"Partial trace over subsystem i of state referenced by s.","category":"page"},{"location":"register_interface/#Interface-Overview-4","page":"Register Interface","title":"Interface Overview","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"<div class=\"mermaid\">\nflowchart TB\n  A[\"<code>traceout!(r::RegRef)</code>\"]\n  B[\"<code>traceout!(r::Register, i::Int)</code>\"]\n  C[\"<code>traceout!(r::StateRef, i::Int)</code>\"]\n  D([Dispatch on state to low level implementation<br>in an independent library])\n  A --> B --> C --> D\n</div>","category":"page"},{"location":"register_interface/#uptotime!","page":"Register Interface","title":"uptotime!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"TODO","category":"page"},{"location":"register_interface/#swap!","page":"Register Interface","title":"swap!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"TODO","category":"page"},{"location":"register_interface/#overwritetime!","page":"Register Interface","title":"overwritetime!","text":"","category":"section"},{"location":"register_interface/","page":"Register Interface","title":"Register Interface","text":"TODO","category":"page"},{"location":"propbackgrounds/#Properties-and-Backgrounds","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"","category":"section"},{"location":"propbackgrounds/","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"propbackgrounds/","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"When creating a new registers, you can specify what type of physical system it will contain in each slot, e.g. a Qubit or a qudit or a harmonic oscillator or a propagating wave packet.","category":"page"},{"location":"propbackgrounds/","page":"Properties and Backgrounds","title":"Properties and Backgrounds","text":"For each subsystem (slot in the register), you also specify what background processes and noise parameters describe it. For instance, it could be a T1Decay or T2Dephasing process, or a coherent error, or a non-Markovian bath.","category":"page"},{"location":"visualizations/#Visualizations","page":"Visualizations","title":"Visualizations","text":"","category":"section"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The registernetplot_axis function can be used to draw a given set of registers, together with the quantum states they contain. It also provides interactive tools for inspecting the content of various registers.","category":"page"},{"location":"visualizations/","page":"Visualizations","title":"Visualizations","text":"The resourceplot_axis function can be used to draw all locks and resources stored in a meta-graph governing a discrete event simulation.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/#Clifford-Simulations-of-First-Generation-Quantum-Repeater","page":"1st-gen Repeater (Clifford formalism)","title":"Clifford Simulations of First Generation Quantum Repeater","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"Here we will simulate a quantum repeater by employing a noisy Clifford circuit simulator.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"Be sure to check out the more detailed tutorial on wavefunction simulations of First Generation Quantum Repeater before proceeding with this one.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"The changes we need to perform to the code are incredibly small. We only change the way the initial states of the entangled pairs are set, without changing any of the code implementing the swapping and purification steps.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"For the wavefunction simulator we had used:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"const perfect_pair = (Z1⊗Z1 + Z2⊗Z2) / sqrt(2)\nconst perfect_pair_dm = SProjector(perfect_pair)\nconst mixed_dm = MixedState(perfect_pair_dm)\nnoisy_pair_func(F) = F*perfect_pair_dm + (1-F)*mixed_dm","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"Here we switch to tableau representation for our initial states. Converting from tableaux to kets or density matrices is cheap and automated, but the reverse direction is difficult, thus we give the initial state explicitly. You can actually use the tableau definition below for all types of simulations (tableau, ket, others).","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"# a tableau corresponding to a Bell pair\nconst tableau = S\"XX\n                  ZZ\"\nconst stab_perfect_pair = StabilizerState(tableau)\nconst stab_perfect_pair_dm = SProjector(stab_perfect_pair)\nstab_noisy_pair_func(F) = F*stab_perfect_pair_dm + (1-F)*mixed_dm","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"We then use that in the entangler setup (the same way we used a similar function when we were doing wavefunction simulations), simply by selecting the appropriate default representation type (CliffordRepr instead of QuantumOpticsRepr):","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"# exerpt from `firstgenrepeater-firstgenrepeater-clifford.jl`\nsim, network = simulation_setup(sizes, T2; representation = CliffordRepr)\nnoisy_pair = stab_noisy_pair_func(F)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"The symbolic-expression-to-density-matrix conversion is cached inside of the symbolic expression noisy_pair, so that it does not need to be recomputed each time. In particular, given that this arbitrary mixed state can not be represented as a tableau, rather as a probability distribution over different tableaux, the cache provides for efficient random sampling.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"note: You can use tableaux states in the Schroedinger simulations.\nConverting from tableaux to kets or density matrices is cheap and automated, so we could have just as well used stab_noisy_pair_func even with the Schroedinger simulations of QuantumOpticsRepr.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/#Simulation-Trace","page":"1st-gen Repeater (Clifford formalism)","title":"Simulation Trace","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"Similarly to the wavefunction simulations from the previous tutorial, here we can see how the various observables evolve over time for a Clifford-base simulation. Notice that unlike the wavefunction simulation, the results are very discrete, and we will certainly need to average over multiple repeated simulations of this trajectory.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"<video src=\"../firstgenrepeater-08.clifford.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/#Comparison-Against-a-Wavefunction-based-Simulations","page":"1st-gen Repeater (Clifford formalism)","title":"Comparison Against a Wavefunction-based Simulations","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"We can run the either simulation multiple times in order to compare the results from the wavefunction and tableau-based simulations:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"(Image: Comparison Against a Wavefunction-based Simulations)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/#Full-Code","page":"1st-gen Repeater (Clifford formalism)","title":"Full Code","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater-clifford/","page":"1st-gen Repeater (Clifford formalism)","title":"1st-gen Repeater (Clifford formalism)","text":"The entirety of the code necessary for reproducing these results is in the examples folder of the QuantumSavory.jl repository.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#First-Generation-Quantum-Repeater","page":"1st-gen Repeater","title":"First Generation Quantum Repeater","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"There is a convenient classification of quantum repeaters by their logical capabilities[1]. The first, simplest, generation of quantum repeaters involves the generation of physical (unencoded) entangled qubits between neighboring nodes, followed by entanglement swap and entanglement purification operation. No error correcting codes are employed and establishing of a link is a probabilistic process.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"[1]: Sreraman Muralidharan, Linshu Li, Jungsang Kim, Norbert L{\\\"u}tkenhaus, Mikhail D Lukin, Liang Jiang (2016)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"We will build a simplistic simulator for such a network.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"We will employ Schroedinger representation (Schroedinger, Lindblad, and other master equation will be used behind the scenes, but we will not need to work at that low level);\nWe will consider a chain of quantum repeater nodes of various sizes (number of qubits);\nThe goal would be to entangle the extreme ends of the chain:\nBy directly entangling nearest neighbors;\nFollowed by entanglement swaps to extend the links;\nAnd entanglement purification to increase the quality of the links.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"For organizing the simulation and simplifying the digital and analog quantum dynamics, we will use the star of QuantumSavory.jl, namely the Register data structure. For a convenient data structure to track per-node metadata in a graph (network) we will use the RegisterNet structure.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Moreover, behind the scenes QuantumSavory.jl will use:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"SimJulia.jl for discrete event scheduling and simulation;\nMakie.jl together with our custom plotting recipes for visualizations;\nQuantumOptics.jl for low-level quantum states.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The user does not need to know much about these libraries, but if they wish, it is easy for them to peek behind the scenes and customize their use.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The full simulation script is available at the bottom.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#The-Underlying-Data-Structures","page":"1st-gen Repeater","title":"The Underlying Data Structures","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"While the quantum dynamics would be encapsulated in a Register data structure, it is convenient to also set up structures that track the overall topology and events on the network. Our preferred way to do that is to use the RegisterNet structure, which lets you construct a graph and attach arbitrary meta-data to each edge and vertex. While this is not required for using QuantumSavory.jl, it is convenient, and we provide a lot of debugging tools that assume the use of this structure.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Given an array of register sizes, e.g. sizes = [2,3,4,3,2], we will create a linear graph, where each node has the prescribed number of qubits, e.g.: ","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"(Image: An image of 5 quantum registers)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The RegisterNet would contain, on each node:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"a Register of the appropriate size;\nan array of tuples keeping track of whom each qubit in the register is entangled to (as the :enttracker property);\nan array of locks (from SimJulia.jl) keeping track of whether a process is happening on the given qubit (as the :locks property).","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"note: Note\nTo see how to visualize these data structures as the simulation is proceeding, consult the Visualizations page.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"note: Note\nTo see how to define imperfections, noise processes, and background events, consult the Sub-system Properties page.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to expand and see code used to set up the meta-graph and registers</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"\"\"\"Creates the datastructures representing the simulated network\"\"\"\nfunction simulation_setup(\n    sizes, # Array giving the number of qubits in each node\n    T2 # T2 dephasing times for the qubits\n    ;\n    representation = QuantumOpticsRepr # Representation to use for the qubits\n    )\n    R = length(sizes) # Number of registers\n\n    # A scheduler datastructure for the discrete event simulation\n    sim = Simulation()\n\n    # All of the quantum register we will be simulating\n    registers = Register[]\n    for s in sizes\n        traits = [Qubit() for _ in 1:s]\n        repr = [representation() for _ in 1:s]\n        bg = [T2Dephasing(T2) for _ in 1:s]\n        push!(registers, Register(traits,repr,bg))\n    end\n\n    # A graph structure defining the connectivity among registers\n    # It is not necessary to use such a structure, however, it is a convenient way to\n    # store data about the simulation (and we have created helper plotting functions\n    # expecting such a structure).\n    graph = grid([R])\n    network = RegisterNet(graph, registers) # A graphs with extra \"meta data\"\n\n    # Add a register datastructures and event locks to each node.\n    for v in vertices(network)\n        # Create an array specifying whether a qubit is entangled with another qubit\n        network[v,:enttrackers] = Any[nothing for i in 1:sizes[v]]\n        # Create an array of locks, telling us whether a qubit is undergoing an operation\n        network[v,:locks] = [Resource(sim,1) for i in 1:sizes[v]]\n    end\n\n    sim, network\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Entangler","page":"1st-gen Repeater","title":"Entangler","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The first set of processes we need is the \"entanglers\" that enable nearest-neighbor entanglement generation:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-02.entangler.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"They run in parallel on each edge of the graph, set up by an invocation similar to the following:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"for (;src, dst) in edges(network)\n    @process entangler(sim, network, src, dst, ...)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"As seen in the following flow chart, the entangler repeatedly checks for available pairs of unused qubit slots and attempts to entangle them.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<div class=\"mermaid\">\ngraph LR\n    A[Entangler starts<br>on node A and B]\n    B{Are there<br>unused qubits on<br>node A and B?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>available qubits])\n    D --> E[Run entanglement<br>generation]\n    E --> F[Write down<br>who was entangled]\n    F --> G([Unlock the<br>qubits])\n    G --> B\n</div>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to see the implementation of the Entangler process</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"@resumable function entangler(\n    sim::Environment,   # The scheduler for all simulation events\n    network,            # The graph of quantum nodes\n    nodea, nodeb,       # The two nodes which we will be entangling\n    noisy_pair,         # A raw entangled pair\n    entangler_wait_time,# The wait time in case all qubits are \"busy\"\n    entangler_busy_time # How long it takes to establish entanglement\n    )\n    while true\n        ia = findfreequbit(network, nodea)\n        ib = findfreequbit(network, nodeb)\n        if isnothing(ia) || isnothing(ib)\n            @yield timeout(sim, entangler_wait_time)\n            continue\n        end\n        locka = network[nodea,:locks][ia]\n        lockb = network[nodeb,:locks][ib]\n        @yield request(locka) & request(lockb)\n        registera = network[nodea]\n        registerb = network[nodeb]\n        @yield timeout(sim, entangler_busy_time)\n        initialize!((registera[ia],registerb[ib]),noisy_pair; time=now(sim))\n        network[nodea,:enttrackers][ia] = (node=nodeb,slot=ib)\n        network[nodeb,:enttrackers][ib] = (node=nodea,slot=ia)\n        @simlog sim \"entangled node $(nodea):$(ia) and node $(nodeb):$(ib)\"\n        release(locka)\n        release(lockb)\n    end\nend\n\n\"\"\"Find an uninitialized unlocked qubit on a given node\"\"\"\nfunction findfreequbit(network, node)\n    register = network[node]\n    locks = network[node,:locks]\n    regsize = nsubsystems(register)\n    findfirst(i->!isassigned(register,i) & isfree(locks[i]), 1:regsize)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Notice that the entangler uses the initialize! function to set the state of certain registers, but we never need to explicitly construct the numerical representation of these kets. Rather, we use the symbolic algebra system of QuantumClifford.jl, and let the simulator automatically convert the symbolic expression into numerical density matrices. This conversion was governed by the choice of representation = QuantumOpticsRepr. Here is one possible symbolic definition of a noisy_pair:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"const perfect_pair = (Z1⊗Z1 + Z2⊗Z2) / sqrt(2)\nconst perfect_pair_dm = SProjector(perfect_pair)\nconst mixed_dm = MixedState(perfect_pair_dm)\nnoisy_pair_func(F) = F*perfect_pair_dm + (1-F)*mixed_dm","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The symbolic-expression-to-density-matrix conversion is cached inside of the symbolic expression, so that it does not need to be recomputed each time.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Swapper","page":"1st-gen Repeater","title":"Swapper","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Once we have the raw nearest-neighbor entanglement, we can proceed with swap operations that link two Bell pairs that share one common node into a longer Bell pair:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-03.swapper.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"They run in parallel on each vertex of the graph, set up by an invocation similar to the following:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"for node in vertices(network)\n    @process swapper(sim, network, node, ...)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The Swapper working on a given node simply checks whether there are any qubits on that node that are entangled with other nodes, both on the left and right of the current node. If such qubits are found, the entanglement swap operation is performed on them, as seen in this flowchart.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<div class=\"mermaid\">\ngraph LR\n    A[Swapper starts<br>on node A]\n    B{Are there<br>qubits entangled with A<br>both on the left and right<br>of A?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>local qubits])\n    D --> E[Run entanglement<br>swapping]\n    E --> F[Write down<br>how the entanglement<br>was redistributed]\n    F --> G([Unlock and erase<br>the local qubits])\n    G --> B\n</div>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The entanglement swap operation is performed through the following simple circuit, which entangles the two local qubits belonging to two separate Bell pairs, and then measures them:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<img alt=\"Entanglement swapping circuit\" src=\"../firstgenrepeater-04.swapcircuit.png\" style=\"max-width:50%\">\n<!--\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CNOT(2, 3),\n Measurement(\"X\", 2, 1),\n ClassicalDecision(\"Z\", 1, 1),\n Measurement(\"Z\", 3, 2),\n ClassicalDecision(\"X\", 4, 2)]\n -->","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The code implementing such a circuit looks like the following (where localslot denotes register slots on which swapping happens, and remslot denotes remote registers on the left and right):","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"apply!((localslot1, localslot2), CNOT; time=time)\nxmeas = project_traceout!(localslot1, X)\nzmeas = project_traceout!(localslot2, Z)\nif xmeas==2\n    apply!(remslot1, Z)\nend\nif zmeas==2\n    apply!(remslot2, X)\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to see the implementation of the Swapper process</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"@resumable function swapper(\n    sim::Environment, # The scheduler for all simulation events\n    network,          # The graph of quantum nodes\n    node,             # The node on which the swapper works\n    swapper_wait_time,# The wait time in case there are no available qubits for swapping\n    swapper_busy_time # How long it takes to perform the swap\n    )\n    while true\n        qubit_pair = findswapablequbits(network,node)\n        if isnothing(qubit_pair)\n            @yield timeout(sim, swapper_wait_time)\n            continue\n        end\n        q1, q2 = qubit_pair\n        locks = network[node, :locks][[q1,q2]]\n        @yield mapreduce(request, &, locks)\n        reg = network[node]\n        @yield timeout(sim, swapper_busy_time)\n        node1 = network[node,:enttrackers][q1]\n        reg1 = network[node1.node]\n        node2 = network[node,:enttrackers][q2]\n        reg2 = network[node2.node]\n        swapcircuit(reg[q1], reg[q2], reg1[node1.slot], reg2[node2.slot]; time=now(sim))\n        network[node1.node,:enttrackers][node1.slot] = node2\n        network[node2.node,:enttrackers][node2.slot] = node1\n        network[node,:enttrackers][q1] = nothing\n        network[node,:enttrackers][q2] = nothing\n        @simlog sim \"swap at $(node):$(q1)&$(q2) connecting $(node1) and $(node2)\"\n        release.(locks)\n    end\nend\n\nfunction swapcircuit(localslot1, localslot2, remslot1, remslot2; time=nothing)\n    apply!((localslot1, localslot2), CNOT; time=time)\n    xmeas = project_traceout!(localslot1, X)\n    zmeas = project_traceout!(localslot2, Z)\n    if xmeas==2\n        apply!(remslot1, Z)\n    end\n    if zmeas==2\n        apply!(remslot2, X)\n    end\nend\n\nfunction findswapablequbits(network,node)\n    enttrackers = network[node,:enttrackers]\n    locks = network[node,:locks]\n    left_nodes  = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node<node && isfree(locks[i])]\n    isempty(left_nodes)  && return nothing\n    right_nodes = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node>node && isfree(locks[i])]\n    isempty(right_nodes) && return nothing\n    _, farthest_left  = findmin(n->n.node, left_nodes)\n    _, farthest_right = findmax(n->n.node, right_nodes)\n    return left_nodes[farthest_left].i, right_nodes[farthest_right].i\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Purifier","page":"1st-gen Repeater","title":"Purifier","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Last but not least, there is the Purifier that searches for pairs of nodes that share more than one Bell pair. On such nodes a purification procedure can be performed:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-05.purifier.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"As you can see, not all purification attempts succeed. On some occasions there is a failure and both pairs get discarded as faulty. Each Purifier is running two purification circuits, one after the other, as a single round of purification is incapable of detecting all types of errors. The two circuits being employed are the following:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<img alt=\"Entanglement purification circuit\" src=\"../firstgenrepeater-06.purcircuit1.png\" style=\"max-width:40%\">\n<img alt=\"Entanglement purification circuit\" src=\"../firstgenrepeater-06.purcircuit2.png\" style=\"max-width:40%\">\n<!--\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CNOT(1, 3),\n CNOT(2, 4),\n Measurement(\"X\", 1),\n Measurement(\"X\", 2)]\n[Initialize(\"pair 1\", [1, 2]),\n Initialize(\"pair 2\", [3, 4]),\n CPHASE(1, 3),\n CPHASE(2, 4),\n Measurement(\"X\", 1),\n Measurement(\"X\", 2)]\n-->","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"If the coincidence measurements fail, all qubits are reset. If the coincidence measurements are correct, the purified pair would have higher fidelity than what it started with. To implement one of these circuits one can write something akin to the following, where regA and regB are the two registers who share two entangled pairs, and pairXqubitX specifies the slot for each of the qubits of each of the pairs:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"gate = Gates.CNOT # or Gates.CPHASE\napply!((rega[pair2qa],rega[pair1qa]),gate)\napply!((regb[pair2qb],regb[pair1qb]),gate)\nmeasa = project_traceout!(rega[pair2qa], X)\nmeasb = project_traceout!(regb[pair2qb], X)\nif measa!=measb\n    traceout!(rega[pair1qa])\n    traceout!(regb[pair1qb])\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The overall structure of this process is similar to the Entangler and Swapper: repeatedly trying to lock four qubits belonging to two pairs shared by the same nodes, followed by performing the purification procedure.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<div class=\"mermaid\">\ngraph LR\n    A[Purifier starts<br>on nodes A and B]\n    B{Are there<br>two Bell pairs shared<br>between A and B?}\n    A --> B\n    B --No--> C[Wait a bit...]\n    C --> B\n    B --Yes--> D([Lock the<br>corresponding qubits])\n    D --> E[Run purification<br>and parity measurement]\n    E --> F{Coincidence<br>was observed?}\n    F --No--> F1[Reset<br>all qubits]\n    F --Yes--> F2[Preserve<br>purified qubits]\n    F1 --> G([Unlock<br>the qubits])\n    F2 --> G([Unlock<br>the qubits])\n    G --> B\n</div>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Purification processes are started on all pairs of nodes with an invocation like:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"for nodea in vertices(network)\n    for nodeb in vertices(network)\n        if nodeb>nodea\n            @process purifier(sim, network, nodea, nodeb, ...)\n        end\n    end\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<details><summary>Click to see the implementation of the Entangler process</summary>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"@resumable function purifier(\n    sim::Environment,  # The scheduler for all simulation events\n    network,           # The graph of quantum nodes\n    nodea,             # One of the nodes on which the pairs to be purified rest\n    nodeb,             # The other such node\n    purifier_wait_time,# The wait time in case there are no pairs available for purification\n    purifier_busy_time # The duration of the purification circuit\n    )\n    round = 0\n    while true\n        pairs_of_bellpairs = findqubitstopurify(network,nodea,nodeb)\n        if isnothing(pairs_of_bellpairs)\n            @yield timeout(sim, purifier_wait_time)\n            continue\n        end\n        pair1qa, pair1qb, pair2qa, pair2qb = pairs_of_bellpairs\n        locks = [network[nodea,:locks][[pair1qa,pair2qa]];\n                 network[nodeb,:locks][[pair1qb,pair2qb]]]\n        @yield mapreduce(request, &, locks)\n        @yield timeout(sim, purifier_busy_time)\n        rega = network[nodea]\n        regb = network[nodeb]\n        gate = (CNOT, CPHASE)[round%2+1]\n        apply!((rega[pair2qa],rega[pair1qa]),gate)\n        apply!((regb[pair2qb],regb[pair1qb]),gate)\n        measa = project_traceout!(rega[pair2qa], X)\n        measb = project_traceout!(regb[pair2qb], X)\n        if measa!=measb\n            traceout!(rega[pair1qa])\n            traceout!(regb[pair1qb])\n            network[nodea,:enttrackers][pair1qa] = nothing\n            network[nodeb,:enttrackers][pair1qb] = nothing\n            @simlog sim \"failed purification at $(nodea):$(pair1qa)&$(pair2qa) and $(nodeb):$(pair1qb)&$(pair2qb)\"\n        else\n            round += 1\n            @simlog sim \"purification at $(nodea):$(pair1qa) $(nodeb):$(pair1qb) by sacrifice of $(nodea):$(pair1qa) $(nodeb):$(pair1qb)\"\n        end\n        network[nodea,:enttrackers][pair2qa] = nothing\n        network[nodeb,:enttrackers][pair2qb] = nothing\n        release.(locks)\n    end\nend\n\nfunction findqubitstopurify(network,nodea,nodeb)\n    enttrackers = network[nodea,:enttrackers]\n    locksa = network[nodea,:locks]\n    locksb = network[nodeb,:locks]\n    enttrackers = [(i=i,n...) for (i,n) in enumerate(enttrackers)\n                   if !isnothing(n) && n.node==nodeb && isfree(locksa[i]) && isfree(locksb[n.slot])]\n    if length(enttrackers)>=2\n        aqubits = [n.i for n in enttrackers[end-1:end]]\n        bqubits = [n.slot for n in enttrackers[end-1:end]]\n        return aqubits[2], bqubits[2], aqubits[1], bqubits[1]\n    else\n        return nothing\n    end\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"</details>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Running-the-simulations","page":"1st-gen Repeater","title":"Running the simulations","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Now that we have defined the Entangler, Swapper, and Purifier processes, we just need to run the simulation. That is no different from running any other SimJulia.jl simulation, after our custom setup:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"sizes = [2,3,4,3,2]        # Number of qubits in each register\nT2 = 100.0                 # T2 dephasing time of all qubits\nF = 0.97                   # Fidelity of the raw Bell pairs\nentangler_wait_time = 0.1  # How long to wait if all qubits are busy before retring entangling\nentangler_busy_time = 1.0  # How long it takes to establish a newly entangled pair\nswapper_wait_time = 0.1    # How long to wait if all qubits are unavailable for swapping\nswapper_busy_time = 0.15   # How long it takes to swap two qubits\npurifier_wait_time = 0.15  # How long to wait if there are no pairs to be purified\npurifier_busy_time = 0.2   # How long the purification circuit takes to execute\n\nsim, network = simulation_setup(sizes, T2; representation = CliffordRepr)\n\nnoisy_pair = stab_noisy_pair_func(F)\nfor (;src, dst) in edges(network)\n    @process entangler(sim, network, src, dst, noisy_pair, entangler_wait_time, entangler_busy_time)\nend\nfor node in vertices(network)\n    @process swapper(sim, network, node, swapper_wait_time, swapper_busy_time)\nend\nfor nodea in vertices(network)\n    for nodeb in vertices(network)\n        if nodeb>nodea\n            @process purifier(sim, network, nodea, nodeb, purifier_wait_time, purifier_busy_time)\n        end\n    end\nend","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Then to run the simulation up to time t we just write run(sim, t). If we want to run until the next event, whenever that is, we can do SimJulia.step(sim)","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Figures-of-Merit-and-Visualizations","page":"1st-gen Repeater","title":"Figures of Merit and Visualizations","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"These simulations are not particularly useful if we do not track the performance of the quantum network. One convenient way to do that is to compute observables related to the quality of entanglement, e.g., the XX and ZZ correlators. We will compute these correlators for the second pair on the extreme ends of the chain of repeaters:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-07.observable.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Notice how the XX observable drops due to the T₂ dephasing experienced by the qubits. And then it goes back up at the occurence of a successful purification (or all the way to zero at failed purifications). Here is what it looks like if we do not perform purification:","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"<video src=\"../firstgenrepeater-07.observable.nopur.mp4\" autoplay loop muted></video>","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The plotting itself is realized with the wonderful Makie.jl plotting library. The figure of merrit is obtained through a call to observable, a convenient method for calculating expectation values of various quantum observables.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Summary-of-QuantumSavory-tools-employed-in-the-simulation","page":"1st-gen Repeater","title":"Summary of QuantumSavory tools employed in the simulation","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"We used the Register data structure to automatically track the quantum states describing our mixed analog-digital quantum dynamics.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Much of the analog dynamics was implicit through the use of backgrounds, declaring the noise properties of various qubits.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The digital-ish dynamics was implemented through the use of","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"initialize! for setting inital states to various qubits\napply! for the application of various gates\ntraceout! for deleting qubits\nproject_traceout! for projective measurements over qubits\nobservable for calculating expectation values of quantum observables","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Many of the above functions take the time keyword argument, which ensures that various background analog processes are simulated before the given operation is performed.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"Of note is that we also used Makie.jl for plotting, SimJulia.jl for discrete event scheduling, QuantumClifford.jl for efficient simulation of Clifford circuits, and QuantumOptics.jl for convenient master equation integration. Many of these tools were used under the hood without being invoked directly.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Full-Code","page":"1st-gen Repeater","title":"Full Code","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The entirety of the code necessary for reproducing these results is in the examples folder of the QuantumSavory.jl repository.","category":"page"},{"location":"howto/firstgenrepeater/firstgenrepeater/#Suggested-Improvements","page":"1st-gen Repeater","title":"Suggested Improvements","text":"","category":"section"},{"location":"howto/firstgenrepeater/firstgenrepeater/","page":"1st-gen Repeater","title":"1st-gen Repeater","text":"The first and most obvious improvement would be to trigger the various events (Entangler, Swapper, Purifier) from each other, instead of having them all randomly wait and hope the necessary resources are available.\nCalibrating when to perform a purification versus a swap would be important for the performance of the network.\nBalancing what types of entanglement purification is performed, depending on the type of noise experienced, can drastically lower resource requirements.\nImplementing more sophisticated purification schemes can greatly improve the quality of entanglement.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"","category":"page"},{"location":"#QuantumSavory.jl","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"","category":"section"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"DocTestSetup = quote\n    using QuantumSavory\nend","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"A limited public demo of a fraction of some internal research code. Full code to be release shortly.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"danger: Danger\nThis is software is still in a fairly unstable alpha state! The documentation is extremely barebones and current users are expected to read the source code.","category":"page"},{"location":"","page":"QuantumSavory.jl","title":"QuantumSavory.jl","text":"A good place to start is the How-To pages. For instance, the implementation of a first generation repeater.","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [QuantumSavory]\nPrivate = false","category":"page"},{"location":"API/#QuantumSavory.CliffordRepr","page":"API","title":"QuantumSavory.CliffordRepr","text":"Representation using tableaux governed by QuantumClifford.jl\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Depolarization","page":"API","title":"QuantumSavory.Depolarization","text":"A depolarization background.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.PauliNoise","page":"API","title":"QuantumSavory.PauliNoise","text":"A Pauli noise background.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.QuantumMCRepr","page":"API","title":"QuantumSavory.QuantumMCRepr","text":"Similar to QuantumOpticsRepr, but using trajectories instead of superoperators.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.QuantumOpticsRepr","page":"API","title":"QuantumSavory.QuantumOpticsRepr","text":"Representation using kets, densinty matrices, and superoperators governed by QuantumOptics.jl.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Qubit","page":"API","title":"QuantumSavory.Qubit","text":"Specifies that a given register slot contains qubits.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Qumode","page":"API","title":"QuantumSavory.Qumode","text":"Specifies that a given register slot contains qumodes.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.Register","page":"API","title":"QuantumSavory.Register","text":"The main data structure in QuantumSavory, used to represent a quantum register in an arbitrary formalism.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.T1Decay","page":"API","title":"QuantumSavory.T1Decay","text":"A background describing the T₁ decay of a two-level system.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.T2Dephasing","page":"API","title":"QuantumSavory.T2Dephasing","text":"A background describing the T₂ dephasing of a two-level system.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSavory.apply!-Tuple{Vector{Register}, Vector{Int64}, Any}","page":"API","title":"QuantumSavory.apply!","text":"Apply a given operation on the given set of register slots.\n\napply!([regA, regB], [slot1, slot2], Gates.CNOT) would apply a CNOT gate on the content of the given registers at the given slots. The appropriate representatin of the gate is used, depending on the formalism under which a quantum state is stored in the given registers. The Hilbert spaces of the registers are automatically joined if necessary.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.initialize!-Tuple{Vector{Register}, Vector{Int64}, Any}","page":"API","title":"QuantumSavory.initialize!","text":"Set the state of a given set of registers.\n\ninitialize!([regA,regB], [slot1,slot2], state) would set the state of the given slots in the given registers to state. state can be any supported state representation, e.g., kets or density matrices from QuantumOptics.jl or tableaux from QuantumClifford.jl.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.observable","page":"API","title":"QuantumSavory.observable","text":"Calculate the expectation value of a quantum observable on the given register and slot.\n\nobservable([regA, regB], [slot1, slot2], obs) would calculate the expectation value of the obs observable (using the appropriate formalism, depending on the state representation in the given registers).\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.project_traceout!","page":"API","title":"QuantumSavory.project_traceout!","text":"Perform a projective measurement on the given slot of the given register.\n\nproject_traceout!(reg, slot, [stateA, stateB]) performs a projective measurement, projecting on either stateA or stateB, returning the index of the subspace on which the projection happened. It assumes the list of possible states forms a basis for the Hilbert space. The Hilbert space of the register is automatically shrinked.\n\nA basis object can be specified on its own as well, e.g. project_traceout!(reg, slot, basis).\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSavory.registernetplot_axis-Tuple{Any, Any}","page":"API","title":"QuantumSavory.registernetplot_axis","text":"Draw the given registers on a given Makie axis.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.resourceplot_axis-NTuple{5, Any}","page":"API","title":"QuantumSavory.resourceplot_axis","text":"Draw the various resources and locks stored in the given meta-graph on a given Makie axis.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSavory.traceout!-Tuple{Register, Int64}","page":"API","title":"QuantumSavory.traceout!","text":"Delete the given slot of the given register.\n\ntraceout!(reg, slot) would reset (perform a partial trace) over the given subsystem. The Hilbert space of the register is automatically shrinked.\n\n\n\n\n\n","category":"method"}]
}

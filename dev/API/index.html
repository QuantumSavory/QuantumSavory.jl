<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QuantumSavory.jl</title><meta name="title" content="API · QuantumSavory.jl"/><meta property="og:title" content="API · QuantumSavory.jl"/><meta property="twitter:title" content="API · QuantumSavory.jl"/><meta name="description" content="Documentation for QuantumSavory.jl."/><meta property="og:description" content="Documentation for QuantumSavory.jl."/><meta property="twitter:description" content="Documentation for QuantumSavory.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script>
// Bad workaround for Documenter + require.js clashing with AnythingLLM.
// Render the widget inside a sandboxed iframe overlay to isolate globals.
(function() {
  const embedId = "dfae9733-b677-42b2-8947-9adc891a0b48";
  const apiBase = "https://anythingllm.krastanov.org/api/embed";
  const src = "https://anythingllm.krastanov.org/embed/anythingllm-chat-widget.min.js";

  const injectEmbed = () => {
    if (document.getElementById("anythingllm-embed-frame")) return;

    const iframe = document.createElement("iframe");
    iframe.id = "anythingllm-embed-frame";
    iframe.title = "AnythingLLM chat";
    iframe.style.cssText = "bottom: 0; height: 560px; maxHeight: min(95vh, 560px); right: 0; border: none; maxWidth: min(95vw, 360px); position: fixed; width: 360px; zIndex: 2147483000; background: transparent;";
    iframe.sandbox = "allow-same-origin allow-scripts allow-popups allow-forms allow-modals";
    iframe.loading = "lazy";

    const html = `
<!doctype html>
<html>
  <head>
    <style>
      html, body { margin: 0; padding: 0; overflow: hidden; background: transparent; }
    </style>
  </head>
  <body>
    <script
      data-embed-id="${embedId}"
      data-base-api-url="${apiBase}"
      data-chat-icon="magic"
      data-position="bottom-right"
      data-assistant-name="AnythingLLM Chat Assistant"
      data-window-height="400px"
      data-greeting="This is an LLM helper with access to the entirety of the docs. You can directly ask it your questions. As usual, take anything it says with a grain of salt -- LLMs are prone to confabulating."
      data-open-on-load="on"
      data-brand-image-url="false"
      data-no-sponsor="true"
      data-no-header="true"
      data-window-width="300px"
      src="${src}">
    <\/script>
  </body>
</html>`;
    iframe.srcdoc = html;
    document.body.appendChild(iframe);
  };

  if (document.readyState === "complete" || document.readyState === "interactive") {
    injectEmbed();
  } else {
    window.addEventListener("DOMContentLoaded", injectEmbed);
  }
})();
</script>
</head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="QuantumSavory.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumSavory.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">QuantumSavory.jl</a></li><li><a class="tocitem" href="../manual/">Getting Started Manual</a></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../explanations/">Explanations</a></li><li><a class="tocitem" href="../register_interface/">Register Interface</a></li><li><a class="tocitem" href="../properties/">Properties</a></li><li><a class="tocitem" href="../backgrounds/">Background Noise</a></li><li><a class="tocitem" href="../symbolics/">Symbolic Expressions</a></li><li><a class="tocitem" href="../tag_query/">Tagging and Querying</a></li><li><a class="tocitem" href="../backendsimulator/">Backend Simulators</a></li><li><a class="tocitem" href="../discreteeventsimulator/">Discrete Event Simulator</a></li><li><a class="tocitem" href="../visualizations/">Visualizations</a></li></ul></li><li><span class="tocitem">How-To Guides</span><ul><li><a class="tocitem" href="../howto/">How-To Guides</a></li><li><a class="tocitem" href="../howto/firstgenrepeater/firstgenrepeater/">1st-gen Repeater - low level implementation</a></li><li><a class="tocitem" href="../howto/firstgenrepeater/firstgenrepeater-clifford/">1st-gen Repeater - Clifford formalism</a></li><li><a class="tocitem" href="../howto/firstgenrepeater_v2/firstgenrepeater_v2/">1st-gen Repeater - simpler implementation</a></li><li><a class="tocitem" href="../howto/congestionchain/congestionchain/">Congestion on a Repeater Chain</a></li><li><a class="tocitem" href="../howto/colorcentermodularcluster/colorcentermodularcluster/">Cluster States in Atomic Memories</a></li><li><a class="tocitem" href="../howto/simpleswitch/simpleswitch/">Entanglement Switch</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial/">Tutorials</a></li><li><a class="tocitem" href="../tutorial/noninstantgate/">Gate Duration</a></li><li><a class="tocitem" href="../tutorial/state_explorer/">State Explorer</a></li></ul></li><li><span class="tocitem">References</span><ul><li><a class="tocitem" href="../references/">References</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Autogenerated-API-list"><span>Autogenerated API list</span></a></li></ul></li><li><a class="tocitem" href="../API_CircuitZoo/">CircuitZoo API</a></li><li><a class="tocitem" href="../API_StatesZoo/">StatesZoo API</a></li><li><a class="tocitem" href="../API_ProtocolZoo/">ProtocolZoo API</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">References</a></li><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumSavory.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/master/docs/src/API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-API"><a class="docs-heading-anchor" href="#Full-API">Full API</a><a id="Full-API-1"></a><a class="docs-heading-anchor-permalink" href="#Full-API" title="Permalink"></a></h1><style>
    .content table td {
        padding-top: 0 !important;
        padding-bottom: 0 !important;
    }
</style><h2 id="Autogenerated-API-list"><a class="docs-heading-anchor" href="#Autogenerated-API-list">Autogenerated API list</a><a id="Autogenerated-API-list-1"></a><a class="docs-heading-anchor-permalink" href="#Autogenerated-API-list" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QuantumSavory.W"><a class="docstring-binding" href="#QuantumSavory.W"><code>QuantumSavory.W</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>A wildcard instance for use with the tag querying functionality.</p><p>See also: <a href="#QuantumSavory.query-Union{Tuple{N}, Tuple{MessageBuffer, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><code>query</code></a>, <a href="#QuantumSavory.tag!-Tuple{RegRef, Any}"><code>tag!</code></a>, <a href="#QuantumSavory.❓"><code>❓</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/queries.jl#L58-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.❓"><a class="docstring-binding" href="#QuantumSavory.❓"><code>QuantumSavory.❓</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>A wildcard instance for use with the tag querying functionality.</p><p>This emoji can be inputted with the <code>\:question:</code> emoji shortcut, or you can simply use the ASCII alternative <a href="#QuantumSavory.W"><code>W</code></a>.</p><p>See also: <a href="#QuantumSavory.query-Union{Tuple{N}, Tuple{MessageBuffer, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><code>query</code></a>, <a href="#QuantumSavory.tag!-Tuple{RegRef, Any}"><code>tag!</code></a>, <a href="#QuantumSavory.W"><code>W</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/queries.jl#L64-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.AbstractBackground"><a class="docstring-binding" href="#QuantumSavory.AbstractBackground"><code>QuantumSavory.AbstractBackground</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>An abstract type for the various background processes that might be inflicted upon a <a href="#QuantumSavory.Register"><code>Register</code></a> slot, e.g. decay, dephasing, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/traits_and_defaults.jl#L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.AmplitudeDamping"><a class="docstring-binding" href="#QuantumSavory.AmplitudeDamping"><code>QuantumSavory.AmplitudeDamping</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A depolarization background.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backgrounds.jl#L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.ConstantHamiltonianEvolution"><a class="docstring-binding" href="#QuantumSavory.ConstantHamiltonianEvolution"><code>QuantumSavory.ConstantHamiltonianEvolution</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Represents a Hamiltonian being applied for the given duration. See also <a href="#QuantumSavory.NonInstantGate"><code>NonInstantGate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/noninstant.jl#L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.Depolarization"><a class="docstring-binding" href="#QuantumSavory.Depolarization"><code>QuantumSavory.Depolarization</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A depolarization background.</p><p>The <code>τ</code> parameter specifies the average time between depolarization events (assuming a Poisson point process). I.e. after time <code>t</code> the probability for an depolarization event is <code>1-exp(-t/τ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backgrounds.jl#L13-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.MessageBuffer"><a class="docstring-binding" href="#QuantumSavory.MessageBuffer"><code>QuantumSavory.MessageBuffer</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A a buffer for classical messages. Usually a part of a <a href="#QuantumSavory.Register"><code>Register</code></a> structure.</p><p>See also: <a href="#QuantumSavory.channel-Tuple{RegisterNet, Vararg{Any}}"><code>channel</code></a>, <a href="#QuantumSavory.messagebuffer-Tuple{RegisterNet, Int64}"><code>messagebuffer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/messagebuffer.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.NonInstantGate"><a class="docstring-binding" href="#QuantumSavory.NonInstantGate"><code>QuantumSavory.NonInstantGate</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Represents an gate applied instantaneously followed by a waiting period. See also <a href="#QuantumSavory.ConstantHamiltonianEvolution"><code>ConstantHamiltonianEvolution</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/noninstant.jl#L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.PauliNoise"><a class="docstring-binding" href="#QuantumSavory.PauliNoise"><code>QuantumSavory.PauliNoise</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A Pauli noise background.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backgrounds.jl#L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.QuantumChannel"><a class="docstring-binding" href="#QuantumSavory.QuantumChannel"><code>QuantumSavory.QuantumChannel</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Quantum channel for transmitting quantum states from one register to another.</p><p>Delay and background noise processes are supported.</p><p>The function <code>put!</code> is used to take the contents of a <code>RegRef</code> and put it in the channel. That state can can then be received by a register (after a delay) using the <code>take!</code> method.</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumSavory, ResumableFunctions, ConcurrentSim

julia&gt; regA = Register(1); regB = Register(1);

julia&gt; initialize!(regA[1], Z1);

julia&gt; sim = Simulation();

julia&gt; qc = QuantumChannel(sim, 10.0) # a delay of 10 units
QuantumChannel{Qubit}(Qubit(), DelayQueue{Register}(ConcurrentSim.QueueStore{Register, Int64}, 10.0), nothing)

julia&gt; @resumable function alice_node(env, qc)
            println(&quot;Putting Alice&#39;s qubit in the channel at &quot;, now(env))
            put!(qc, regA[1])
        end
alice_node (generic function with 1 method)

julia&gt; @resumable function bob_node(env, qc)
            @yield take!(qc, regB[1])
            println(&quot;Taking the qubit from alice at &quot;, now(env))
        end
bob_node (generic function with 1 method)

julia&gt; @process alice_node(sim, qc); @process bob_node(sim, qc);

julia&gt; run(sim)
Putting Alice&#39;s qubit in the channel at 0.0
Taking the qubit from alice at 10.0

julia&gt; regA
Register with 1 slots: [ Qubit ]
  Slots:
    nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/quantumchannel.jl#L1-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.QuantumStateTrait"><a class="docstring-binding" href="#QuantumSavory.QuantumStateTrait"><code>QuantumSavory.QuantumStateTrait</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>An abstract type for the various types of states that can be given to <a href="#QuantumSavory.Register"><code>Register</code></a> slots, e.g. qubit, harmonic oscillator, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/traits_and_defaults.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.Qubit"><a class="docstring-binding" href="#QuantumSavory.Qubit"><code>QuantumSavory.Qubit</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Specifies that a given register slot contains qubits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/traits_and_defaults.jl#L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.Qumode"><a class="docstring-binding" href="#QuantumSavory.Qumode"><code>QuantumSavory.Qumode</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Specifies that a given register slot contains qumodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/traits_and_defaults.jl#L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.RegRef"><a class="docstring-binding" href="#QuantumSavory.RegRef"><code>QuantumSavory.RegRef</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A reference to a <a href="#QuantumSavory.Register"><code>Register</code></a> slot, convenient for use with functions like <a href="../register_interface/#apply!"><code>apply!</code></a>, etc.</p><pre><code class="language-julia-repl hljs">julia&gt; r = Register(2)
       initialize!(r[1], X₁)
       observable(r[1], X)
0.9999999999999998 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/states_registers.jl#L44-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.Register"><a class="docstring-binding" href="#QuantumSavory.Register"><code>QuantumSavory.Register</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>The main data structure in <code>QuantumSavory</code>, used to represent a quantum register in an arbitrary formalism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/states_registers.jl#L12-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.RegisterNet"><a class="docstring-binding" href="#QuantumSavory.RegisterNet"><code>QuantumSavory.RegisterNet</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A network of <a href="#QuantumSavory.Register"><code>Register</code></a>s with convenient graph API as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/networks.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.RegisterNet-Tuple{Graphs.SimpleGraphs.SimpleGraph, Any}"><a class="docstring-binding" href="#QuantumSavory.RegisterNet-Tuple{Graphs.SimpleGraphs.SimpleGraph, Any}"><code>QuantumSavory.RegisterNet</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Construct a <a href="#QuantumSavory.RegisterNet"><code>RegisterNet</code></a> from a given list of <a href="#QuantumSavory.Register"><code>Register</code></a>s and a graph.</p><pre><code class="language-julia-repl hljs">julia&gt; graph = grid([2,2]) # from Graphs.jl
{4, 4} undirected simple Int64 graph

julia&gt; registers = [Register(1), Register(2), Register(1), Register(2)]
4-element Vector{Register}:
 Register with 1 slots: [ Qubit ]
  Slots:
    nothing
 Register with 2 slots: [ Qubit | Qubit ]
  Slots:
    nothing
    nothing
 Register with 1 slots: [ Qubit ]
  Slots:
    nothing
 Register with 2 slots: [ Qubit | Qubit ]
  Slots:
    nothing
    nothing

julia&gt; net = RegisterNet(graph, registers)
A network of 4 registers in a graph of 4 edges


julia&gt; neighbors(net, 1) # from Graphs.jl
2-element Vector{Int64}:
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/networks.jl#L65-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.RegisterNet-Tuple{Vector{Register}}"><a class="docstring-binding" href="#QuantumSavory.RegisterNet-Tuple{Vector{Register}}"><code>QuantumSavory.RegisterNet</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Construct a <a href="#QuantumSavory.RegisterNet"><code>RegisterNet</code></a> from a given list of <a href="#QuantumSavory.Register"><code>Register</code></a>s, defaulting to a chain topology.</p><pre><code class="language-julia-repl hljs">julia&gt; net = RegisterNet([Register(2), Register(4), Register(2)])
A network of 3 registers in a graph of 2 edges

julia&gt; neighbors(net,2) # from Graphs.jl
2-element Vector{Int64}:
 1
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/networks.jl#L108-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.T1Decay"><a class="docstring-binding" href="#QuantumSavory.T1Decay"><code>QuantumSavory.T1Decay</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A background describing the T₁ decay of a two-level system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backgrounds.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.T2Dephasing"><a class="docstring-binding" href="#QuantumSavory.T2Dephasing"><code>QuantumSavory.T2Dephasing</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A background describing the T₂ dephasing of a two-level system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backgrounds.jl#L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.Tag"><a class="docstring-binding" href="#QuantumSavory.Tag"><code>QuantumSavory.Tag</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Tags are used to represent classical metadata describing the state (or even history) of nodes and their registers. The library allows the construction of custom tags using the <code>Tag</code> constructor. Currently tags are implemented as instances of a <a href="https://github.com/MasonProtter/SumTypes.jl">sum type</a> and have fairly constrained structure. Most of them are constrained to contain only Symbol instances and integers.</p><p>Here is an example of such a generic tag:</p><pre><code class="language-julia-repl hljs">julia&gt; Tag(:sometagdescriptor, 1, 2, -3)
SymbolIntIntInt(:sometagdescriptor, 1, 2, -3)::Tag</code></pre><p>A tag can have a custom <code>DataType</code> as first argument, in which case additional customizability in printing is available. E.g. consider the [<code>EntanglementHistory</code>] tag used to track how pairs were entangled before a swap happened.</p><pre><code class="language-julia-repl hljs">julia&gt; using QuantumSavory.ProtocolZoo: EntanglementHistory

julia&gt; Tag(EntanglementHistory, 1, 2, 3, 4, 5)
Was entangled to 1.2, but swapped with .5 which was entangled to 3.4</code></pre><p>See also: <a href="#QuantumSavory.tag!-Tuple{RegRef, Any}"><code>tag!</code></a>, <a href="#QuantumSavory.query-Union{Tuple{N}, Tuple{MessageBuffer, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><code>query</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/tags.jl#L3-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.apply!-Tuple{Vector{Register}, Union{Tuple{Vararg{Int64}}, AbstractVector{&lt;:Int64}}, Any}"><a class="docstring-binding" href="#QuantumInterface.apply!-Tuple{Vector{Register}, Union{Tuple{Vararg{Int64}}, AbstractVector{&lt;:Int64}}, Any}"><code>QuantumInterface.apply!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Apply a given operation on the given set of register slots.</p><p><code>apply!([regA, regB], [slot1, slot2], Gates.CNOT)</code> would apply a CNOT gate on the content of the given registers at the given slots. The appropriate representation of the gate is used, depending on the formalism under which a quantum state is stored in the given registers. The Hilbert spaces of the registers are automatically joined if necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/baseops/apply.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumInterface.traceout!-Tuple{Register, Int64}"><a class="docstring-binding" href="#QuantumInterface.traceout!-Tuple{Register, Int64}"><code>QuantumInterface.traceout!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Delete the given slot of the given register.</p><p><code>traceout!(reg, slot)</code> would reset (perform a partial trace) over the given subsystem. The Hilbert space of the register gets automatically shrunk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/baseops/traceout.jl#L32-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.channel-Tuple{RegisterNet, Vararg{Any}}"><a class="docstring-binding" href="#QuantumSavory.channel-Tuple{RegisterNet, Vararg{Any}}"><code>QuantumSavory.channel</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Get a handle to a classical channel between two registers.</p><p>Usually used for sending classical messages between registers. It can be used for receiving as well, but a more convenient choice is <a href="#QuantumSavory.messagebuffer-Tuple{RegisterNet, Int64}"><code>messagebuffer</code></a>, which is a message buffer listening to <strong>all</strong> channels sending to a given destination register.</p><pre><code class="language-julia-repl hljs">julia&gt; net = RegisterNet([Register(2), Register(2), Register(2)]) # defaults to a chain topology
A network of 3 registers in a graph of 2 edges

julia&gt; channel(net, 1=&gt;2)
ConcurrentSim.DelayQueue{Tag}(ConcurrentSim.QueueStore{Tag, Int64}, 0.0)

julia&gt; channel(net, 1=&gt;2)
ConcurrentSim.DelayQueue{Tag}(ConcurrentSim.QueueStore{Tag, Int64}, 0.0)

julia&gt; channel(net, 1=&gt;2) === channel(net, net[1]=&gt;net[2])
true</code></pre><p>See also: <a href="#QuantumSavory.qchannel-Tuple{RegisterNet, Vararg{Any}}"><code>qchannel</code></a>, <a href="#QuantumSavory.messagebuffer-Tuple{RegisterNet, Int64}"><code>messagebuffer</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/networks.jl#L143-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.findfreeslot-Tuple{Register}"><a class="docstring-binding" href="#QuantumSavory.findfreeslot-Tuple{Register}"><code>QuantumSavory.findfreeslot</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Find an empty unlocked slot in a given <a href="#QuantumSavory.Register"><code>Register</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = Register(3); initialize!(reg[1], X); lock(reg[2]);

julia&gt; findfreeslot(reg) == reg[3]
true

julia&gt; lock(findfreeslot(reg));

julia&gt; findfreeslot(reg) |&gt; isnothing
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/queries.jl#L388-L402">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.generate_map"><a class="docstring-binding" href="#QuantumSavory.generate_map"><code>QuantumSavory.generate_map</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Generates a default map with country and state boundaries and returns a GeoAxis. The returned GeoAxis can be used as an input for registernetplot_axis.</p><p>The <code>Tyler</code> package must be installed and imported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/plots.jl#L26-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.initialize!-Tuple{Union{Tuple{Vararg{Register}}, AbstractVector{&lt;:Register}}, Union{Tuple{Vararg{Int64}}, AbstractVector{&lt;:Int64}}, Any}"><a class="docstring-binding" href="#QuantumSavory.initialize!-Tuple{Union{Tuple{Vararg{Register}}, AbstractVector{&lt;:Register}}, Union{Tuple{Vararg{Int64}}, AbstractVector{&lt;:Int64}}, Any}"><code>QuantumSavory.initialize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Set the state of a given set of registers.</p><p><code>initialize!([regA,regB], [slot1,slot2], state)</code> would set the state of the given slots in the given registers to <code>state</code>. <code>state</code> can be any supported state representation, e.g., kets or density matrices from <code>QuantumOptics.jl</code> or tableaux from <code>QuantumClifford.jl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/baseops/initialize.jl#L9-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.krausops"><a class="docstring-binding" href="#QuantumSavory.krausops"><code>QuantumSavory.krausops</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>For a given background noise type, provide the corresponding Kraus operators, in a QuantumOptics.jl representation.</p><p>See also: <a href="#QuantumSavory.paulinoise"><code>paulinoise</code></a>, <a href="#QuantumSavory.lindbladop"><code>lindbladop</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backends/quantumoptics/uptotime.jl#L52-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.krausops-Tuple{Depolarization, Any}"><a class="docstring-binding" href="#QuantumSavory.krausops-Tuple{Depolarization, Any}"><code>QuantumSavory.krausops</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Kraus operators for depolarization are <code>√(1-3p/4) I, √p/2 * X, √p/2 * Y, √p/2 Z</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backends/quantumoptics/uptotime.jl#L99-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.krausops-Tuple{T1Decay, Any}"><a class="docstring-binding" href="#QuantumSavory.krausops-Tuple{T1Decay, Any}"><code>QuantumSavory.krausops</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Kraus operators for a T₁ process</p><ul><li><code>A₁ = |0⟩⟨0| + √(1-γ) |1⟩⟨1|</code></li><li><code>A₂ = √γ |0⟩⟨1|</code></li><li><code>λ = 1 - exp(-Δt/T₁)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backends/quantumoptics/uptotime.jl#L63-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.krausops-Tuple{T2Dephasing, Any}"><a class="docstring-binding" href="#QuantumSavory.krausops-Tuple{T2Dephasing, Any}"><code>QuantumSavory.krausops</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Kraus operators for a T₂ process</p><p>One option is the following (more popular in the literature):</p><ul><li><code>P₁ = |0⟩⟨0| + √(1-λ) |1⟩⟨1|</code></li><li><code>P₂ = √λ |1⟩⟨1|</code></li><li><code>λ = 1 - exp(-2Δt/T₂)</code></li></ul><p>An equivalent option is (more convenient when converting to a Pauli error channel):</p><ul><li><code>P₁′ = √(1-p/2) I</code></li><li><code>P₂′ = √(p/2) Z</code></li><li><code>p = 1 - exp(-Δt/T₂)</code></li></ul><p>These two options are equivalent under a unitary transformation. We implement the second one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backends/quantumoptics/uptotime.jl#L75-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.lindbladop"><a class="docstring-binding" href="#QuantumSavory.lindbladop"><code>QuantumSavory.lindbladop</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>For a given background noise type, provide the corresponding Lindblad collapse operator, in a QuantumOptics.jl representation.</p><p>See also: <a href="#QuantumSavory.paulinoise"><code>paulinoise</code></a>, <a href="#QuantumSavory.krausops"><code>krausops</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backends/quantumoptics/noninstant.jl#L16-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.lindbladop-Tuple{AmplitudeDamping, Any}"><a class="docstring-binding" href="#QuantumSavory.lindbladop-Tuple{AmplitudeDamping, Any}"><code>QuantumSavory.lindbladop</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>1/√τ â</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backends/quantumoptics/noninstant.jl#L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.lindbladop-Tuple{T1Decay}"><a class="docstring-binding" href="#QuantumSavory.lindbladop-Tuple{T1Decay}"><code>QuantumSavory.lindbladop</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>1/√T₁ |0⟩⟨1|</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backends/quantumoptics/noninstant.jl#L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.lindbladop-Tuple{T2Dephasing}"><a class="docstring-binding" href="#QuantumSavory.lindbladop-Tuple{T2Dephasing}"><code>QuantumSavory.lindbladop</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>1/√(2T₂) Z</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backends/quantumoptics/noninstant.jl#L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.messagebuffer-Tuple{RegisterNet, Int64}"><a class="docstring-binding" href="#QuantumSavory.messagebuffer-Tuple{RegisterNet, Int64}"><code>QuantumSavory.messagebuffer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">messagebuffer(
    net::RegisterNet,
    dst::Int64
) -&gt; MessageBuffer{Tag}
</code></pre><p>Get a handle to a classical message buffer corresponding to all channels sending to a given destination register.</p><p>See also: <a href="#QuantumSavory.channel-Tuple{RegisterNet, Vararg{Any}}"><code>channel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/networks.jl#L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.messagebuffer-Tuple{Union{RegRef, Register}}"><a class="docstring-binding" href="#QuantumSavory.messagebuffer-Tuple{Union{RegRef, Register}}"><code>QuantumSavory.messagebuffer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">messagebuffer(
    ref::Union{RegRef, Register}
) -&gt; MessageBuffer{Tag}
</code></pre><p>Get a handle to a classical message buffer corresponding to all channels sending to a given destination register.</p><p>See also: <a href="#QuantumSavory.channel-Tuple{RegisterNet, Vararg{Any}}"><code>channel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/networks.jl#L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.observable-Tuple{Union{Tuple{Vararg{Register}}, AbstractVector{&lt;:Register}}, Union{Tuple{Vararg{Int64}}, AbstractVector{&lt;:Int64}}, Any}"><a class="docstring-binding" href="#QuantumSavory.observable-Tuple{Union{Tuple{Vararg{Register}}, AbstractVector{&lt;:Register}}, Union{Tuple{Vararg{Int64}}, AbstractVector{&lt;:Int64}}, Any}"><code>QuantumSavory.observable</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate the expectation value of a quantum observable on the given register and slot.</p><p><code>observable([regA, regB], [slot1, slot2], obs)</code> would calculate the expectation value of the <code>obs</code> observable (using the appropriate formalism, depending on the state representation in the given registers).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/baseops/observable.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.onchange"><a class="docstring-binding" href="#QuantumSavory.onchange"><code>QuantumSavory.onchange</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Wait for changes to occur on a <a href="#QuantumSavory.MessageBuffer"><code>MessageBuffer</code></a> or <a href="#QuantumSavory.Register"><code>Register</code></a>. By specifying a second argument, you can filter what type of events are waited on. E.g. <code>onchange(r, Tag)</code> will wait only on changes to tags and metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/messagebuffer.jl#L106-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.paulinoise"><a class="docstring-binding" href="#QuantumSavory.paulinoise"><code>QuantumSavory.paulinoise</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>For a given background noise type, provide the corresponding (potentially twirled) Pauli operators and the probabilities for the operators to act, in a QuantumClifford.jl representation.</p><p>See also: <a href="#QuantumSavory.krausops"><code>krausops</code></a>, <a href="#QuantumSavory.lindbladop"><code>lindbladop</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backends/clifford/uptotime.jl#L14-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.paulinoise-Tuple{Depolarization, Any}"><a class="docstring-binding" href="#QuantumSavory.paulinoise-Tuple{Depolarization, Any}"><code>QuantumSavory.paulinoise</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Pauli operator and probability of its application for a Depolarization process.</p><p><code>((p/4, X), (p/4, Y), (p/4, Z))</code> for <code>p = 1-exp(-Δt/τ)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backends/clifford/uptotime.jl#L31-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.paulinoise-Tuple{T2Dephasing, Any}"><a class="docstring-binding" href="#QuantumSavory.paulinoise-Tuple{T2Dephasing, Any}"><code>QuantumSavory.paulinoise</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>The Pauli operator and probability of its application for a T₂ process.</p><p><code>(1-exp(-Δt/T₂)) / 2</code> and <code>Z</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/backends/clifford/uptotime.jl#L21-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.project_traceout!"><a class="docstring-binding" href="#QuantumSavory.project_traceout!"><code>QuantumSavory.project_traceout!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Perform a projective measurement on the given slot of the given register.</p><p><code>project_traceout!(reg, slot, [stateA, stateB])</code> performs a projective measurement, projecting on either <code>stateA</code> or <code>stateB</code>, returning the index of the subspace on which the projection happened. It assumes the list of possible states forms a basis for the Hilbert space. The Hilbert space of the register is automatically shrunk.</p><p>A basis object can be specified on its own as well, e.g. <code>project_traceout!(reg, slot, basis)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/baseops/traceout.jl#L53-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.qchannel-Tuple{RegisterNet, Vararg{Any}}"><a class="docstring-binding" href="#QuantumSavory.qchannel-Tuple{RegisterNet, Vararg{Any}}"><code>QuantumSavory.qchannel</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Get a handle to a quantum channel between two registers.</p><pre><code class="language-julia-repl hljs">julia&gt; net = RegisterNet([Register(2), Register(2), Register(2)]) # defaults to a chain topology
A network of 3 registers in a graph of 2 edges

julia&gt; qchannel(net, 1=&gt;2)
QuantumChannel{Qubit}(Qubit(), ConcurrentSim.DelayQueue{Register}(ConcurrentSim.QueueStore{Register, Int64}, 0.0), nothing)

julia&gt; qchannel(net, 1=&gt;2) === qchannel(net, net[1]=&gt;net[2])
true</code></pre><p>See also: <a href="#QuantumSavory.channel-Tuple{RegisterNet, Vararg{Any}}"><code>channel</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/networks.jl#L169-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.query-Union{Tuple{N}, Tuple{MessageBuffer, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><a class="docstring-binding" href="#QuantumSavory.query-Union{Tuple{N}, Tuple{MessageBuffer, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><code>QuantumSavory.query</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">query(
    mb::MessageBuffer,
    queryargs::Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}...
) -&gt; Union{Nothing, NamedTuple{(:depth, :src, :tag), &lt;:Tuple{Int64, Any, Any}}}
</code></pre><p>You are advised to actually use <a href="../tag_query/#querydelete!"><code>querydelete!</code></a>, not <code>query</code> when working with classical message buffers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/queries.jl#L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.query-Union{Tuple{N}, Tuple{Union{RegRef, Register}, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><a class="docstring-binding" href="#QuantumSavory.query-Union{Tuple{N}, Tuple{Union{RegRef, Register}, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><code>QuantumSavory.query</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">query(
    reg::Union{RegRef, Register},
    queryargs::Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}...;
    locked,
    assigned,
    filo
) -&gt; Any
</code></pre><p>A query function searching for the first slot in a register that has a given tag.</p><p>Wildcards are supported (instances of <code>Wildcard</code> also available as the constants <a href="#QuantumSavory.W"><code>W</code></a> or the emoji <a href="#QuantumSavory.❓"><code>❓</code></a> which can be entered as <code>\:question:</code> in the REPL). Predicate functions are also supported (they have to be <code>Int</code>↦<code>Bool</code> functions). The order of query lookup can be specified in terms of FIFO or FILO and defaults to FILO if not specified. The keyword arguments <code>locked</code> and <code>assigned</code> can be used to check, respectively, whether the given slot is locked or whether it contains a quantum state. The keyword argument <code>filo</code> can be used to specify whether the search should be done in a FIFO or FILO order, defaulting to <code>filo=true</code> (i.e. a stack-like behavior).</p><pre><code class="language-julia-repl hljs">julia&gt; r = Register(10);
       tag!(r[1], :symbol, 2, 3);
       tag!(r[2], :symbol, 4, 5);


julia&gt; query(r, :symbol, 4, 5)
(slot = Slot 2, id = 4, tag = SymbolIntInt(:symbol, 4, 5)::Tag)

julia&gt; lock(r[1]);

julia&gt; query(r, :symbol, 4, 5; locked=false) |&gt; isnothing
false

julia&gt; query(r, :symbol, ❓, 3)
(slot = Slot 1, id = 3, tag = SymbolIntInt(:symbol, 2, 3)::Tag)

julia&gt; query(r, :symbol, ❓, 3; assigned=true) |&gt; isnothing
true

julia&gt; query(r, :othersym, ❓, ❓) |&gt; isnothing
true

julia&gt; tag!(r[5], Int, 4, 5);

julia&gt; query(r, Float64, 4, 5) |&gt; isnothing
true

julia&gt; query(r, Int, 4, &gt;(7)) |&gt; isnothing
true

julia&gt; query(r, Int, 4, &lt;(7))
(slot = Slot 5, id = 5, tag = TypeIntInt(Int64, 4, 5)::Tag)</code></pre><p>A <a href="#QuantumSavory.query-Union{Tuple{N}, Tuple{MessageBuffer, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><code>query</code></a> can be on on a single slot of a register:</p><pre><code class="language-julia-repl hljs">julia&gt; r = Register(5);

julia&gt; tag!(r[2], :symbol, 2, 3);

julia&gt; query(r[2], :symbol, 2, 3)
(slot = Slot 2, id = 6, tag = SymbolIntInt(:symbol, 2, 3)::Tag)

julia&gt; query(r[3], :symbol, 2, 3) === nothing
true

julia&gt; queryall(r[2], :symbol, 2, 3)
1-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:
 (slot = Slot 2, id = 6, tag = SymbolIntInt(:symbol, 2, 3)::Tag)</code></pre><p>See also: <a href="../tag_query/#queryall"><code>queryall</code></a>, <a href="#QuantumSavory.tag!-Tuple{RegRef, Any}"><code>tag!</code></a>, <a href="#QuantumSavory.W"><code>W</code></a>, <a href="#QuantumSavory.❓"><code>❓</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/queries.jl#L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.queryall-Union{Tuple{N}, Tuple{Union{RegRef, Register}, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><a class="docstring-binding" href="#QuantumSavory.queryall-Union{Tuple{N}, Tuple{Union{RegRef, Register}, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><code>QuantumSavory.queryall</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">queryall(
    reg::Union{RegRef, Register},
    queryargs::Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}...;
    filo,
    kwargs...
) -&gt; Any
</code></pre><p>A query function that returns all slots of a register that have a given tag, with support for predicates and wildcards.</p><pre><code class="language-julia-repl hljs">julia&gt; r = Register(10);
       tag!(r[1], :symbol, 2, 3);
       tag!(r[2], :symbol, 4, 5);

julia&gt; queryall(r, :symbol, ❓, ❓)
2-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:
 (slot = Slot 2, id = 2, tag = SymbolIntInt(:symbol, 4, 5)::Tag)
 (slot = Slot 1, id = 1, tag = SymbolIntInt(:symbol, 2, 3)::Tag)

julia&gt; queryall(r, :symbol, ❓, &gt;(4))
1-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:
 (slot = Slot 2, id = 2, tag = SymbolIntInt(:symbol, 4, 5)::Tag)

julia&gt; queryall(r, :symbol, ❓, &gt;(5))
@NamedTuple{slot::RegRef, id::Int128, tag::Tag}[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/queries.jl#L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.querydelete!-Tuple{MessageBuffer, Vararg{Any}}"><a class="docstring-binding" href="#QuantumSavory.querydelete!-Tuple{MessageBuffer, Vararg{Any}}"><code>QuantumSavory.querydelete!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">querydelete!(
    mb::MessageBuffer,
    args...
) -&gt; Union{Nothing, @NamedTuple{src::Union{Nothing, Int64}, tag::T} where T}
</code></pre><p>A <a href="#QuantumSavory.query-Union{Tuple{N}, Tuple{MessageBuffer, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><code>query</code></a> for classical message buffers that also deletes the message out of the buffer.</p><pre><code class="language-julia-repl hljs">julia&gt; net = RegisterNet([Register(3), Register(2)])
A network of 2 registers in a graph of 1 edges

julia&gt; put!(channel(net, 1=&gt;2), Tag(:my_tag));

julia&gt; put!(channel(net, 1=&gt;2), Tag(:another_tag, 123, 456));

julia&gt; query(messagebuffer(net, 2), :my_tag)

julia&gt; run(get_time_tracker(net))

julia&gt; query(messagebuffer(net, 2), :my_tag)
(depth = 1, src = 1, tag = Symbol(:my_tag)::Tag)

julia&gt; querydelete!(messagebuffer(net, 2), :my_tag)
@NamedTuple{src::Union{Nothing, Int64}, tag::Tag}((1, Symbol(:my_tag)::Tag))

julia&gt; querydelete!(messagebuffer(net, 2), :my_tag) === nothing
true

julia&gt; querydelete!(messagebuffer(net, 2), :another_tag, ❓, ❓)
@NamedTuple{src::Union{Nothing, Int64}, tag::Tag}((1, SymbolIntInt(:another_tag, 123, 456)::Tag))

julia&gt; querydelete!(messagebuffer(net, 2), :another_tag, ❓, ❓) === nothing
true</code></pre><p>You can also wait on a message buffer for a message to arrive before running a query:</p><pre><code class="language-julia-repl hljs">julia&gt; using ResumableFunctions; using ConcurrentSim;

julia&gt; net = RegisterNet([Register(3), Register(2), Register(3)])
A network of 3 registers in a graph of 2 edges

julia&gt; env = get_time_tracker(net);

julia&gt; @resumable function receive_tags(env)
           while true
               mb = messagebuffer(net, 2)
               @yield onchange(mb)
               msg = querydelete!(mb, :second_tag, ❓, ❓)
               print(&quot;t=$(now(env)): query returns &quot;)
               if isnothing(msg)
                   println(&quot;nothing&quot;)
               else
                   println(&quot;$(msg.tag) received from node $(msg.src)&quot;)
               end
           end
       end
receive_tags (generic function with 1 method)

julia&gt; @resumable function send_tags(env)
           @yield timeout(env, 1.0)
           put!(channel(net, 1=&gt;2), Tag(:my_tag))
           @yield timeout(env, 2.0)
           put!(channel(net, 3=&gt;2), Tag(:second_tag, 123, 456))
       end
send_tags (generic function with 1 method)

julia&gt; @process send_tags(env);

julia&gt; @process receive_tags(env);

julia&gt; run(env, 10)
t=1.0: query returns nothing
t=3.0: query returns SymbolIntInt(:second_tag, 123, 456)::Tag received from node 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/queries.jl#L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.querydelete!-Tuple{Union{RegRef, Register}, Vararg{Any}}"><a class="docstring-binding" href="#QuantumSavory.querydelete!-Tuple{Union{RegRef, Register}, Vararg{Any}}"><code>QuantumSavory.querydelete!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">querydelete!(
    reg::Union{RegRef, Register},
    args...;
    kwa...
) -&gt; Any
</code></pre><p>A <a href="#QuantumSavory.query-Union{Tuple{N}, Tuple{MessageBuffer, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><code>query</code></a> for <a href="#QuantumSavory.Register"><code>Register</code></a> or a register slot (i.e. a <a href="#QuantumSavory.RegRef"><code>RegRef</code></a>) that also deletes the tag.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = Register(3)
       tag!(reg[1], :tagA, 1, 2, 3)
       tag!(reg[2], :tagA, 10, 20, 30)
       tag!(reg[2], :tagB, 6, 7, 8);

julia&gt; queryall(reg, :tagA, ❓, ❓, ❓)
2-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:
 (slot = Slot 2, id = 4, tag = SymbolIntIntInt(:tagA, 10, 20, 30)::Tag)
 (slot = Slot 1, id = 3, tag = SymbolIntIntInt(:tagA, 1, 2, 3)::Tag)

julia&gt; querydelete!(reg, :tagA, ❓, ❓, ❓)
(slot = Slot 2, id = 4, tag = SymbolIntIntInt(:tagA, 10, 20, 30)::Tag)

julia&gt; queryall(reg, :tagA, ❓, ❓, ❓)
1-element Vector{@NamedTuple{slot::RegRef, id::Int128, tag::Tag}}:
 (slot = Slot 1, id = 3, tag = SymbolIntIntInt(:tagA, 1, 2, 3)::Tag)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/queries.jl#L331">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.registernetplot"><a class="docstring-binding" href="#QuantumSavory.registernetplot"><code>QuantumSavory.registernetplot</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Draw the given register network.</p><p>Requires a Makie backend be already imported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/plots.jl#L1-L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.registernetplot!"><a class="docstring-binding" href="#QuantumSavory.registernetplot!"><code>QuantumSavory.registernetplot!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Draw the given register network on a given Makie axis.</p><p>Requires a Makie backend be already imported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/plots.jl#L6-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.registernetplot_axis"><a class="docstring-binding" href="#QuantumSavory.registernetplot_axis"><code>QuantumSavory.registernetplot_axis</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Draw the given register network on a given Makie axis or subfigure and modify the axis with numerous visualization enhancements.</p><p>Requires a Makie backend be already imported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/plots.jl#L11-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.resourceplot_axis"><a class="docstring-binding" href="#QuantumSavory.resourceplot_axis"><code>QuantumSavory.resourceplot_axis</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Draw the various resources and locks stored in the given meta-graph on a given Makie axis.</p><p>Requires a Makie backend be already imported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/plots.jl#L16-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.subsystemcompose-Tuple{Union{Tuple{Vararg{Register}}, AbstractVector{&lt;:Register}}, Any}"><a class="docstring-binding" href="#QuantumSavory.subsystemcompose-Tuple{Union{Tuple{Vararg{Register}}, AbstractVector{&lt;:Register}}, Any}"><code>QuantumSavory.subsystemcompose</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Ensure that the all slots of the given registers are represented by one single state object, i.e. that all the register slots are tracked in the same Hilbert space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/baseops/subsystemcompose.jl#L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.tag!-Tuple{RegRef, Any}"><a class="docstring-binding" href="#QuantumSavory.tag!-Tuple{RegRef, Any}"><code>QuantumSavory.tag!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tag!(ref::RegRef, tag) -&gt; Int128
</code></pre><p>Assign a tag to a slot in a register.</p><p>See also: <a href="#QuantumSavory.query-Union{Tuple{N}, Tuple{MessageBuffer, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><code>query</code></a>, <a href="#QuantumSavory.untag!-Tuple{Union{RegRef, Register}, Integer}"><code>untag!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/queries.jl#L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.untag!-Tuple{Union{RegRef, Register}, Integer}"><a class="docstring-binding" href="#QuantumSavory.untag!-Tuple{Union{RegRef, Register}, Integer}"><code>QuantumSavory.untag!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">untag!(
    ref::Union{RegRef, Register},
    id::Integer
) -&gt; @NamedTuple{tag::Tag, slot::Int64, time::Float64}
</code></pre><p>Remove the tag with the given id from a <a href="#QuantumSavory.RegRef"><code>RegRef</code></a> or a <a href="#QuantumSavory.Register"><code>Register</code></a>.</p><p>To remove a tag based on a query, use <a href="../tag_query/#querydelete!"><code>querydelete!</code></a> instead.</p><p>See also: <a href="../tag_query/#querydelete!"><code>querydelete!</code></a>, <a href="#QuantumSavory.query-Union{Tuple{N}, Tuple{MessageBuffer, Vararg{Union{QuantumSavory.Wildcard, Int64, DataType, Function, Symbol}, N}}} where N"><code>query</code></a>, <a href="#QuantumSavory.tag!-Tuple{RegRef, Any}"><code>tag!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/queries.jl#L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumSavory.uptotime!"><a class="docstring-binding" href="#QuantumSavory.uptotime!"><code>QuantumSavory.uptotime!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Evolve all the states in a register to a given time, according to the various backgrounds that they might have.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = Register(2, T1Decay(1.0))
Register with 2 slots: [ Qubit | Qubit ]
  Slots:
    nothing
    nothing

julia&gt; initialize!(reg[1], X₁)
       observable(reg[1], σᶻ)
0.0 + 0.0im

julia&gt; uptotime!(reg[1], 10)
       observable(reg[1], Z)
0.9999546000702374 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/f62c3c22446cf43d91f6a3240ceee0742bd4259a/src/baseops/uptotime.jl#L1-L19">source</a></section></details></article><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../references/">« References</a><a class="docs-footer-nextpage" href="../API_CircuitZoo/">CircuitZoo API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 6 February 2026 17:01">Friday 6 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

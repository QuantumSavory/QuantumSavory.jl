<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ProtocolZoo API · QuantumSavory.jl</title><meta name="title" content="ProtocolZoo API · QuantumSavory.jl"/><meta property="og:title" content="ProtocolZoo API · QuantumSavory.jl"/><meta property="twitter:title" content="ProtocolZoo API · QuantumSavory.jl"/><meta name="description" content="Documentation for QuantumSavory.jl."/><meta property="og:description" content="Documentation for QuantumSavory.jl."/><meta property="twitter:description" content="Documentation for QuantumSavory.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="QuantumSavory.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumSavory.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">QuantumSavory.jl</a></li><li><a class="tocitem" href="../manual/">Getting Started Manual</a></li><li><span class="tocitem">Explanations</span><ul><li><a class="tocitem" href="../explanations/">Explanations</a></li><li><a class="tocitem" href="../register_interface/">Register Interface</a></li><li><a class="tocitem" href="../properties/">Properties</a></li><li><a class="tocitem" href="../backgrounds/">Background Noise</a></li><li><a class="tocitem" href="../symbolics/">Symbolic Expressions</a></li><li><a class="tocitem" href="../tag_query/">Tagging and Querying</a></li><li><a class="tocitem" href="../backendsimulator/">Backend Simulators</a></li><li><a class="tocitem" href="../discreteeventsimulator/">Discrete Event Simulator</a></li><li><a class="tocitem" href="../visualizations/">Visualizations</a></li></ul></li><li><span class="tocitem">How-To Guides</span><ul><li><a class="tocitem" href="../howto/">How-To Guides</a></li><li><a class="tocitem" href="../howto/firstgenrepeater/firstgenrepeater/">1st-gen Repeater - low level implementation</a></li><li><a class="tocitem" href="../howto/firstgenrepeater/firstgenrepeater-clifford/">1st-gen Repeater - Clifford formalism</a></li><li><a class="tocitem" href="../howto/firstgenrepeater_v2/firstgenrepeater_v2/">1st-gen Repeater - simpler implementation</a></li><li><a class="tocitem" href="../howto/congestionchain/congestionchain/">Congestion on a Repeater Chain</a></li><li><a class="tocitem" href="../howto/colorcentermodularcluster/colorcentermodularcluster/">Cluster States in Atomic Memories</a></li><li><a class="tocitem" href="../howto/simpleswitch/simpleswitch/">Entanglement Switch</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial/">Tutorials</a></li><li><a class="tocitem" href="../tutorial/noninstantgate/">Gate Duration</a></li><li><a class="tocitem" href="../tutorial/state_explorer/">State Explorer</a></li></ul></li><li><span class="tocitem">References</span><ul><li><a class="tocitem" href="../references/">References</a></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../API_CircuitZoo/">CircuitZoo API</a></li><li><a class="tocitem" href="../API_StatesZoo/">StatesZoo API</a></li><li class="is-active"><a class="tocitem" href>ProtocolZoo API</a><ul class="internal"><li><a class="tocitem" href="#Autogenerated-API-list-for-QuantumSavory.ProtocolZoo"><span>Autogenerated API list for <code>QuantumSavory.ProtocolZoo</code></span></a></li></ul></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">References</a></li><li class="is-active"><a href>ProtocolZoo API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ProtocolZoo API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumSavory.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/master/docs/src/API_ProtocolZoo.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Predefined-Networking-Protocols"><a class="docs-heading-anchor" href="#Predefined-Networking-Protocols">Predefined Networking Protocols</a><a id="Predefined-Networking-Protocols-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-Networking-Protocols" title="Permalink"></a></h1><style>
    .content table td {
        padding-top: 0 !important;
        padding-bottom: 0 !important;
    }
</style><p>The submodule <code>QuantumSavory.ProtocolZoo</code> provides models for many common quantum networking protocols, including the details of their discrete event scheduling and simulation.</p><h2 id="Autogenerated-API-list-for-QuantumSavory.ProtocolZoo"><a class="docs-heading-anchor" href="#Autogenerated-API-list-for-QuantumSavory.ProtocolZoo">Autogenerated API list for <code>QuantumSavory.ProtocolZoo</code></a><a id="Autogenerated-API-list-for-QuantumSavory.ProtocolZoo-1"></a><a class="docs-heading-anchor-permalink" href="#Autogenerated-API-list-for-QuantumSavory.ProtocolZoo" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.CutoffProt" href="#QuantumSavory.ProtocolZoo.CutoffProt"><code>QuantumSavory.ProtocolZoo.CutoffProt</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CutoffProt{LT} &lt;: QuantumSavory.ProtocolZoo.AbstractProtocol</code></pre><p>A protocol running at a node, checking periodically for any qubits in the node that have remained unused for more than the retention period of the qubit and emptying such slots.</p><p>If coordination messages are exchanged during deletions (instances of the type <code>EntanglementDelete</code>), then a <a href="#QuantumSavory.ProtocolZoo.EntanglementTracker"><code>EntanglementTracker</code></a> protocol needs to also run, to act on such messages.</p><ul><li><p><code>sim</code>: time-and-schedule-tracking instance from <code>ConcurrentSim</code></p></li><li><p><code>net</code>: a network graph of registers</p></li><li><p><code>node</code>: the vertex index of the node on which the protocol is running</p></li><li><p><code>period</code>: time period between successive queries on the node (<code>nothing</code> for queuing up)</p></li><li><p><code>retention_time</code>: time after which a slot is emptied</p></li><li><p><code>announce</code>: if <code>true</code>, synchronization messages are sent after a deletion to the node containing the other entangled qubit</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/cutoff.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.EntanglementConsumer" href="#QuantumSavory.ProtocolZoo.EntanglementConsumer"><code>QuantumSavory.ProtocolZoo.EntanglementConsumer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EntanglementConsumer{LT} &lt;: QuantumSavory.ProtocolZoo.AbstractProtocol</code></pre><p>A protocol running between two nodes, checking periodically for any entangled pairs between the two nodes and consuming/emptying the qubit slots.</p><ul><li><p><code>sim</code>: time-and-schedule-tracking instance from <code>ConcurrentSim</code></p></li><li><p><code>net</code>: a network graph of registers</p></li><li><p><code>nodeA</code>: the vertex index of node A</p></li><li><p><code>nodeB</code>: the vertex index of node B</p></li><li><p><code>period</code>: time period between successive queries on the nodes (<code>nothing</code> for queuing up and waiting for available pairs)</p></li><li><p><code>tag</code>: tag type which the consumer is looking for – the consumer query will be <code>query(node, EntanglementConsumer.tag, remote_node)</code> and it will be expected that <code>remote_node</code> possesses the symmetric reciprocal tag; defaults to <code>EntanglementCounterpart</code></p></li><li><p><code>log</code>: stores the time and resulting observable from querying nodeA and nodeB for <code>EntanglementCounterpart</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/ProtocolZoo.jl#L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.EntanglementCounterpart" href="#QuantumSavory.ProtocolZoo.EntanglementCounterpart"><code>QuantumSavory.ProtocolZoo.EntanglementCounterpart</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EntanglementCounterpart</code></pre><p>Indicates the current entanglement status with a remote node&#39;s slot. Added when a new entanglement is generated through <a href="#QuantumSavory.ProtocolZoo.EntanglerProt"><code>EntanglerProt</code></a> or when a swap happens and  the <a href="#QuantumSavory.ProtocolZoo.EntanglementTracker"><code>EntanglementTracker</code></a> receives an [<code>EntanglementUpdate</code>] message.</p><ul><li><p><code>remote_node::Int64</code>: the id of the remote node to which we are entangled</p></li><li><p><code>remote_slot::Int64</code>: the slot in the remote node containing the qubit we are entangled to</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/ProtocolZoo.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.EntanglementHistory" href="#QuantumSavory.ProtocolZoo.EntanglementHistory"><code>QuantumSavory.ProtocolZoo.EntanglementHistory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EntanglementHistory</code></pre><p>This tag is used to store the outdated entanglement information after a swap. It helps to direct incoming entanglement update messages to the right node after a swap. It helps in situations when locally we have performed a swap, but we are now receiving a message from a distant node that does not know yet that the swap has occurred (thus the distant node might have outdated information about who is entangled to whom and we need to update that information).</p><ul><li><p><code>remote_node::Int64</code>: the id of the remote node we used to be entangled to</p></li><li><p><code>remote_slot::Int64</code>: the slot of the remote node we used to be entangled to</p></li><li><p><code>swap_remote_node::Int64</code>: the id of remote node to which we are entangled after the swap</p></li><li><p><code>swap_remote_slot::Int64</code>: the slot of the remote node to which we are entangled after the swap</p></li><li><p><code>swapped_local::Int64</code>: the slot in this register with whom we performed a swap</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/ProtocolZoo.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.EntanglementTracker" href="#QuantumSavory.ProtocolZoo.EntanglementTracker"><code>QuantumSavory.ProtocolZoo.EntanglementTracker</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EntanglementTracker &lt;: QuantumSavory.ProtocolZoo.AbstractProtocol</code></pre><p>A protocol, running at a given node, listening for messages that indicate something has happened to a remote qubit entangled with one of the local qubits.</p><ul><li><p><code>sim::ConcurrentSim.Simulation</code>: time-and-schedule-tracking instance from <code>ConcurrentSim</code></p></li><li><p><code>net::RegisterNet</code>: a network graph of registers</p></li><li><p><code>node::Int64</code>: the vertex of the node where the tracker is working</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/ProtocolZoo.jl#L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.EntanglementUpdateX" href="#QuantumSavory.ProtocolZoo.EntanglementUpdateX"><code>QuantumSavory.ProtocolZoo.EntanglementUpdateX</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EntanglementUpdateX</code></pre><p>This tag arrives as a message from a remote node to which the current node was entangled to update the entanglement information and apply an <code>X</code> correction after the remote node performs an entanglement swap.</p><ul><li><p><code>past_local_node::Int64</code>: the id of the node to which you were entangled before the swap</p></li><li><p><code>past_local_slot::Int64</code>: the slot of the node to which you were entangled before the swap</p></li><li><p><code>past_remote_slot::Int64</code>: the slot of your node that we were entangled to</p></li><li><p><code>new_remote_node::Int64</code>: the id of the node to which you are now entangled after the swap</p></li><li><p><code>new_remote_slot::Int64</code>: the slot of the node to which you are now entangled after the swap</p></li><li><p><code>correction::Int64</code>: what Pauli correction you need to perform</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/ProtocolZoo.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.EntanglementUpdateZ" href="#QuantumSavory.ProtocolZoo.EntanglementUpdateZ"><code>QuantumSavory.ProtocolZoo.EntanglementUpdateZ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EntanglementUpdateZ</code></pre><p>This tag arrives as a message from a remote node to which the current node was entangled to update the entanglement information and apply a <code>Z</code> correction after the remote node performs an entanglement swap.</p><ul><li><p><code>past_local_node::Int64</code>: the id of the node to which you were entangled before the swap</p></li><li><p><code>past_local_slot::Int64</code>: the slot of the node to which you were entangled before the swap</p></li><li><p><code>past_remote_slot::Int64</code>: the slot of your node that we were entangled to</p></li><li><p><code>new_remote_node::Int64</code>: the id of the node to which you are now entangled after the swap</p></li><li><p><code>new_remote_slot::Int64</code>: the slot of the node to which you are now entangled after the swap</p></li><li><p><code>correction::Int64</code>: what Pauli correction you need to perform</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/ProtocolZoo.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.EntanglerProt" href="#QuantumSavory.ProtocolZoo.EntanglerProt"><code>QuantumSavory.ProtocolZoo.EntanglerProt</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EntanglerProt{LT} &lt;: QuantumSavory.ProtocolZoo.AbstractProtocol</code></pre><p>A protocol that generates entanglement between two nodes. Whenever a pair of empty slots is available, the protocol locks them and starts probabilistic attempts to establish entanglement.</p><ul><li><p><code>sim::ConcurrentSim.Simulation</code>: time-and-schedule-tracking instance from <code>ConcurrentSim</code></p></li><li><p><code>net::RegisterNet</code>: a network graph of registers</p></li><li><p><code>nodeA::Int64</code>: the vertex index of node A</p></li><li><p><code>nodeB::Int64</code>: the vertex index of node B</p></li><li><p><code>pairstate::Any</code>: the state being generated (supports symbolic, numeric, noisy, and pure)</p></li><li><p><code>success_prob::Float64</code>: success probability of one attempt of entanglement generation</p></li><li><p><code>attempt_time::Float64</code>: duration of single entanglement attempt</p></li><li><p><code>local_busy_time_pre::Float64</code>: fixed &quot;busy time&quot; duration immediately before starting entanglement generation attempts</p></li><li><p><code>local_busy_time_post::Float64</code>: fixed &quot;busy time&quot; duration immediately after the a successful entanglement generation attempt</p></li><li><p><code>retry_lock_time::Any</code>: how long to wait before retrying to lock qubits if no qubits are available (<code>nothing</code> for queuing up)</p></li><li><p><code>rounds::Int64</code>: how many rounds of this protocol to run (<code>-1</code> for infinite)</p></li><li><p><code>attempts::Int64</code>: maximum number of attempts to make per round (<code>-1</code> for infinite)</p></li><li><p><code>chooseA::Union{Int64, var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:Function</code>: function <code>Vector{Int}-&gt;Vector{Int}</code> or an integer slot number, specifying the slot to take among available free slots in node A</p></li><li><p><code>chooseB::Union{Int64, var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:Function</code>: function <code>Vector{Int}-&gt;Vector{Int}</code> or an integer slot number, specifying the slot to take among available free slots in node B</p></li><li><p><code>randomize::Bool</code>: whether the protocol should find the first available free slots in the nodes to be entangled or check for free slots randomly from the available slots</p></li><li><p><code>margin::Int64</code>: Repeated rounds of this protocol may lead to monopolizing all slots of a pair of registers, starving or deadlocking other protocols. This field can be used to always leave a minimum number of slots free if there already exists entanglement between the current pair of nodes.</p></li><li><p><code>hardmargin::Int64</code>: Like <code>margin</code>, but it is enforced even when no entanglement has been established yet. Usually smaller than <code>margin</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/ProtocolZoo.jl#L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.EntanglerProt-Tuple{ConcurrentSim.Simulation, RegisterNet, Int64, Int64}" href="#QuantumSavory.ProtocolZoo.EntanglerProt-Tuple{ConcurrentSim.Simulation, RegisterNet, Int64, Int64}"><code>QuantumSavory.ProtocolZoo.EntanglerProt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Convenience constructor for specifying <code>rate</code> of generation instead of success probability and time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/ProtocolZoo.jl#L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.SwapperProt" href="#QuantumSavory.ProtocolZoo.SwapperProt"><code>QuantumSavory.ProtocolZoo.SwapperProt</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SwapperProt{NL, NH, CL, CH, LT} &lt;: QuantumSavory.ProtocolZoo.AbstractProtocol</code></pre><p>A protocol, running at a given node, that finds swappable entangled pairs and performs the swap.</p><p>Consider setting an <code>agelimit</code> on qubits and using it together with the cutoff protocol, <a href="#QuantumSavory.ProtocolZoo.CutoffProt"><code>CutoffProt</code></a>, which deletes qubits that are about to go past their cutoff/retention time.</p><ul><li><p><code>sim::ConcurrentSim.Simulation</code>: time-and-schedule-tracking instance from <code>ConcurrentSim</code></p></li><li><p><code>net::RegisterNet</code>: a network graph of registers</p></li><li><p><code>node::Int64</code>: the vertex of the node where swapping is happening</p></li><li><p><code>nodeL::Any</code>: the vertex of one of the remote nodes for the swap, arbitrarily referred to as the &quot;low&quot; node (or a predicate function or a wildcard); if you are working on a repeater chain, a good choice is <code>&lt;(current_node)</code>, i.e. any node to the &quot;left&quot; of the current node</p></li><li><p><code>nodeH::Any</code>: the vertex of the other remote node for the swap, the &quot;high&quot; counterpart of <code>nodeL</code>; if you are working on a repeater chain, a good choice is <code>&gt;(current_node)</code>, i.e. any node to the &quot;right&quot; of the current node</p></li><li><p><code>chooseL::Any</code>: the <code>nodeL</code> predicate can return many positive candidates; <code>chooseL</code> picks one of them (by index into the array of filtered <code>nodeL</code> results), defaults to a random pick <code>arr-&gt;rand(keys(arr))</code>; if you are working on a repeater chain a good choice is <code>argmin</code>, i.e. the node furthest to the &quot;left&quot;</p></li><li><p><code>chooseH::Any</code>: the <code>nodeH</code> counterpart for <code>chooseH</code>; if you are working on a repeater chain a good choice is <code>argmax</code>, i.e. the node furthest to the &quot;right&quot;</p></li><li><p><code>local_busy_time::Float64</code>: fixed &quot;busy time&quot; duration immediately before starting entanglement generation attempts</p></li><li><p><code>retry_lock_time::Any</code>: how long to wait before retrying to lock qubits if no qubits are available (<code>nothing</code> for queuing up and waiting)</p></li><li><p><code>rounds::Int64</code>: how many rounds of this protocol to run (<code>-1</code> for infinite))</p></li><li><p><code>agelimit::Union{Nothing, Float64}</code>: what is the oldest a qubit should be to be picked for a swap (to avoid swapping with qubits that are about to be deleted, the agelimit should be shorter than the retention time of the cutoff protocol) (<code>nothing</code> for no limit) – you probably want to use <a href="#QuantumSavory.ProtocolZoo.CutoffProt"><code>CutoffProt</code></a> if you have an agelimit</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/swapping.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.Switches.SimpleSwitchDiscreteProt" href="#QuantumSavory.ProtocolZoo.Switches.SimpleSwitchDiscreteProt"><code>QuantumSavory.ProtocolZoo.Switches.SimpleSwitchDiscreteProt</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SimpleSwitchDiscreteProt{AA} &lt;: QuantumSavory.ProtocolZoo.AbstractProtocol</code></pre><p>A switch &quot;controller&quot;, running on a given node, checking for connection requests from neighboring clients, and attempting to serve them by attempting direct raw entanglement with the clients and then mediating swaps to connect two clients together.</p><p>Works on discrete time intervals and destroys raw entanglement not used by the end of a ticktock cycle.</p><p>This switch is mostly based on the architecture proposed in (<a href="../bibliography/#promponas2024maximizing">Promponas <em>et al.</em>, 2024</a>). Multiple switch management algorithms are suggested in that paper. By default we use the <code>QuantumSavory.ProtocolZoo.Switches.promponas_bruteforce_choice</code> algorithm.</p><ul><li><p><code>sim::ConcurrentSim.Simulation</code>: time-and-schedule-tracking instance from <code>ConcurrentSim</code></p></li><li><p><code>net::RegisterNet</code>: a network graph of registers</p></li><li><p><code>switchnode::Int64</code>: the vertex index of the switch</p></li><li><p><code>clientnodes::Vector{Int64}</code>: the vertex indices of the clients</p></li><li><p><code>success_probs::Vector{Float64}</code>: best-guess about success of establishing raw entanglement between client and switch</p></li><li><p><code>ticktock::Float64</code>: duration of a single full cycle of the switching decision algorithm</p></li><li><p><code>rounds::Int64</code>: how many rounds of this protocol to run (<code>-1</code> for infinite)</p></li><li><p><code>assignment_algorithm::Any</code>: the algorithm to use for memory slot assignment, defaulting to <code>promponas_bruteforce_choice</code></p></li><li><p><code>backlog::QuantumSavory.ProtocolZoo.Switches.SymMatrix{Matrix{Int64}}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/switches.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantumSavory.ProtocolZoo.Switches.SwitchRequest" href="#QuantumSavory.ProtocolZoo.Switches.SwitchRequest"><code>QuantumSavory.ProtocolZoo.Switches.SwitchRequest</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SwitchRequest</code></pre><p>Notify a switch that you request to be entangled with another node.</p><ul><li><p><code>requester::Int64</code>: the id of the node making the request</p></li><li><p><code>remote_node::Int64</code>: the id of the remote node to which we want to be entangled</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSavory/QuantumSavory.jl/blob/92bcecb97247d53b818294454bfe89099ab0e38a/src/ProtocolZoo/switches.jl#L336">source</a></section></article><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../API_StatesZoo/">« StatesZoo API</a><a class="docs-footer-nextpage" href="../bibliography/">Bibliography »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 1 April 2025 16:35">Tuesday 1 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
